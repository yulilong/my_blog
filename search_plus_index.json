{"./":{"url":"./","title":"说明","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 说明 1. 文章内容目录 2. 项目开发部署 2.1 本地开发 2.2 服务部署 说明 这是我的个人blog，里面包含了我一些平时整理的资料文档。 github地址：https://github.com/yulilong/my_blog github pages地址：https://yulilong.github.io/my_blog/ 由于有的时候github访问慢、打不开，本人又在码云上部署了同样内容： 码云地址：https://gitee.com/dragon-li/my-wiki 码云 pages地址：http://dragon-li.gitee.io/my-wiki/ 1. 文章内容目录 请参考SUMMARY.md文件。 2. 项目开发部署 本服务使用的是gitbook + github pages托管形式网站。 gitbook使用教程 本地电脑编辑器推荐使用：https://typora.io/ 2.1 本地开发 需要本地电脑里面有终端和nodejs，如果没有请自行查找安装，nodejs官网：http://nodejs.cn/ 1、代码克隆到本地电脑。 2、终端使用npm install gitbook-cli -g 命令安装 gitbook-cli工具，已经安装请忽略。 3、在终端使用npm install命令安装gitbook插件。 4、终端使用npm start命令启动本地开发服务。 5、在浏览器中输入http://localhost:4000/地址查看项目。 2.2 服务部署 终端使用bash deolog.sh命令运行自动部署脚本。 具体部署方法请参照./deploy.sh文件内容。 powered by Gitbook文件最后修改时间： 2021-08-19 09:59:38 "},"SUMMARY.html":{"url":"SUMMARY.html","title":"项目目录","keywords":"","body":" 说明 项目目录 git git介绍、安装、配置 git教程 git教程-高级 git常用功能使用介绍 git常见问题及解决 git代码冲突处理软件P4Merge git内部原理揭秘 动图展示10大Git命令 git忽略文件方法 git daemon命令开启git服务器 使用Gitblit软件开启git服务器 github推送代码方式 Mac Mac下常用的软件 Mac系统操作习惯设置 Mac快捷键和一些常用操作 Mac下终端常用设置、命令、快捷键 Mac下Iterm2使用及快捷键 Mac中常见错误以及处理方法 Mac下vscode编辑器设置 Mac下vscode快捷键 Mac-Office2016使用设置 Mac下Nginx的安装运行 Mac下sublime编辑器设置 Mac下移动硬盘分区用做TimeMachine的备份 Mac下angular开发环境安装 Mac-install-RVM,ruby,pqadmin3,rubymine2016 linux linux下常用的终端命令 linux下常用软件 Linux查找文件内容 find命令详解 linux下Nginx安装配置 centos7下习惯设置 centos7搭建samba方法 centos7错误处理 centos7_VNC_install centos7ruby相关软件安装l Terminal终端快捷键 VIM编辑器常用命令与用法总结 virtualbox虚拟机、centos7安装增强工具 linux下ssh配置 npm yarn node NPM使用介绍 NPM常见问题 package.json文件详解 NPM常用的包 node环境常见问题 yarn说明 window下开发说明 windows下前端开发环境安装 windows常见问题 其他 Chrome浏览器开发者工具使用 Chrome浏览器有用的插件 gitbook入门教程 常用正则表达式 HTTP方法详解 Markdown常用语法 VS2010编译器设置 VS2010开发控制台程序遇到的问题 阻止定向广告 英文字母缩写的含义 工作相关 eslint配置和规范说明 前端打包大小优化 angular angularJS资料 angularJS开发遇见的问题 arcgis开发记录 angular2开发知识点 angular2网页前端执行流程 angular2中引入插件 angular-CLI中一些问题 angular下arcgis开发遇见的问题 angular编程规范 TS_JS中一些知识点 ruby、rails ruby中语法知识 include和extend以及模块中ClassMethods require,load,include,extend的显著区别 Object、Class、Module之间关系 rails中常见问题 ruby比较常用的gems包 ruby_gems命令 国内RubyGems镜像 Ruby中任务构建工具rake的入门学习教程 Ruby中的Rake任务详述 ruby_on_Rails中的Rake教程 rubyor_rails错误解决 ruby面试题 RubyMine常用快捷键 rubymine习惯设置 haml语法符号的含义 manageIQ manageIQ开发环境安装centos manageIQ开发环境安装Mac manageIQ代码结构、框架、执行流程分析 manageIQ汉化 manageIQ网页部分功能代码实现 新建提供者 manageiq各种云平台provide资料 manageIQ服务部署 manageIQ网页图标、图片、网页导航栏风格修改 开发manageiq遇见的问题、错误解决 添加新的Providers代码开发 centos7,rvm,ruby,gems,rails,pqadmin3,rubymine,isntall azure azure获取TenantID、SubscriptionID、ClientID、ClientKey azure开发连接的国内网站 azure-armrest中链接作用 azure使用虚拟机生成私有镜像 面试 JS CSS 问过的问题 JavaScript中各种源码实现 面试资料整理 JS答过的笔试题 CSS答过的笔试题 7个简单棘手的JS问题 浏览器http相关问题 这些前端基础题你能答对几道 后端一次性丢给你10万条数据-怎么处理显示 说说你对options请求的理解 powered by Gitbook文件最后修改时间： 2025-01-07 14:22:43 "},"doc/git/001-git介绍、安装、配置.html":{"url":"doc/git/001-git介绍、安装、配置.html","title":"git介绍、安装、配置","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. GIT介绍 2. 使用GIT的好处 3. GIT 安装 4. GIT 配置 4.1 GIT 初始化设置、命令别名设置 4.2 如果终端安装了oh-my-zsh，会带一堆git命令别名 4.3 GIT配置文件介绍 4.3.1 Linux、Mac OS系统 4.3.2 windows系统 5. git设置远程仓库账号密码(拉取、上传代码不用输入用户名密码) 6. git文件夹详解 7. 图形软件操作工具 [TOC] 1. GIT介绍 git是一个分布式版本控制软件，与常用的版本控制工具如CVS、Subversion不同，支持离线开发，离线存储。强大的分支功能，适合多个独立开发者协作。速度块。用户从远端GIT仓库下载一个工程(project)时，这个工程的所有文件，包括版本历史，文件改动都会下载下来，这时 候本地GIT就演变成了一个服务器，所有的提交(check-in)、提出(check-out)都会在这个本地服务器上执行，当你确定一项修改之后，可 以再和远端仓库进行合并和同步(merge)。所以，GIT的安装和配置步骤无论在本机还是服务器上都是完全一样的。 2. 使用GIT的好处 更顺畅的工作流程，开发过程中，完全可以离线操作 快速，Git分布式架构使得本地仓库包含所有的历史版本信息，你可以在不同的版之间快速切换 弹性的本地分支，在svn下，你建一个分支需要把源代码复制到另外一个文件夹，而在Git下，创建分支的代价是非常小的，只需一条命令 仓库目录结构简洁，用Git复制一个项目，只会在项目根目录创建一个.git的目录，而其他目录很干净 内容按原数据方式存储，所有的版本信息都位于.git目录下 完整性好，更易于协作开发 用户群大，现在已经有成千上万个开源项目采用Git来做项目管理，github上更是有无数个代码仓库 参考链接： http://blog.csdn.net/fyx708711/article/details/52606252 3. GIT 安装 https://git-scm.com/book/zh/v2/起步-安装-Git 1、 linux系统的centos7.2安装： sudo yum update sudo yum install -y git 2、ubuntu 安装(一般系统默认就安装了) # http://www.linuxidc.com/Linux/2016-09/135527.htm sudo apt-get install git 3、Mac OS苹果系统(一般默认就安装了，需要事先安装了homebrew ) brew install git 4、windows系统，安装git终端： https://git-for-windows.github.io/ 安装教程：https://jingyan.baidu.com/article/20095761b48041cb0721b4fc.html 4. GIT 配置 linux、mac系统打开终端进行下面配置。 window系统打开git bash终进行下面端配置。 4.1 GIT 初始化设置、命令别名设置 下面操作linux, Mac OS, window 都适用。 设置用户名和邮箱： # https://git-scm.com/book/zh/v2/起步-初次运行-Git-前的配置 # https://git-scm.com/book/zh/v2/自定义-Git-配置-Git git config --global user.name name # 设置GIT的用户名 git config --global user.email you_email_addr@gmail.com # 设置GIT的邮箱 必须要的配置： git config --global core.mergeoptions --no-edit # 关闭git pull产生的merge信息 # git config --global commit.template ~/.gitmessage.txt # git 提交时编辑里面的模板 # 终端内容显示颜色：false：关闭， auto：自动，有的颜色会忽略， always：忽略掉管道和终端的不同，即在任何情况下着色输出 git config --global color.ui false # 使用VIM编辑器编辑作为GIT的默认编辑器 git config --global core.editor vim # 存储credential(凭证)，自动保存远程仓库账号密码 git config --global credential.helper store # https://git-scm.com/book/zh/v2/Git-工具-凭证存储 # 关闭对0x80以上的字符进行quote， 解决git的中文乱码问题。 git config --global core.quotepath false # 自动转换LF和CRLF(不同操作系统换行不同问题)。 git config --global core.autocrlf true # 把CRLF自动转换警告取消 git config --global core.safecrlf false # 设置git识别大小写 git config core.ignorecase false # 修改git log中时间的显示格式为 2021-07-14 10:13:17 +0800 git config --global log.date iso8601 git config --global --replace-all log.date format:'%Y-%m-%d %H:%M:%S' # 查看上面的配置 git config --list # 查看git路径 which git # 删除一个配置项 git config --global --unset log.date # 编辑配置文件 git config --global --edit GIT命令别名 方便操作快捷(频繁git操作的时候，命令简化。): git config --global alias.co checkout git config --global alias.ci commit git config --global alias.st status git config --global alias.br branch git config --global alias.hist 'log --pretty=format:\"%h %ad | %s%d [%an]\" --graph --date=short' git config --global alias.type 'cat-file -t' git config --global alias.dump 'cat-file -p' # log 只显示修改的文件 git config --global alias.ls 'log --stat' # log 只用一行显示信息 git config --global alias.one 'log --pretty=oneline' 4.2 如果终端安装了oh-my-zsh，会带一堆git命令别名 Mac 用户和 Linux 用户通过在您的终端中运行以下命令来安装oh-my-zsh： sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" oh-my-zsh带的git命令别名： g - git gst - git status gl - git pull gup - git pull --rebase gp - git push gd - git diff gdc - git diff --cached gdv - git diff -w \"$@\" | view gc - git commit -v gc! - git commit -v --amend gca - git commit -v -a gca! - git commit -v -a --amend gcmsg - git commit -m gco - git checkout gcm - git checkout master gr - git remote grv - git remote -v grmv - git remote rename grrm - git remote remove gsetr - git remote set-url grup - git remote update grbi - git rebase -i grbc - git rebase --continue grba - git rebase --abort gb - git branch gba - git branch -a gcount - git shortlog -sn gcl - git config --list gcp - git cherry-pick glg - git log --stat --max-count=10 glgg - git log --graph --max-count=10 glgga - git log --graph --decorate --all glo - git log --oneline --decorate --color glog - git log --oneline --decorate --color --graph gss - git status -s ga - git add gm - git merge grh - git reset HEAD grhh - git reset HEAD --hard gclean - git reset --hard && git clean -dfx gwc - git whatchanged -p --abbrev-commit --pretty=medium gsts - git stash show --text gsta - git stash gstp - git stash pop gstd - git stash drop ggpull - git pull origin $(current_branch) ggpur - git pull --rebase origin $(current_branch) ggpush - git push origin $(current_branch) ggpnp - git pull origin $(current_branch) && git push origin $(current_branch) glp - _git_log_prettily 参考资料： https://segmentfault.com/a/1190000007145316 https://www.hinjin.com/2018/04/13/%E5%A6%82%E4%BD%95%E5%8A%A0%E5%BF%AB%E4%BD%A0%E7%9A%84git%E6%93%8D%E4%BD%9C%EF%BC%9F/ 4.3 GIT配置文件介绍 4.3.1 Linux、Mac OS系统 Git 使用一系列配置文件来保存你自定义的行为。它首先会查找 /etc/gitconfig 文件，该文件含有系统里每位用户及他们所拥有的仓库的配置值。 如果你传递 --system 选项给 git config，它就会读写该文件。接下来 Git 会查找每个用户的 ~/.gitconfig 文件（或者 ~/.config/git/config 文件）。 你可以传递 --global 选项让 Git 读写该文件。最后 Git 会查找你正在操作的版本库所对应的 Git 目录下的配置文件（.git/config）。 这个文件中的值只对该版本库有效。以上三个层次中每层的配置（系统、全局、本地）都会覆盖掉上一层次的配置，所以 .git/config 中的值会覆盖掉 /etc/gitconfig 中所对应的值。 4.3.2 windows系统 windows7系统： C:\\Documents and Settings\\用户名，其中有一个.gitconfig的文件。windows8系统： C盘 -> 用户(Users) -> 用户名 文件夹下，有个.gitconfig的文件。 在上述那个目录底下， 可发现另外一个文件.git-credentials，里面记录的就是用户名密码了。 5. git设置远程仓库账号密码(拉取、上传代码不用输入用户名密码) github Personal access tokens 使用token可以不需要密码就可以读取远程仓库代码，如果你的远程仓库网站提供了账户访问token，那么设置一个access tokens。 github网站登陆后， 点击右上角的用户图标 -> settings -> 选择 Developer settings -> 选择 Personal access tokens，或者打开链接https://github.com/settings/tokens 使用： git clone https://github.com/username/repo.git username: your email Password: your access tokens 由于github在2021-08-13禁止了用户名、密码形式，所以需要使用如下形式： # git clone https://oauth2:[access tokens]@github.com/user/repo git clone https://oauth2:ghp_GjguOh******KZm@github.com/user/repo # 修改仓库 git remote set-url origin https://oauth2:ghp_GjguOh******ThzKZm@github.com/user/repo 码云仓库有类似的：码云 私人令牌 git-credentials git读取账号密码文件 这里是为了你在拉取代码的时候不用在输入用户名密码了， 但是这里会暴露你远程仓库的用户名密码，注意保密，如果电脑不用了记得删除这个文件。 # 打开文件，如果没有则会自动创建文件 $ vim ~/.git-credentials # 编辑好文件后运行git命令来让文件生效 $ git config --global credential.helper store 里面文件内容： http://用户名:密码或token@仓库地址 http://yulilong:password@192.168.102.9 https://yulilong:password@bitbucket.org http://yulilong:password@bitbucket.org https://yulilong:5199818388420@github.com http://yulilong:github_Personal_access_tokens@github.com 6. git文件夹详解 探索.git目录 .git文件夹详解 Git 内部原理 7. 图形软件操作工具 有的可能不适应命令行的复杂， 所以有一款图形化操作软件，并且带终端的软件。 网址：https://git-scm.com/ 下载地址：https://git-scm.com/downloads 这个软件在window下自带命令行工具， 可以直接在打开文件夹中鼠标右键用命令行打开这个文件夹，使用非常方便。b powered by Gitbook文件最后修改时间： 2025-01-14 16:07:16 "},"doc/git/002-git教程.html":{"url":"doc/git/002-git教程.html","title":"git教程","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 git使用教程-基础 一、电脑本地初始化一个仓库 1.1 git init: 初始化一个电脑上本地仓库 1.2 创建远程仓库： 存放代码 1.3 本地Git添加远程仓库地址 1.3.1 git remote add shortname url： 添加仓库 1.3.2 git remote -v：查看本地git的远程仓库地址 1.3.3 git remote show [remote-name] ：查看远程仓库详细信息 1.4 远程仓库的重命名、删除、修改地址 二、从远程仓库(服务器)获取代码 2.1 本地没有仓库，新建仓库 2.1.1 拉取默认分支代码：git clone [代码地址] 2.1.2 自定义本地仓库文件名： git clone [代码地址] [新名字] 2.1.3 拉取特定分之的代码：git clone -b [分支名] [代码地址] 2.1.4 拉取特定标签(tag)的代码：git clone -b [标签名] [代码地址] 2.2 本地已经存在了仓库 2.2.1 拉取新分支代码：git checkout -b [分支名] [仓库名]/[分支名] 2.2.2 有多个远程仓库，拉取指定仓库：git pull [仓库名] [分支名] 2.2.3 当前分支拉取别的分支代码：git pull [仓库名] [分支名] 三、记录每次更新到仓库 3.1 GIT中文件状态介绍(已跟踪/未跟踪) 3.2 已跟踪的两种状态 3.2.1 已暂存(Changes to be committed) 3.2.2 已修改(Changes not staged for commit) 3.2.3 未跟踪(Untracked files) 3.2 git status: 查看当前文件状态 3.3 git status -s紧凑格式输出 3.4 GIT代码管理：改变文件的状态 3.4.1 git add 3.4.2 git checkout -- file： 撤消对文件的修改 3.4.3 git reset HEAD file：取消暂存的文件 3.5 .gitignore：忽略文件，不纳入GIT版本控制 3.6 git diff: 查看代码修改详细内容 3.6.1 git diff： 查看尚未暂存的文件修改记录 3.6.2 git diff --staged： 查看已暂存文件修改记录 3.6.3 git diff 的其他用法: --stat HEAD SHA1 3.7 把代码纳入版本控制中： 提交更新 git commit 3.7.1 commit命令的其他的用法： -m选项，提交信息简写 3.7.2 commit命令的其他的用法： -a选项,提交所有修改过的文件（已暂存，已修改） 3.8 git push： 把代码推送到远程仓库上 3.8.1 仓库名、分支名一样：git push 3.8.2 推送到特定仓库、分支：git push 仓库名 本地分支名:远程分支名 3.9 git push -u:设置默认推送仓库 四、 查看提交历史: git log 4.1 git log 的常用选项: -stat, -p, --name-status, --pretty=oneline, --abbrev-commit 4.1.1 git log --stat:显示每次更新的文件修改统计信息(修改的文件名，每个文件添加的多少、删除了多少数字)。 4.1.2 git log --name-only: 只显示修改的文件名，没有其他信息 4.1.3 git log --pretty=oneline: 用一行显示信息 五、 GIT分支 5.1 本地分支的创建、切换、删除： 5.1.1 创建分支：git branch testing 5.1.2 切换分支：git checkout testing 5.1.3 创建并切换到新分支：git checkout -b testing 5.1.4 删除分支：git branch -d testing 5.1.5 删除远程仓库已经不存在的分支引用：git remote prune origin 5.2 远程仓库分支的新建与删除 5.2.1 远程仓库分支的新建： git push origin testing 5.2.2 删除远程仓库的无用分支：git push origin --delete testing 5.3 本地分支跟踪远程分支 5.3.1 默认分支追踪 5.3.2 本地分支追踪远程仓库另外分支 5.3.3 分支追踪修改 5.3.4 查看本地分支和远程分支的跟踪关系：git branch -vv 5.4 分支合并：git merge 5.4.1 合并命令：git merge [分支名] 5.4.2 合并过程中代码有冲突，解决冲突 5.4.3 取消合并 六、 打标签(一个版本发布) git tag 6.1 什么是标签？ 6.2 查看现有的标签 6.2.1 拉取服务器上的新标签：git pull 6.2.2 查看所有标签：git tag 6.2.3 查看符合条件的标签：git tag -l 'v1.*' 6.2.4 查看一个标签的详细信息：git show tag名字 6.3 创建标签：Git 使用两种主要类型的标签： 6.3.1 git tag -a:创建附注标签（annotated） 6.3.2 git tag V1.4: 创建轻量标签（lightweight） 6.3.3 git tag -a v1.2 9fceb02：对某个历史提交打标签(后期打标签) 6.4 把创建的标签推送到服务器上：git push origin [tagname] 6.5 检出标签: 代码变成标签的样子 6.6 删除标签 6.6.1 git tag -d v1.0:删除本地标签 6.6.2 git push origin :refs/tags/v0.1:删除服务器标签 常用命令 7. git 一些查看命令 8. 获取Git仓库 9. git tag — 标签相关操作 10. 代码存储，代码修改记录:git stash, git diff tmp.patch 11. 分支管理 12. git 回滚到某个commit 13. git 查看改动 14. git恢复删除的文件 15. \"git rm\" 和 \"rm\" 的区别 16. 关闭git pull产生的merge 信息 16.1 git pull 产生merge信息的原因 16.2 解决 17. git pull文件时和本地文件冲突 18. git删除远程仓库的一次commit提交 [TOC] 参考资料： 廖雪峰git教程 git使用教程-基础 一、电脑本地初始化一个仓库 1.1 git init: 初始化一个电脑上本地仓库 终端进入项目目录，输入： $ git init 该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。详细介绍； https://git-scm.com/book/zh/v2/Git-基础-获取-Git-仓库 1.2 创建远程仓库： 存放代码 目前我知道的git网站仓库： 码云:https://gitee.com/共有仓库、私有仓库都免费使用， 国内访问速度快。 github:https://github.com/共有仓库免费使用， 私有仓库收费， 有时候访问速度慢。 Bitbucket:https://bitbucket.org/共有仓库、私有仓库都免费使用， 但是免费的最多只能有5个用户对仓库进行读写，超过的就需要付费。访问速度有时很慢。 gitlab:公司自建的git服务器，随意使用。 创建仓库都差不多，在网站中点击新建仓库，然后选择仓库的类型(公有、私有)，然后点击创建即可。 1.3 本地Git添加远程仓库地址 1.3.1 git remote add ： 添加仓库 本地git初始化后，此时还没有添加远程仓库地址，需要添加一个远程仓库地址才能上传代码到服务器。可在终端中运行git remote add 添加一个新的远程 Git 仓库。shortname是url的简写，当上传代码的时候，可用这个简写代替url地址。命令详细介绍：https://git-scm.com/book/zh/v2/Git-基础-远程仓库的使用 $ git remote add pb https://github.com/paulboone/ticgit 1.3.2 git remote -v：查看本地git的远程仓库地址 当添加好远程仓库后，可以使用命令来查看添加的仓库是否正确。 # 列出你指定的每一个远程服务器的简写 $ git remote origin # 指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。 $ git remote -v origin https://github.com/schacon/ticgit (fetch) origin https://github.com/schacon/ticgit (push) 1.3.3 git remote show [remote-name] ：查看远程仓库详细信息 如果想要查看某一个远程仓库的更多信息，可以使用 git remote show [remote-name] 命令。如果想以一个特定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息： $ git remote show origin * remote origin Fetch URL: https://github.com/schacon/ticgit Push URL: https://github.com/schacon/ticgit HEAD branch: master Remote branches: master tracked dev-branch tracked Local branch configured for 'git pull': master merges with remote master Local ref configured for 'git push': master pushes to master (up to date) 1.4 远程仓库的重命名、删除、修改地址 重命名远程仓库引用名字(git remote rename 旧名字 新名字)： $ git remote rename pb paul # 将 pb 重命名为 paul $ git remote origin paul 这同样也会修改你的远程分支名字。 那些过去引用 pb/master 的现在会引用 paul/master。 删除一个远程仓库(git remote rm 仓库名)： $ git remote rm paul $ git remote origin 修改仓库地址： git remote set-url origin https://gitee.com/username/repo.git # 设置改为access token git remote set-url origin https://oauth2:ghp_GjguOh******ThzKZm@github.com/yulilong/front-end-doc 或者直接修改git配置文件： cd .git vi config 关于远程仓库详细介绍 二、从远程仓库(服务器)获取代码 2.1 本地没有仓库，新建仓库 2.1.1 拉取默认分支代码：git clone [代码地址] 如果本地没有代码，远程仓库有代码，则需要从远程仓库克隆代码。 克隆仓库的命令格式是 git clone [url] 。 比如，要克隆 Git 的可链接库 libgit2，可以用下面的命令： $ git clone https://github.com/libgit2/libgit2 这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹，从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。如果你进入到这个新建的 libgit2 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。 2.1.2 自定义本地仓库文件名： git clone [代码地址] [新名字] 如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令： $ git clone https://github.com/libgit2/libgit2 mylibgit 这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为 mylibgit。 关于克隆远程仓库命令详细介绍：https://git-scm.com/book/zh/v2/Git-基础-获取-Git-仓库 2.1.3 拉取特定分之的代码：git clone -b [分支名] [代码地址] 如果不想克隆默认分之的代码， 也可以克隆特定分之的代码： $ git clone -b pages-aliyun https://gitee.com/dragon-li/front-end-doc Cloning into 'front-end-doc'... remote: Enumerating objects: 941, done. remote: Counting objects: 100% (941/941), done. remote: Compressing objects: 100% (463/463), done. remote: Total 2633 (delta 615), reused 697 (delta 470), pack-reused 1692 Receiving objects: 100% (2633/2633), 21.79 MiB | 2.26 MiB/s, done. Resolving deltas: 100% (1610/1610), done. 2.1.4 拉取特定标签(tag)的代码：git clone -b [标签名] [代码地址] git允许直接克隆特定分之的代码，不过克隆好后，项目里没有分之，需要自己创建一个分支： $ git clone -b V2.2 http://192.168.102.9/jas-paas/cloudlink-front-framework.git Cloning into 'cloudlink-front-framework'... remote: Counting objects: 14436, done. remote: Compressing objects: 100% (3072/3072), done. remote: Total 14436 (delta 11224), reused 14226 (delta 11075) Receiving objects: 100% (14436/14436), 17.93 MiB | 4.70 MiB/s, done. Resolving deltas: 100% (11224/11224), done. Note: checking out 'eeea534cdae1f82c48c7b0de8f9993b54ffa065d'. You are in 'detached HEAD' state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by performing another checkout. If you want to create a new branch to retain commits you create, you may do so (now or later) by using -b with the checkout command again. Example: git checkout -b 从信息中就可以看见，克隆特定标签的项目后，是没有分之的，需要进入项目目录后，使用命令创建一个分支： $ git checkout -b V2.2 2.2 本地已经存在了仓库 2.2.1 拉取新分支代码：git checkout -b [分支名] [仓库名]/[分支名] 例如，本地就一个master分支，远程有2个分支(master,develop)，把远程的develop拉取到本地： # 本地的分支是干净的，也就是没有修改的文件 # 获取远程所有分支名字 ~ git fetch # 显示远程所有分支名字 ~ git branch -a # 提取远程新分支到本地 ~ git checkout -b develop origin/develop 2.2.2 有多个远程仓库，拉取指定仓库：git pull [仓库名] [分支名] 比如 远程仓库有2个： origin、github，默认残酷史origin，如果想要来去github仓库的代码： ~ git pull github master 2.2.3 当前分支拉取别的分支代码：git pull [仓库名] [分支名] 比如，当前是test分支，需要拉取develop分支代码，运行如下命令： git pull origin develop 三、记录每次更新到仓库 3.1 GIT中文件状态介绍(已跟踪/未跟踪) 工作目录下每个文件只有两种状态： 3.2 已跟踪的两种状态 指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。git会自动管理已跟踪的文件，记录文件处于什么状态中。 3.2.1 已暂存(Changes to be committed) 文件在这个状态下的，说明已经准备好把文件提交了，可以把这次代码变动记录保存在历史记录中。这个状态为GIT可以提交的内容。 3.2.2 已修改(Changes not staged for commit) 这状态下的文件， git只是知道修改了那些内容，但是并不会在提交代码的时候把这部分内容提交上去。如果需要提交这部分代码需要使用命令git add 把文件添加到 已暂存中，然后提交代码。 3.2.3 未跟踪(Untracked files) 工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。git不会去管理这些文件。 3.2 git status: 查看当前文件状态 使用git status命令可以查看文件处于什么状态，例如： $ git status On branch P02 // 告诉你当前是哪个分之下 Your branch is up-to-date with 'origin/P02'. // 当前分之是从哪个仓库更新的 Changes to be committed: // 已暂存状态 (use \"git reset HEAD ...\" to unstage) // 使用这个命令可回退到Changes not staged for commit: modified: fileName.ts Changes not staged for commit: // 已跟踪文件的内容发生了变化 (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: test.txt Untracked files: // 未跟踪的文件 (use \"git add ...\" to include in what will be committed) src/library/ 在git status命令输出的信息中： Changes to be committed:已暂存状态如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。 Changes not staged for commit:已跟踪文件的内容发生了变化，但还没有放到暂存区。 Untracked files:未跟踪的文件，意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”，这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。 3.3 git status -s紧凑格式输出 使用git status -s命令或git status --short命令，你将得到一种更为紧凑的格式输出。 $ git status -s M README // 出现在右边的 M 表示该文件被修改了但是还没放入暂存区 MM Rakefile // 文件已经放入暂存区，但是又修改过了，在已修改中也存在 A lib/git.rb // 新添加到暂存区中的文件前面有 A 标记 M lib/simplegit.rb // 出现在靠左边的 M 表示该文件被修改了并放入了暂存区 ?? LICENSE.txt // 新添加的未跟踪文件前面有 ?? 标记 3.4 GIT代码管理：改变文件的状态 3.4.1 git add git add命令是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。例子：src/test.txt文件是一个未跟踪文件，可使用git add命令开始跟踪： $ git add src/test.txt //指定单个文件添加 $ git add src/* //指定src目录下所有文件都添加 3.4.2 git checkout -- ： 撤消对文件的修改 如果你并不想保留对 CONTRIBUTING.md 文件的修改,将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）可使用如下命令： git checkout -- CONTRIBUTING.md 注：你需要知道 git checkout -- [file] 是一个危险的命令，这很重要。你对那个文件做的任何修改都会消失 - 你只是拷贝了另一个文件来覆盖它。除非你确实清楚不想要那个文件了，否则不要使用这个命令。 3.4.3 git reset HEAD ：取消暂存的文件 如果你在提交代码的时候，不想提交一些文件，可使用该命令把文件从暂存中回退到已修改的文件中。 git reset HEAD CONTRIBUTING.md 关于撤销操作的详细介绍： https://git-scm.com/book/zh/v2/Git-基础-撤消操作 3.5 .gitignore：忽略文件，不纳入GIT版本控制 一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。在这种情况下，我们可以在项目根目录创建一个名为 .gitignore 的文件，列出要忽略的文件模式。 文件 .gitignore 的格式规范如下： 所有空行或者以 ＃ 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。 一个 .gitignore 文件的例子： # 忽略所有后缀为 .a 的文件 *.a # 但是要跟踪lib.a，即使你上面忽略了 .a文件 !lib.a # 仅忽略当前目录的TODO文件夹， 不是subdir/TODO /TODO # 忽略build /目录中的所有文件 build/ # 忽略doc / notes.txt，而不是doc / server / arch.txt doc/*.txt # 忽略doc 目录中的所有.pdf文件 doc/**/*.pdf GitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表:https://github.com/github/gitignore 这部分详细介绍： https://git-scm.com/book/zh/v2/Git-基础-记录每次更新到仓库 3.6 git diff: 查看代码修改详细内容 如果你想知道文件具体修改了什么，可以用git diff命令。 3.6.1 git diff： 查看尚未暂存的文件修改记录 git diff命令查看修改之后还没有暂存起来的变化内容。也就是git status命令输出信息中，Changes not staged for commit:下面的文件， 例如： $ git diff # 查看所有详细修改 $ git diff 1.txt # 只查看 1.txt文件的 详细修改 //输出信息如下 diff --git a/.gitignore b/.gitignore # ① index e722882..f98470c 100644 # ② --- a/.gitignore # ③ +++ b/.gitignore # ③ @@ -3,8 +3,8 @@ # ④ *~ *.sw[mnpcod] -.DS_Store # ⑤ *.log # ⑥ +text.t # ⑦ *.tmp *.tmp.* log.txt ① git格式的diff,进行比较的是，a版本的.gitignore（即变动前）和b版本的.gitignore（即变动后）。② 表示两个版本的git哈希值（index区域的e722882对象，与工作目录区域的f98470c对象进行比较）， 最后的六位数字是对象的模式（普通文件，644权限）。③ 表示进行比较的两个文件。 \"---\"表示变动前的版本，\"+++\"表示变动后的版本。④ 下面代码所在的行： -3,7： 修改前下面信息变化的行， 从第3行开始一直到第7行 +3,6： 修改后下面信息变化的行， 从第3行开始一直到第6行⑤ 以- 开头表示删除的代码⑥ 以空格开头表示没有修改 ⑦ 以+开头便是增加的代码 git diff输出结果介绍 3.6.2 git diff --staged： 查看已暂存文件修改记录 查看已暂存的将要添加到下次提交里的内容可是使用命令git diff --staged(GIT版本1.6.1以上)。 也可以使用git diff --cached命令。 git diff --staged # 查看所有已暂存文件的修改记录 git diff --staged t.txt # 只查看1.txt文件 已暂存的修改记录 3.6.3 git diff 的其他用法: --stat HEAD SHA1 ~ git diff --stat # 查看简单的diff结果，只查看修改的文件名、修改了多少内容 ~ git diff HEAD # 查看所有修改记录(已暂存、已修改)：显示工作版本(Working tree)和HEAD的差别 ~ git diff topic master # 直接将两个分支上最新的提交做diff ~ git diff HEAD^ HEAD # 比较上次提交commit和上上次提交 ~ git diff SHA1 SHA2 # 比较两个历史版本之间的差异 3.7 把代码纳入版本控制中： 提交更新 git commit 当所有需要提交的代码都放到暂存区后，就可以提交代码了： $ git commit 这种方式会启动文本编辑器以便输入本次提交的说明。一般都是 vim 或 emacs。使用 git config --global core.editor 命令设定你喜欢的编辑软件。编辑器会显示类似下面的文本信息（本例选用 Vim 的屏显方式展示）： // # Please enter the commit message for your changes. Lines starting // # with '#' will be ignored, and an empty message aborts the commit. // # On branch master // # Changes to be committed: // # new file: README // # modified: CONTRIBUTING.md // # // ~ // ~ // \".git/COMMIT_EDITMSG\" 9L, 283C 可以在这段文本信息中看见， 所有以#符号开头的行，都会被忽略，也就是#是注释行，不会放到提交信息中去。接下来就可以输入一些提交信息了，关于写提交信息的建议： 信息应当以少于 50 个字符（25个汉字）的单行开始且简要地描述变更，接着是一个空白行，再接着是一个更详细的解释。Git 项目要求一个更详细的解释，包括做改动的动机和它的实现与之前行为的对比 - 这是一个值得遵循的好规则。 提交信息简单的模板： 修改的摘要（50 个字符或更少） 如果必要的话，加入更详细的解释文字。在 大概 72 个字符的时候换行。在某些情形下， 第一行被当作一封电子邮件的标题，剩下的 文本作为正文。分隔摘要与正文的空行是 必须的（除非你完全省略正文）；如果你将 两者混在一起，那么类似变基等工具无法 正常工作。 3.7.1 commit命令的其他的用法： -m选项，提交信息简写 在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行，如下所示： $ git ci -m \"测试提交\" [master f949399] 测试提交 1 file changed, 1 insertion(+) 从输出的信息中可以看见：当前是在哪个分支（master）提交的，本次提交的完整 SHA-1 校验和是什么（f949399），以及在本次提交中，有多少文件修订过，多少行添加和删改过。 注意：提交时记录的是放在暂存区域的快照。 任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。 3.7.2 commit命令的其他的用法： -a选项,提交所有修改过的文件（已暂存，已修改） 有时候把修改的提交到暂存区，然后在提交代码比较繁琐， GIT提供了一种-a选项，在提交代码的时候，跳过暂存区，把所有已经跟踪的文件暂存起来一并提交，从而跳过git add步骤，例如： $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: CONTRIBUTING.md no changes added to commit (use \"git add\" and/or \"git commit -a\") $ git commit -a -m 'added new benchmarks' [master 83e38c7] added new benchmarks 1 file changed, 5 insertions(+), 0 deletions(-) 从输出信息中可以看到：提交之前不再需要 git add 文件“CONTRIBUTING.md”了。 关于git commit命令详解：https://git-scm.com/book/zh/v2/Git-基础-记录每次更新到仓库 3.8 git push： 把代码推送到远程仓库上 3.8.1 仓库名、分支名一样：git push 如果你本地的分支名称和远程名称相同：则可使用it push [remote-name] [branch-name]命令。 比如，你想要将 master 分支推送到 origin 服务器时： $ git push origin master # 把更新上传到 origin服务器的 master分之上。 $ git push # 上传本地所有分支代码到远程对应的分支上 3.8.2 推送到特定仓库、分支：git push 仓库名 本地分支名:远程分支名 本地分支跟远程仓库分支不同：需要制定本地和远程的分支名称，比如远程仓库名字是basic，本地分支名字是dev，远程分支名字是newTemplate，则使用如下命令： git push basic dev:newTemplate 如果本地没有设置过远程仓库名字，也可以直接使用仓库地址形式： git push http://mayun/user/abc-frontend.git dev:feture 3.9 git push -u:设置默认推送仓库 git push -u origin命令用来在推送代码的时候，指定origin源仓库为默认跟踪源，下次就可以直接使用git push 命令把代码直接推送到这个默认的仓库源。 如果你的远程仓库只有一个，那么这个仓库就是默认的源，直接使用git push也是一样的， 但是当远程仓库有多个源的时候，比如： ~ git remote -v bitbucket https://bitbucket.org/user/jack.git (fetch) bitbucket https://bitbucket.org/user/jack.git (push) origin https://gitee.com/dragon-li/jack.git (fetch) origin https://gitee.com/dragon-li/jack.git (push) 由于bitbucket是后加进来的，如果在推送代码的时候，同时设置这个仓库为默认源，则可以使用：git push -u bitbucket命令，这样下次直接git push命令就可以，设置后，origin仓库的源代码推送就需要指定源：git push origin。 四、 查看提交历史: git log 在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 git log 命令： $ git log commit ca82a6dff817ec66f44342007202690a93763949 // 提交的 SHA-1 校验和 Author: Scott Chacon // 作者的名字和电子邮件地址 Date: Mon Mar 17 21:52:11 2008 -0700 // 提交时间 changed the version number // 提交说明 commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 Author: Scott Chacon Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary test 默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。 4.1 git log 的常用选项: -stat, -p, --name-status, --pretty=oneline, --abbrev-commit 4.1.1 git log --stat:显示每次更新的文件修改统计信息(修改的文件名，每个文件添加的多少、删除了多少数字)。 4.1.2 git log --name-only: 只显示修改的文件名，没有其他信息 4.1.3 git log --pretty=oneline: 用一行显示信息 $ git log 1.txt # 查看 1.txt文件的历史修改记录。 $ git log -n # 只查看前n次修改记录，例如查看前2次的记录： git log -2 $ git log -p # 按补丁格式显示每个更新之间的差异。 $ git log --shortstat # 只显示 --stat 中最后的行数修改添加移除统计。 $ git log --name-status # 显示新增、修改、删除的文件清单。 $ git log --abbrev-commit # 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。 $ git log --relative-date # 使用较短的相对时间显示（比如，“2 weeks ago”）。 $ git log --graph # 显示 分支合并历史。 $ git log --pretty=oneline # 用一行显示信息 // 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。 关于git log命令详解 五、 GIT分支 Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 master。在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 它会在每次的提交操作中自动向前移动。 分支作用： 开发多个项目任务，比如说我有两个任务都比较紧急，任务1需要两天完成，任务2需要一天完成，而任务1是之前就已经开始进行的，任务二是中间加的新任务，所以需要第一天就完成任务2. master分支始终要保证可发布的状态，用dev分支和bug分支进行开发和错误调试，这样能够保证主干代码的干净、可发布。 自己开发测试或者修复BUG等等，可以避免代码的丢失。 5.1 本地分支的创建、切换、删除： 5.1.1 创建分支：git branch testing 比如，创建一个 testing 分支， 你需要使用 git branch 命令： $ git branch testing 这条命令会根据当前的分支来创建一个新分支，分支中内容与当前分支内容完全一样。git branch命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。 5.1.2 切换分支：git checkout testing 要切换到一个已存在的分支，你需要使用git checkout命令。 我们现在切换到新创建的 testing 分支去： $ git checkout testing 5.1.3 创建并切换到新分支：git checkout -b testing $ git checkout -b testing Switched to a new branch \"testing\" 这个命令会创建一个分支并切换到新分支中去， 实际上他是上面2条命令的简化版。 5.1.4 删除分支：git branch -d testing 删除一个分支的时候，你不能在要删除的分支中，要切换到别的分支中，否则会报错。如果要删除 testing分支，可以使用带 -d 选项的 git branch 命令来删除分支： $ git br -d testing Deleted branch testing (was 4baf2a3). 5.1.5 删除远程仓库已经不存在的分支引用：git remote prune origin 有的时候查看所有分支的时候，会发现有很多在远程仓库已经删除的分支引用。则可以使用prune命令删除不存在的分支引用： git branch -a # 查看所有分支 git remote show origin # 查看本地分支对应的远程分支的状态 git remote prune origin # 删除没有对应的远程分支 5.2 远程仓库分支的新建与删除 5.2.1 远程仓库分支的新建： git push origin testing 如果想把本地的新分支推送到远程仓库，可使用 git push [远程仓库名] [分支名]： $ git br -a testing * master remotes/origin/master $ git push origin testing Total 0 (delta 0), reused 0 (delta 0) To http://192.168.132.55/user/test.git * [new branch] testing -> testing 5.2.2 删除远程仓库的无用分支：git push origin --delete testing 如果远程仓库某个分支无用了，想要删除，可以运行带有 --delete 选项的 git push 命令来删除一个远程分支： git push origin --delete testing To http://192.168.132.55/user/test.git - [deleted] testing 5.3 本地分支跟踪远程分支 当本地新建一个分支，使用git push命令推送是，会报错： ~ git push fatal: The current branch tmp has no upstream branch. To push the current branch and set the remote as upstream, use git push --set-upstream origin tmp 因为当前分支没有追踪远程指定的分支的话，当前分支指定的版本快照不知道要作为服务器哪一个分支的版本快照的子节点。简单来说就是：不知道要推送给哪一个分支。 如何建立跟踪远程分支？ 5.3.1 默认分支追踪 1、假如远程仓库默认分支是master，克隆代码时，本地master分支将自动追踪origin/master分支。 git clone URL 2、本地拉取仓库新分支develop时，本地新建的develop将自动追踪origin/develop远程分支。 git checkout -b develop origin/develop 3、本地新建分支，远程仓库没有这个分支，则使用如下命令推送代码同事建立追踪： git push --set-upstream origin branch-name 5.3.2 本地分支追踪远程仓库另外分支 可以使用--set-upstream，还可以使用--set-upstream-to，前者已经被弃用了， ~ git branch --set-upstream-to=basic-web/develop basic-web Branch 'basic-web' set up to track remote branch 'develop' from 'basic-web'. 作用：追踪远程分支basic-web/develop到本地分支basic-web，如果远程没有develop分支会报错，需要先创建远程分支。报错信息： git branch --set-upstream-to=basic-web/develop basic-web error: the requested upstream branch 'basic-web/develop' does not exist hint: hint: If you are planning on basing your work on an upstream hint: branch that already exists at the remote, you may need to hint: run \"git fetch\" to retrieve it. hint: hint: If you are planning to push out a new local branch that hint: will track its remote counterpart, you may want to use hint: \"git push -u\" to set the upstream config as you push. 还有一种情况：如果两个远程仓库地址一样，那么设置也会报错，需要先修改一个仓库地址。 弃用的方法：将branch-name分支追踪远程分支origin/branch-name: git branch --set-upstream branch-name origin/branch-name 5.3.3 分支追踪修改 修改当前分支跟踪远程分支origin/develop git branch -u origin/develop 或者直接打开项目中.git文件夹中config文件： 1、[remote \"origin\"]这一项是修改对应远程Git仓库地址 2、[branch \"master\"]这一项是修改本地分支‘master’的远程追踪关系分支，直接修改merge = refs/heads/master为 3、再次通过命令行查看状态就可以发现你的远程分支已经改掉。 5.3.4 查看本地分支和远程分支的跟踪关系：git branch -vv git branch -vv basic-web e389f6d [basic-web/develop] xx develop 6f1c493 [origin/develop] 提交信息 [分支名字] [提交hash值] [远程仓库分支] [提交信息] merge-tmp e0bd5b7 Merge 如果本地分支没有追踪远程仓库分支，那么就不会显示追踪的远程仓库。 5.4 分支合并：git merge 如果一个分支的功能开发完毕了，需要把开发的内容合并的其他分支中去，则需要使用 git的 merge命令。例如， 现在有2个分支(master, ningning), master分支的代码要合并到ningning,2个分支代码都已经git commit过了。如果没有commit，需要先commit，否则不能合并代码。 5.4.1 合并命令：git merge [分支名] // 切换到需要添加新功能的分支上 $ git checkout ningning // 把 master分支上的代码合并到ningning分支上 $ git merge master 如果合并成功了则输出的信息类似于下面： $ git merge master Updating f42c576..3a0874c Fast-forward index.html | 2 ++ 1 file changed, 2 insertions(+) // 或者下面的输出信息 Merge made by the 'recursive' strategy. index.html | 1 + 1 file changed, 1 insertion(+) Git 将合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 5.4.2 合并过程中代码有冲突，解决冲突 错误信息类似于： Auto-merging index.html CONFLICT (content): Merge conflict in index.html Automatic merge failed; fix conflicts and then commit the result. Auto-merging是指已经自动合并的文件， CONFLICT (content)是指有冲突的文件，需要解决冲突的文件。 打开有冲突的文件，冲突部分代码类似于下面： contact : email.support@github.com ======= please contact us at support@github.com >>>>>>> master ======= >>>>>> 中的是 master分支的代码。经过对比后删除冲突部分的代码， 并把 >>> 所在行全部删除。保存后，使用git add添加修改的文件。使用git commit命令来完成合并提交： 解决冲突文件：git checkout --ours/--theirs放弃其中一个分支的冲突代码 如果想放弃一个分支文件的冲突代码，只保留一个分支的代码，可使用如下命令。 假如：冲突文件名为 1.txt，要放弃master分支的修改，可使用如下命令： $ git checkout --ours 1.txt 放弃ningning分支冲突代码，可使用如下命令： $ git checkout --theirs 1.txt 5.4.3 取消合并 冲突太多，解决冲突乱了， 可取消合并：git reset --hard HEAD 如果冲突代码太多了，解决冲突代码过程中产生了混乱，想要重新合并，可使用下面命令取消这次合并： git reset --hard HEAD HEAD is now at 9e791f3 提交信息 合并已经commit，还没上传远程仓库，取消合并：git reset --hard HEAD^ 如果合并的代码产生了错误，或者合并有问题，但是已经commit了，但是还没有把合并提交到远程仓库，则可以使用如下命令取消这次合并： $ git reset --hard HEAD^ 六、 打标签(一个版本发布) git tag 像其他版本控制系统（VCS）一样，Git 可以给历史中的某一个提交打上标签，以示重要。比较有代表性的是人们会使用这个功能来标记发布版本节点（v1.0 等等）。 6.1 什么是标签？ 标签可以认为是版本管理工具的一个版本，也就是说像很多第三方开源软件安装包表示的版本号，比如说1.0,2.0等等，它代表修复了一个bug,或者重大的重构，git的标签也是这样的一个作用，可以对版本的不同阶段做一个标示。 6.2 查看现有的标签 6.2.1 拉取服务器上的新标签：git pull 使用git pull就可以将服务器上的所有新tag拉取到本地来： $ git pull remote: Counting objects: 35, done remote: Finding sources: 100% (13/13) remote: Total 13 (delta 11), reused 13 (delta 11) Unpacking objects: 100% (13/13), done. From http://doman/portal-frontend 29660dea..43b21ab4 rel-1.12 -> origin/rel-1.12 * [new tag] 1.11.2 -> 1.11.2 Already up to date. 6.2.2 查看所有标签：git tag $ git tag v0.1 v1.3 v1.4 这个命令以字母顺序列出标签；但是它们出现的顺序并不重要。 6.2.3 查看符合条件的标签：git tag -l 'v1.*' 也可以使用特定的模式查找标签, 如果只对 1.0以上tag感兴趣，可以运行： $ git tag -l '1.1*' 1.11.0 1.11.1 1.11.2 6.2.4 查看一个标签的详细信息：git show tag名字 该命令会输出打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。 $ git show 1.11.2 tag 1.11.2 Tagger: user Date: Mon May 12 11:10:30 2021 +0800 我是tag的提交信息 commit f22dsa345b6bf918c6be44f46aa874f54b2ecd (HEAD -> master, tag: 1.11.2, origin/master) Merge: 3863142e 4116ea11 Author: user Date: Mon May 10 10:27:25 2021 +0800 Merge branch 'feature/clNull' 6.3 创建标签：Git 使用两种主要类型的标签： 6.3.1 git tag -a:创建附注标签（annotated） 附注标签是存储在 Git 数据库中的一个完整对象。它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息。 创建一个附注标签，使用tag命令时指定-a选项： $ git tag -a v1.4 -m 'my version 1.4' -m选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入信息。 如果你有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的-a改为-s（取 signed 的首字母）即可： git tag -s v1.5 -m 'my signed 1.5 tag' 再运行 git show 会看到对应的 GPG 签名也附在其内. 6.3.2 git tag V1.4: 创建轻量标签（lightweight） 如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，则可以选择使用轻量标签。轻量标签本质上是将提交校验和存储到一个文件中 - 没有保存任何其他信息。创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字： $ git tag v1.4-lw 6.3.3 git tag -a v1.2 9fceb02：对某个历史提交打标签(后期打标签) 如果你在项目版本发布的时候忙忘记打标签，你可以在之后补上标签。要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）: git tag -a v1.2 9fceb02 6.4 把创建的标签推送到服务器上：git push origin [tagname] 默认情况下，git push命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 $ git push origin v1.5 Counting objects: 14, done. Delta compression using up to 8 threads. Compressing objects: 100% (12/12), done. Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done. Total 14 (delta 3), reused 0 (delta 0) To git@github.com:schacon/simplegit.git * [new tag] v1.5 -> v1.5 如果想要一次性推送很多标签，也可以使用带有--tags选项的git push命令。这将会把所有不在远程仓库服务器上的标签全部传送到服务器。 $ git push origin --tags Counting objects: 1, done. Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done. Total 1 (delta 0), reused 0 (delta 0) To git@github.com:schacon/simplegit.git * [new tag] v1.4 -> v1.4 * [new tag] v1.4-lw -> v1.4-lw 现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。 6.5 检出标签: 代码变成标签的样子 在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用git checkout -b [branchname] [tagname]在特定的标签上创建一个新分支： $ git checkout -b version2 v2.0.0 Switched to a new branch 'version2' 6.6 删除标签 6.6.1 git tag -d v1.0:删除本地标签 $ git tag -d v1.0 Deleted tag 'v1.0' (was 2ffea56) 6.6.2 git push origin :refs/tags/v0.1:删除服务器标签 推送一个空tag到远程tag，就可以删除同名的tag： $ git push origin :refs/tags/v0.1 To http://192.168.95.95/user/test.git - [deleted] v0.1 如果服务器的标签删除后，本地的也需要自己删除。 或者使用这种形式： git push origin --delete tag 关于git tag详解 常用命令 7. git 一些查看命令 ~ git help status # 查看status命令的帮助 # 查看状态和修改 # https://git-scm.com/book/zh/v2/Git-基础-记录每次更新到仓库, git st -s 详细介绍 ~ git status -s # 状态简览,或 git status --short,得到一种更为紧凑的格式输出. # git diff 将通过文件补丁的格式显示具体哪些行发生了改变。 ~ git diff filename # 查看未暂存的修改,git diff 只显示尚未暂存的改动,已经add 的文件修改看不见，需要下面的命令 ~ git diff --staged filename # 或git diff --cached, 查看已暂存的将要添加到下次提交里的内容 # commit 提交 ~ git commit # 这种方式会启动文本编辑器以便输入本次提交的说明 ~ git commit -m \"提交信息\" # 将提交信息与命令放在同一行,直接提交， ~ git commit -a -m '提交信息' # `-a`选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过`git add`步骤。 # 查看提交历史 https://git-scm.com/book/zh/v2/Git-基础-查看提交历史 ~ git reflog # 查看commit 引用日志记录信息 ~ git log -p -2 # -p:用来显示每次提交的内容差异, -2:仅显示最近两次提交. ~ git log --stat # 每次提交的简略的统计信息,列出额所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 ~ git log --pretty=oneline # 每个提交放在一行显示,还有 short，full 和 fuller 可以用 ~ git log -p files # 查看某个文件的详细修改记录 ~ git log --oneline --decorate --graph --all # 提交历史、各个分支的指向以及项目的分支分叉情况 ~ git log --oneline --decorate # 查看各个分支当前所指的对象 8. 获取Git仓库 # https://git-scm.com/book/zh/v2/Git-基础-获取-Git-仓库 # 进入该项目目录 ~ git init ~ git remote add origin http://192.168.102.9/username/ttt.git # 添加远程仓库地址 # 仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪,通过 git add 命令来实现对指定文件的跟踪，然后执行 git commit 提交. ~ git clone https://github.com/libgit2/libgit2 # 克隆现有的仓库 ~ git clone https://github.com/libgit2/libgit2 mylibgit # 克隆现有的仓库,自定义本地仓库的名字 # Git 支持多种数据传输协议,https:// 协议,git:// 协议或者使用 SSH 传输协议 # https://git-scm.com/book/zh/v2/Git-基础-远程仓库的使用 ~ git remote show origin # 查看某一个远程仓库的更多信息 ~ git remote rename pb paul # 将 pb 重命名为 paul ~ git remote rm paul # 移除一个远程仓库 9. git tag — 标签相关操作 http://blog.csdn.net/wangjia55/article/details/8793577http://gitref.org/zh/branching/#tag # https://git-scm.com/book/zh/v2/Git-基础-打标签 # 列出标签 $ Git tag # 在控制台打印出当前仓库的所有标签 $ git tag -l ‘v0.1.*’ # 搜索符合模式的标签 # 打标签 $ git tag v0.1.2-light # 创建轻量标签 ,使用这个命令后，只有一个版本号，没有备注信息 # 建议使用附注标签 $ git tag -a v0.1.2 # 这个标签会进入vi中编辑tag提交信息。 $ git tag -a v0.1.2 -m “0.1.2版本” # 创建附注标签， 不进入vi中，直接把tag信息写在这里。 # 切换到标签 $ git checkout [tagname] # 切换到标签 # 如果你想在这个标签中开发，那么则创建一个新分支 $ git checkout -b new_branch_name $ git show v0.1.2 # 查看标签的版本信息 # 删除标签 # 删除本地标签 $ git tag -d v0.1.2 # 删除标签 参数d即delete的缩写，意为删除其后指定的标签。 # 删除远程标签 $ git push origin :refs/tags/ # 推送一个空tag到远程tag $ git push origin --delete tag # 在Git v1.7.0 之后，可以使用这种语法删除远程分支 # 给指定的commit打标签 $ git tag -a v0.1.1 9fbc3d0 # 需要你知道某个提交对象的校验和（通过git log获取） # 标签发布 # 通常的git push不会将标签对象提交到git服务器，我们需要进行显式的操作： $ git push origin v0.1.2 # 将v0.1.2标签提交到git服务器 $ git push origin --tags # 将本地所有标签一次性提交到git服务器 注意：如果想看之前某个标签状态下的文件，可以这样操作：1.git tag 查看当前分支下的标签2.git checkout v0.21 此时会指向打v0.21标签时的代码状态，（但现在处于一个空的分支上） cat test.txt 查看某个文件 10. 代码存储，代码修改记录:git stash, git diff > tmp.patch 当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态，而这时你想要切换到另一个分支做一点别的事情。或者是要拉取新代码， # 方法一： # 把修改的代码备份一下 ~ git diff > tmp.patch # 放弃所有修改的代码 ~ git co . # 拉取代码 ~ git pull # 把备份的代码还原回去 ~ git apply tmp.patch # 注意，不要有冲突，如果拉取的代码与修改的代码重复就会冲突，小心慎重 # 方法二： # https://git-scm.com/book/zh/v2/Git-工具-储藏与清理 ~ git stash # 或使用命令：git stash save 暂存当前状态 # 运行上面的命令后，工作目录就变干净了，使用git status 命令查看 ~ git stash list # 显示已暂存列表 stash@{0}: WIP on master: 049d078 added the index file stash@{1}: WIP on master: c264051 Revert \"added file_size\" ~ git stash apply # 将最近的储藏工作重新应用 ~ git stash apply stash@{1} # 应用其中一个更旧的储藏 ~ git stash pop # 应用储藏然后立即从栈上扔掉它 ~ git stash drop stash@{0} # 移除这个存储 # 当你做了几个改动并只想提交其中的一部分，过一会儿再回来处理剩余改动时，这个功能会很有用。 ~ git stash --keep-index # 不要储藏任何你通过 git add 命令已暂存的东西 ~ git stash -u # 指定 --include-untracked 或 -u 标记，Git 也会储藏任何创建的未跟踪文件。 11. 分支管理 $ git branch testing # 创建本地分支 $ git checkout testing # 切换分支 $ git checkout -b euwe-1-jas # 创建分支并切换到这个分支 $ git branch -d testing # 删除本地分支分支 # 删除远程分支 # 如果删除失败看看是不是这个分支时默认分支，修改默认分支就好 $ git push origin --delete # 在Git v1.7.0 之后，可以使用这种语法删除远程分支 $ git push origin : # 推送一个空分支到远程分支，其实就相当于删除远程分支 #重命令本地分支， $ git br -m 旧名字 新名字 # 如果想重命名远程分支，那么先重命名本地分支，然后上传，最后删除就分知名 12. git 回滚到某个commit http://www.shouce.ren/api/view/a/13832 # 回滚到老的commit # 方法一 # 记住最新的commit，然后在用此命令回滚 $ git reset --hard resetVersionHash //将当前branch的HEAD指针指向commit hash $ git reset --hard 3628164 //老的commit # 只看commit SHA1 不看作者跟时间 ~ git log --pretty=oneline # 方法二： # Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164...882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100 $ git reset --hard HEAD^ HEAD is now at ea34578 add distributed # 回到新 # 如果记得新commit的号码 $ git reset --hard 3628164 # 3628164 是新的commit HEAD is now at 3628164 append GPL # 如果不记得commit号，那么可使用如下命令查看： $ git reflog ea34578 HEAD@{0}: reset: moving to HEAD^ 3628164 HEAD@{1}: commit: append GPL ea34578 HEAD@{2}: commit: add distributed 13. git 查看改动 # 当修改文件但是没有提交时： $ git diff # 查看所有的改动 $ git diff 文件名 #查看这个文件的改动 # 查看某个commit做了哪些改动 $ git show 046bd7b5c1d134b8123f 14. git恢复删除的文件 # 要查看删除的文件： $ git ls-files --deleted # 使用命令checkout来恢复： $ git checkout -- file_name # 如果要恢复多个被删除的文件，可以使用批处理命令： $ git ls-files -d | xargs git checkout -- # 如果要恢复被修改的文件，命令： $ git ls-files -m | xargs git checkout -- 1.git pull会使用git merge导致冲突，需要将冲突的文件resolve掉 git add -u, git commit之后才能成功pull. 2.如果想放弃本地的文件修改，可以使用git reset --hard FETCH_HEAD，FETCH_HEAD表示上一次成功git pull之后形成的commit点。然后git pull. 15. \"git rm\" 和 \"rm\" 的区别 http://blog.csdn.net/jfkidear/article/details/12152167 这是一个比较肤浅的问题，但对于 Git 初学者来说，还是有必要提一下的。用 git rm来删除文件，同时还会将这个删除操作记录下来；用rm来删除文件，仅仅是删除了物理文件，没有将其从 git 的记录中剔除。 直观的来讲，git rm删除过的文件，执行git commit -m \"abc\"提交时，会自动将删除该文件的操作提交上去。 而对于用rm命令直接删除的文件，执行git commit -m \"abc\"提交时，则不会将删除该文件的操作提交上去。不过不要紧，即使你已经通过rm将某个文件删除掉了，也可以再通过git rm命令重新将该文件从git的记录中删除掉，这样的话，在执行git commit -m \"abc\"以后，也能将这个删除操作提交上去。 如果之前不小心用rm命令删除了一大批文件呢？是的，此时用git rm逐个地再删除一次就显得相当蛋疼了。所幸还有更方便的处理方案，用如下的方式做提交就没有问题了：git commit -am \"abc\" 总结一下： 在被 git 管理的目录中删除文件时，可以选择如下两种方式来记录删除动作：一、rm + git commit -am \"abc\"二、git rm + git commit -m \"abc\"另外，git add . 仅能记录添加、改动的动作，删除的动作需靠git rm来完成。最后，rm删除的文件是处于not staged状态的，也就是一种介于 “未改动” 和 “已提交过” 之间的状态。 16. 关闭git pull产生的merge 信息 linux, 编辑 ~/.gitconfig: [core] mergeoptions = --no-edit 或者终端执行：git config --global core.mergeoptions --no-edit 16.1 git pull 产生merge信息的原因 Git 作为分布式版本控制系统，所有修改操作都是基于本地的，在团队协作过程中，假设你和你的同伴在本地中分别有各自的新提交，而你的同伴先于你 push 了代码到远程分支上，所以你必须先执行 git pull 来获取同伴的提交，然后才能 push 自己的提交到远程分支。而按照 Git 的默认策略，如果远程分支和本地分支之间的提交线图有分叉的话（即不是 fast-forwarded），Git 会执行一次 merge 操作，因此产生一次没意义的提交记录，从而造成了像上图那样的混乱。 16.2 解决 参考：洁癖者用 Git：pull --rebase 和 merge --no-ff其实在 pull 操作的时候，，使用 git pull --rebase 选项即可很好地解决上述问题。 加上 --rebase 参数的作用是，提交线图有分叉的话，Git 会 rebase 策略来代替默认的 merge 策略。 使用 rebase 策略有什么好处呢？假设提交线图在执行 pull 前是这样的： A---B---C remotes/origin/master / D---E---F---G master 如果是执行git pull 后，提交线图会变成这样： A---B---C remotes/origin/master / \\ D---E---F---G---H master 结果多出了 H 这个没必要的提交记录。如果是执行 git pull --rebase的话，提交线图就会变成这样： remotes/origin/master | D---E---A---B---C---F'---G' master F G 两个提交通过 rebase 方式重新拼接在 C 之后，多余的分叉去掉了，目的达到。 会把你的本地master分支里的每个提交(commit)取消掉，并且把它们临时 保存为补丁(patch)(这些补丁放到\".git/rebase\"目录中),然后把本地master分支更新 到最新的\"origin\"分支，最后把保存的这些补丁应用到本地\"maser\"分支上。 关于git --rebase介绍：http://gitbook.liuhui998.com/4_2.htmlhttp://blog.csdn.net/hudashi/article/details/7664631/ 17. git pull文件时和本地文件冲突 http://www.01happy.com/git-resolve-conflicts/ 当拉去远程代码时，出现如下错误： error: Your local changes to 'c/environ.c' would be overwritten by merge. Aborting. Please, commit your changes or stash them before you can merge. 这个意思是说更新下来的内容和本地修改的内容有冲突，先提交你的改变或者先将本地修改暂时存储起来。处理的方式非常简单，可使用git stash命令或者提交修改。 18. git删除远程仓库的一次commit提交 # 参考链接： http://zhuqingcode.github.io/git/2014/05/15/github-a-bug-commit.html # 方法一： 删除远程一次提交 ~ git reset --hard HEAD~1 ~ git push --force ## 强制推送提交， ~ git push -f origin master ## 强制推送提交 # 方法二： 采取revert的方法，相当于重新生成一个提交，来撤销前一次错误的commit。 ~ git revert HEAD ~ git push origin master powered by Gitbook文件最后修改时间： 2022-12-26 18:00:35 "},"doc/git/003-git教程-高级.html":{"url":"doc/git/003-git教程-高级.html","title":"git教程-高级","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 git使用教程-高级(平时用的很少，了解就好) 1. git stash: 代码暂存 1.1 把代码储藏起来： git stash 1.2 查看储藏的代码： git stash list 1.3 把储藏的代码取出来： git stash apply 1.4 git stash apply --index 1.5 删除储藏堆栈上的某个储藏：git stash drop stash@{0} 1.6 应用储藏然后立即从栈上扔掉它：git stash pop 1.7 git stash --keep-index: 不要储藏任何你通过 git add 命令已暂存的东西 1.8 git stash -u: 把任何创建的未跟踪文件也储藏 1.9 从储藏创建一个分支:解决应用储藏冲突问题 2 git clean：清理工作目录 2.1 git clean -f -d:移除工作目录中所有未追踪的文件以及空的子目录 2.2 git clean -f -d -n: 做一次演习然后告诉你 将要 移除什么 2.3 git clean -f -d -x: 移除.gitiignore文件中忽略的文件 3. 重写历史：git 提交历史修改 3.1 修改最后一次提交 3.1.1 修改最后一次提交的提交信息：git commit --amend 3.1.2 修改最后一次提交的快照：git add或git rm然后git commit --amend 3.1.3 把修改的最后一次提交信息强推到服务器：git push --f 3.1.4 gitlab服务器强推被拒绝： 仓库 - 设置 - 保护分支： 把被保护的分支去掉即可解决问题 3.2 使用git rebase合并多次commit 3.3 把一个文件从提交历史中彻底删除：git filter-branch --tree-filter 'rm -f 1.txt' HEAD 3.4.1 如果后悔删除了，可使用如下命令恢复：git reset --hard refs/original/refs/heads/[分支名] 3.4.2 把删除后的项目提交到服务器：git push origin +[分支名] 注意：一旦运行此命令，删除的文件不能找回 3.4.3 删除一堆类似文件：git filter-branch --tree-filter \"find * -type f -name '*~' -delete\" HEAD 3.4 全局性地更换电子邮件地址 4. GIT的工作原理 4.1 HEAD 4.2 index 4.3 Working Directory 4.4 工作流程 5. git重置git reset: 代码回退操作 5.1 只移动HEAD(相当于取消上一次提交)：git reset --soft HEAD~或 git reset --soft 99ad0ec 5.2 移动HEAD，更新index： git reset HEAD~ 或git reset --mixed HEAD~ 5.3 移动HEAD，更新index,更新工作目录（working Directory）: git reset --hard HEAD~ 5.4 使用git reflog命令来查看所有已经提交过的commit 5.5 通过路径来重置：git reset file.txt 6. git checkout 介绍 6.1 切换分支：git checkout [分支名] 6.2 放弃index与working Directory的改动：git checkout [分支名] file.txt 6.3 值放弃修改working Directory 工作目录中的修改：git checkout file.txt放弃单个修改或使用git checkout .放弃所有修改 [TOC] git使用教程-高级(平时用的很少，了解就好) 1. git stash: 代码暂存 git stash 用来把代码暂存起来，把工作目录变干净，方便切换分支等做一些其他事情。 当你的工作已经做了一段时间后，所开发的功能还没有完成， 而这时候你想要切换分支做一点别的事情。但你又不想应为过一会就回到这一点而为做了一半工作就创建一次提交，这个时候你就可以使用git stash命令。git stash命令会处理工作目录的脏的状态，即修改的跟踪文件与暂存的改动。然后将未完成的修改保存到一个栈上，而你可以在任何时候重新应用这些改动。 1.1 把代码储藏起来： git stash $ git status Changes to be committed: (use \"git reset HEAD ...\" to unstage) modified: index.html Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: lib/simplegit.rb //储藏代码 $ git stash Saved working directory and index state \\ \"WIP on master: 049d078 added the index file\" HEAD is now at 049d078 added the index file (To restore them type \"git stash apply\") $ git status # On branch master nothing to commit, working directory clean 上面使用了git stash 储藏了代码，这时候在看工作目录就变成干净了，这个时候你就可以做别的事情了。 还可以使用git stash save命令，与 git stash 是一样的。 1.2 查看储藏的代码： git stash list 要查看储藏的东西，可以使用git stash list命令： $ git stash list stash@{0}: WIP on master: 049d078 added the index file stash@{1}: WIP on master: c264051 Revert \"added file_size\" stash@{2}: WIP on master: 21d80a5 added number to log 最新的是stash@{0} 1.3 把储藏的代码取出来： git stash apply 如果想把储藏的代码应用回来，可使用git stash apply命令，如果不指定一个储藏，Git 认为指定的是最近的储藏。如果想要应用其中一个更旧的储藏，可以通过名字指定它，像这样：git stash apply stash@{2}。 $ git stash apply --index // # On branch master // # Changed but not updated: // # (use \"git add ...\" to update what will be committed) // # // # modified: index.html // # modified: lib/simplegit.rb // # 1.4 git stash apply --index 文件的改动被重新应用了,但是之前已修改未暂存的文件却没有回到原来的位置，想要完全回到之前的样子，必须使用--index选项来运行git stash apply命令，来尝试重新应用暂存的修改。如果已经那样做了，那么你将回到原来的位置： $ git stash apply --index // # On branch master // # Changes to be committed: // # (use \"git reset HEAD ...\" to unstage) // # // # modified: index.html // # // # Changed but not updated: // # (use \"git add ...\" to update what will be committed) // # // # modified: lib/simplegit.rb // # 1.5 删除储藏堆栈上的某个储藏：git stash drop stash@{0} 使用git stash apply 命令只会尝试应用暂存的工作 ，在堆栈上还有它。可以运行git stash drop加上将要移除的储藏的名字来移除它： $ git stash list stash@{0}: WIP on master: 049d078 added the index file stash@{1}: WIP on master: c264051 Revert \"added file_size\" stash@{2}: WIP on master: 21d80a5 added number to log $ git stash drop stash@{0} Dropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43) 1.6 应用储藏然后立即从栈上扔掉它：git stash pop 这个命令只会应用最新的，然后丢掉它。 1.7 git stash --keep-index: 不要储藏任何你通过 git add 命令已暂存的东西 当你做了几个改动并只想提交其中的一部分，过一会儿再回来处理剩余改动时，这个功能会很有用。 $ git status -s M index.html M lib/simplegit.rb $ git stash --keep-index Saved working directory and index state WIP on master: 1b65b17 added the index file HEAD is now at 1b65b17 added the index file $ git status -s M index.html 1.8 git stash -u: 把任何创建的未跟踪文件也储藏 默认情况下，git stash只会储藏已经在索引中的文件。如果指定 --include-untracked或-u标记，Git 也会储藏任何创建的未跟踪文件。 $ git status -s M index.html M lib/simplegit.rb ?? new-file.txt $ git stash -u Saved working directory and index state WIP on master: 1b65b17 added the index file HEAD is now at 1b65b17 added the index file $ git status -s $ 1.9 从储藏创建一个分支:解决应用储藏冲突问题 如果储藏了一些工作，将它留在那儿了一会儿，然后继续在储藏的分支上工作，在重新应用工作时可能会有问题。如果应用尝试修改刚刚修改的文件，你会得到一个合并冲突并不得不解决它。如果想要一个轻松的方式来再次测试储藏的改动，可以运行git stash branch创建一个新分支，检出储藏工作时所在的提交，重新在那应用工作，然后在应用成功后扔掉储藏： $ git stash branch testchanges Switched to a new branch \"testchanges\" // # On branch testchanges // # Changes to be committed: // # (use \"git reset HEAD ...\" to unstage) // # // # modified: index.html // # // # Changed but not updated: // # (use \"git add ...\" to update what will be committed) // # // # modified: lib/simplegit.rb // # // Dropped refs/stash@{0} (f0dfc4d5dc332d1cee34a634182e168c4efc3359) 2 git clean：清理工作目录 有时候你想清除工作目录一些无用的文件，或是为了运行一个干净的构建而移除之前构建的残留。这个时候你可以使用git clean命令。 它被设计为从工作目录中移除未被追踪的文件。如果你改变主意了，你也不一定能找回来那些文件的内容。一个更安全的选项是运行 git stash --all 来移除每一样东西并存放在栈中。 2.1 git clean -f -d:移除工作目录中所有未追踪的文件以及空的子目录 -d 是 目录的意思。-f 意味着 强制 或 “确定移除”。 $ git clean -f -d Removing 6.txt Removing tttt/ 2.2 git clean -f -d -n: 做一次演习然后告诉你 将要 移除什么 2.3 git clean -f -d -x: 移除.gitiignore文件中忽略的文件 默认情况下，git clean 命令只会移除没有忽略的未跟踪文件。任何与 .gitiignore 或其他忽略文件中的模式匹配的文件都不会被移除。如果你也想要移除那些文件，例如为了做一次完全干净的构建而移除所有由构建生成的 .o 文件，可以给 clean 命令增加一个 -x 选项。 $ git status -s M lib/simplegit.rb ?? build.TMP ?? tmp/ $ git clean -n -d Would remove build.TMP Would remove tmp/ $ git clean -n -d -x Would remove build.TMP Would remove test.o Would remove tmp/ 3. 重写历史：git 提交历史修改 3.1 修改最后一次提交 修改你最近一次提交可能是所有修改历史提交的操作中最常见的一个。对于你的最近一次提交，你往往想做两件事情：修改提交信息，或者修改你添加、修改和移除的文件的快照。 3.1.1 修改最后一次提交的提交信息：git commit --amend 如果只是想修改最后一次提交的提交信息，可以直接使用如下命令： $ git commit --amend [dev 3fa2e1a] 合并提交测试3号,测试修改最后一次提交。在测试一下。 Date: Thu Nov 2 11:29:00 2017 +0800 1 file changed, 1 insertion(+) create mode 100644 6.txt 这会把你带入文本编辑器，里面包含了你最近一条提交信息，供你修改。当保存并关闭编辑器后，编辑器将会用你输入的内容替换最近一条提交信息。 3.1.2 修改最后一次提交的快照：git add或git rm然后git commit --amend 如果你已经完成提交，又因为之前提交时忘记添加一个新创建的文件，想通过添加或修改文件来更改提交的快照，也可以通过类似的操作来完成。 通过修改文件然后运行git add或git rm一个已追踪的文件，随后运行git commit --amend拿走当前的暂存区域并使其做为新提交的快照。 使用这个技巧的时候需要小心，因为修正会改变提交的 SHA-1 校验和。它类似于一个小的变基 - 如果已经推送了最后一次提交则需要慎重修改。 3.1.3 把修改的最后一次提交信息强推到服务器：git push --f 此操作要慎重，如果要修改服务器上的最后一次提交，可现在本地修改，然后使用git push --f(force)强推到服务器中去。 git push --force Counting objects: 3, done. Delta compression using up to 8 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 458 bytes | 458.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) To http://192.168.102.9/yulilong/test.git + 5c0a032...3fa2e1a dev -> dev (forced update) 3.1.4 gitlab服务器强推被拒绝： 仓库 -> 设置 -> 保护分支： 把被保护的分支去掉即可解决问题 3.2 使用git rebase合并多次commit 使用git log 查看一下历史： $ git log commit 3fa2e1a951ff823fbec625a96049e27ef35a85b8 (HEAD -> dev, origin/dev) Author: yulilong Date: Thu Nov 2 11:29:00 2017 +0800 合并提交测试3号,测试修改最后一次提交。在测试一下。 commit f526876def0b80676bfcf52937f78052e2d63955 Author: yulilong Date: Thu Nov 2 11:27:20 2017 +0800 合并提交测试2号 commit 4d2b6ce4d5154c0b739e552e679bb7f4ce05fb2c Author: yulilong Date: Thu Nov 2 11:25:59 2017 +0800 合并提交测试一号 commit 9e791f38f4d5f472a371a8c147f37670185582f8 Author: yulilong Date: Mon Oct 30 10:22:02 2017 +0800 这是dev分支上的合并提交测试 commit 4baf2a319c0de8f46630ba85db11cc4aebd1d2cd Author: yulilong Date: Fri Sep 29 10:20:08 2017 +0800 这是测试-a -m命令提交记录 如果想要合并最后三次的提交，可使用git rebase -i HEAD~3或git rebase -i 9e791f38f4d命令来压缩.该命令执行后，会弹出一个编辑窗口，3次提交的commit倒序排列，最上面的是最早的提交，最下面的是最近一次提交。 1 pick 4d2b6ce 合并提交测试一号 2 pick f526876 合并提交测试2号 3 pick 3fa2e1a 合并提交测试3号,测试修改最后一次提交。在测试一下。 4 5 # Rebase 9e791f4..3fa2e1a onto 9e791f3 (3 commands) 6 # 7 # Commands: 8 # p, pick = use commit 9 # r, reword = use commit, but edit the commit message 10 # e, edit = use commit, but stop for amending 11 # s, squash = use commit, but meld into previous commit 12 # f, fixup = like \"squash\", but discard this commit's log message 13 # x, exec = run command (the rest of the line) using shell 14 # d, drop = remove commit 15 # 16 # These lines can be re-ordered; they are executed from top to bottom. 17 # 18 # If you remove a line here THAT COMMIT WILL BE LOST. 19 # 20 # However, if you remove everything, the rebase will be aborted. 21 # 22 # Note that empty commits are commented out 修改第二行、第三行的第一个单词pick为squash(这些命令什么意思下面的注释有说明)。然后保存退出，git会压缩提交历史，如果有冲突，需要修改，修改的时候要注意，保留最新的历史，不然我们的修改就丢弃了。修改以后要记得敲下面的命令： $ git add . # git rebase --continue 如果你想放弃这次压缩的话，执行以下命令： $ git rebase --abort 如果没有冲突，或者冲突已经解决，则会出现如下的编辑窗口： 1 # This is a combination of 3 commits. 2 # This is the 1st commit message: 3 4 合并提交测试一号 5 6 # This is the commit message #2: 7 8 合并提交测试2号 9 10 # This is the commit message #3: 11 12 合并提交测试3号,测试修改最后一次提交。在测试一下。 13 14 # Please enter the commit message for your changes. Lines starting 15 # with '#' will be ignored, and an empty message aborts the commit. 16 # 17 # Date: Thu Nov 2 11:25:59 2017 +0800 18 # 19 # interactive rebase in progress; onto 9e791f3 20 # Last commands done (3 commands done): 21 # squash f526876 合并提交测试2号 22 # squash 3fa2e1a 合并提交测试3号,测试修改最后一次提交。在测试一下。 23 # No commands remaining. 24 # You are currently rebasing branch 'dev' on '9e791f3'. 25 # 26 # Changes to be committed: 27 # modified: 1.txt 28 # new file: 5.txt 29 # new file: 6.txt 编辑好合并的提交信息后保存，可看见如下输出信息： [detached HEAD 83d65c7] 三次合并提交的测试，成功了。 Date: Thu Nov 2 11:25:59 2017 +0800 3 files changed, 7 insertions(+) create mode 100644 5.txt create mode 100644 6.txt Successfully rebased and updated refs/heads/dev. 最后把合并的记录强推到服务器中去： git push -f Counting objects: 5, done. Delta compression using up to 8 threads. Compressing objects: 100% (3/3), done. Writing objects: 100% (5/5), 596 bytes | 596.00 KiB/s, done. Total 5 (delta 1), reused 0 (delta 0) To http://192.168.102.9/yulilong/test.git + 3fa2e1a...83d65c7 dev -> dev (forced update) 服务器合并提交前： 服务器合并后： 参考链接：http://blog.csdn.net/yangcs2009/article/details/47166361 3.3 把一个文件从提交历史中彻底删除：git filter-branch --tree-filter 'rm -f 1.txt' HEAD 有些人不经思考使用git add .，意外地提交了一个巨大的二进制文件，你想将它从所有地方删除。也许你不小心提交了一个包含密码的文件，而你想让你的项目开源。filter-branch大概会是你用来清理整个历史的工具。如果想要从整个历史总删除1.txt文件，你可以在filter-branch上使用--tree-filter选项： $ git filter-branch -f --tree-filter 'rm -f 1.txt' HEAD Rewrite 83d65c7b098e0ec1f14d9a332187632b49d2ad9f (5/5) (0 seconds passed, remaining 0 predicted) Ref 'refs/heads/dev' was rewritten 如果执行命令的时候提示如下错误，删除 .git/refs/original/ 目录,或使用-f命令强制覆盖： $ git filter-branch -f --tree-filter 'rm -f 1.txt' HEAD Cannot create a new backup. A previous backup already exists in refs/original/ Force overwriting the backup with -f git filter-branch -f --tree-filter 'rm -f 1.txt' HEAD Rewrite 83d65c7b098e0ec1f14d9a332187632b49d2ad9f (5/5) (0 seconds passed, remaining 0 predicted) Ref 'refs/heads/dev' was rewritten 3.4.1 如果后悔删除了，可使用如下命令恢复：git reset --hard refs/original/refs/heads/[分支名] $ git reset --hard refs/original/refs/heads/dev HEAD is now at 83d65c7 三次合并提交的测试，成功了。 3.4.2 把删除后的项目提交到服务器：git push origin +[分支名] 注意：一旦运行此命令，删除的文件不能找回 $ git push origin +dev Counting objects: 14, done. Delta compression using up to 8 threads. Compressing objects: 100% (9/9), done. Writing objects: 100% (14/14), 1.40 KiB | 1.40 MiB/s, done. Total 14 (delta 1), reused 0 (delta 0) To http://192.168.102.110/user/test.git + 83d65c7...4b4da80 dev -> dev (forced update) 注意，分支名字前面的+号一定不能忘记，否则会报如下错误： To http://192.168.102.110/user/test.git ! [rejected] dev -> dev (non-fast-forward) error: failed to push some refs to 'http://192.168.102.110/user/test.git' hint: Updates were rejected because the tip of your current branch is behind hint: its remote counterpart. Integrate the remote changes (e.g. hint: 'git pull ...') before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. 推送之前要把服务器的分支保护去掉，否则会报如下错误： remote: GitLab: You are not allowed to force push code to a protected branch on this project. To http://192.168.102.110/user/test.git ! [remote rejected] dev -> dev (pre-receive hook declined) error: failed to push some refs to 'http://192.168.102.110/user/test.git' 3.4.3 删除一堆类似文件：git filter-branch --tree-filter \"find -type f -name '~' -delete\" HEAD 3.4 全局性地更换电子邮件地址 $ git filter-branch --commit-filter ' if [ \"$GIT_AUTHOR_EMAIL\" = \"schacon@localhost\" ]; then GIT_AUTHOR_NAME=\"Scott Chacon\"; GIT_AUTHOR_EMAIL=\"schacon@example.com\"; git commit-tree \"$@\"; else git commit-tree \"$@\"; fi' HEAD 参考链接： https://git-scm.com/book/zh/v2/Git-工具-重写历史 4. GIT的工作原理 Git 的思维框架（将其作为内容管理器）是管理三棵不同的树。“树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。 Git 作为一个系统，是以它的一般操作来管理并操纵这三棵树的： ---------------------------- 树 用途 HEAD 上一次提交的快照，下一次提交的父节点 index 预期的下一次提交的快照 Working Directory 沙盒（工作目录） 4.1 HEAD HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 HEAD 将是下一次提交的父结点。通常，理解 HEAD 的最简方式，就是将它看做 你的上一次提交 的快照。 下例命令就显示了HEAD快照实际的目录列表，以及其中每个文件的SHA-1校验和： $ git cat-file -p HEAD tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf author Scott Chacon 1301511835 -0700 committer Scott Chacon 1301511835 -0700 initial commit $ git ls-tree -r HEAD 100644 blob a906cb2a4a904a152... README 100644 blob 8f94139338f9404f2... Rakefile 040000 tree 99f1a6d12cb4b6f19... lib cat-file与ls-tree是底层命令，它们一般用于底层工作，在日常工作中并不使用。不过它们能帮助我们了解到底发生了什么。 4.2 index index(索引)是你的预期的下一次提交。也会将这个概念引用为 Git 的 “暂存区域”，这就是当你运行git commit时Git看起来的样子。 Git 将上一次检出到工作目录中的所有文件填充到索引区，它们看起来就像最初被检出时的样子。之后你会将其中一些文件替换为新版本，接着通过 git commit 将它们转换为树来用作新的提交。 $ git ls-files -s 100644 a906cb2a4a904a152e80877d4088654daad0c859 0 README 100644 8f94139338f9404f26296befa88755fc2598c289 0 Rakefile 100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0 lib/simplegit.rb ls-files是底层命令，它会显示出索引当前的样子。确切来说，索引并非技术上的树结构，它其实是以扁平的清单实现的。不过对我们而言，把它当做树就够了。 4.3 Working Directory Working Directory（工作目录），最后，你就有了自己的工作目录。另外两棵树以一种高效但并不直观的方式，将它们的内容存储在 .git 文件夹中。工作目录会将它们解包为实际的文件以便编辑。 你可以把工作目录当做 沙盒。在你将修改提交到暂存区并记录到历史之前，可以随意更改。 4.4 工作流程 +-------------------------------------------------------------------+ | +--------------+ +---------------+ +--------------+ | | | Working | | Index | | HEAD | | | | Directory | | | | | | | +-----+--------+ +-------+-------+ +-------+------+ | | | | | | | | | Checkout the project | | | | | | | | | | Commit | | | | +--------------------> | | | | | | | +-------------------------------------------------------------------+ 假设我们进入到一个新目录，其中有一个文件。 我们称其为该文件的 v1 版本，将它标记为蓝色。现在运行git init，这会创建一个 Git 仓库，其中的 HEAD 引用指向未创建的分支（master 还不存在）。 此时，只有工作目录有内容。 现在我们想要提交这个文件，所以用git add来获取工作目录中的内容，并将其复制到索引(Index)中。 接着运行git commit，它首先会移除索引中的内容并将它保存为一个永久的快照，然后创建一个指向该快照的提交对象，最后更新 master 来指向本次提交。 此时如果我们运行git status，会发现没有任何改动，因为现在三棵树完全相同。现在我们想要对文件进行修改然后提交它。 我们将会经历同样的过程；首先在工作目录中修改文件。我们称其为该文件的 v2 版本，并将它标记为红色。 如果现在运行 git status，我们会看到文件显示在 “Changes not staged for commit,” 下面并被标记为红色，因为该条目在索引与工作目录之间存在不同。 接着我们运行git add来将它暂存到索引中。 此时，由于索引和 HEAD 不同，若运行git status的话就会看到 “Changes to be committed” 下的该文件变为绿色.也就是说，现在预期的下一次提交与上一次提交不同。 最后，我们运行git commit来完成提交。 现在运行git status会没有输出，因为三棵树又变得相同了。切换分支或克隆的过程也类似。 当检出一个分支时，它会修改 HEAD 指向新的分支引用，将 索引 填充为该次提交的快照，然后将 索引 的内容复制到 工作目录 中。 git工作详细介绍 5. git重置git reset: 代码回退操作 5.1 只移动HEAD(相当于取消上一次提交)：git reset --soft HEAD~或 git reset --soft 99ad0ec reset做的第一件事是移动HEAD的指向。reset移动HEAD指向的分支。reset --soft本质上是撤销了上一次git commit命令。 当你在运行git commit时，Git会创建一个新的提交，并移动HEAD所指向的分支来使其指向该提交。当你将它reset回HEAD~HEAD 的父结点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录。现在你可以更新索引并再次运行git commit来完成git commit --amend所要做的事情了。 5.2 移动HEAD，更新index： git reset HEAD~ 或git reset --mixed HEAD~ 它依然会撤销一上次 提交，但还会 取消暂存 所有的东西。 于是，我们回滚到了所有git add和git commit的命令执行之前。 5.3 移动HEAD，更新index,更新工作目录（working Directory）: git reset --hard HEAD~ 必须注意，--hard标记是reset命令唯一的危险用法，它也是Git会真正地销毁数据的仅有的几个操作之一。其他任何形式的reset调用都可以轻松撤消，但是--hard选项不能，因为它强制覆盖了工作目录中的文件。在这种特殊情况下，我们的Git数据库中的一个提交内还留有该文件的v3版本，我们可以通过reflog来找回它。但是若该文件还未提交，Git仍会覆盖它从而导致无法恢复。 reset命令会以特定的顺序重写这三棵树，在你指定以下选项时停止： 移动 HEAD 分支的指向 （若指定了 --soft，则到此停止） 使索引看起来像 HEAD （若未指定 --hard，则到此停止） 使工作目录看起来像索引 5.4 使用git reflog命令来查看所有已经提交过的commit 5.5 通过路径来重置：git reset file.txt 假如我们运行git reset file.txt（这其实是git reset --mixed HEAD file.txt的简写形式，因为你既没有指定一个提交的SHA-1或分支，也没有指定--soft或--hard），它会： 移动HEAD分支的指向 （已跳过） 让索引看起来像HEAD（到此处停止） 所以它本质上只是将file.txt从HEAD复制到索引中。它还有取消暂存文件的实际效果。 我们可以不让Git从HEAD拉取数据，而是通过具体指定一个提交来拉取该文件的对应版本。我们只需运行类似于git reset eb43bf file.txt的命令即可。 6. git checkout 介绍 6.1 切换分支：git checkout [分支名] 运行git checkout [branch]与运行git reset --hard [branch]非常相似，它会更新所有三棵树使其看起来像 [branch]，不过有两点重要的区别。 首先不同于reset --hard，checkout对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢。其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有还未修改过的文件都会被更新。而reset --hard则会不做检查就全面地替换所有东西。 第二个重要的区别是如何更新HEAD。reset会移动HEAD分支的指向，而checkout只会移动HEAD自身来指向另一个分支。 例如，假设我们有master和develop分支，它们分别指向不同的提交；我们现在在develop上（所以HEAD指向它）。如果我们运行git reset master，那么develop自身现在会和master指向同一个提交。而如果我们运行git checkout master的话，develop不会移动，HEAD自身会移动。 现在HEAD将会指向master。 所以，虽然在这两种情况下我们都移动HEAD使其指向了提交 A，但做法是非常不同的。reset 会移动HEAD分支的指向，而checkout则移动HEAD自身。 6.2 放弃index与working Directory的改动：git checkout [分支名] file.txt 该命令不会移动HEAD，只会把HEAD中的代码恢复到index中，同时把工作目录文件也恢复到HEAD中代码的样子。 6.3 值放弃修改working Directory 工作目录中的修改：git checkout file.txt放弃单个修改或使用git checkout .放弃所有修改 这个命令只会放弃工作目录中的修改，已经提交到index中的修改则不会改动。 reset\\checkout命令详细介绍 powered by Gitbook文件最后修改时间： 2022-09-05 16:17:09 "},"doc/git/004-git常用功能使用介绍.html":{"url":"doc/git/004-git常用功能使用介绍.html","title":"git常用功能使用介绍","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 GIT特殊功能使用介绍 1. git log 相关 1.1 查看一个文件的修改历史记录：git log -p filename 1.1.1 查看一个文件的所有改动历史记录：git log --pretty=oneline 文件名 1.1.2 查看文件的某次提交的改动记录:git show 提交的hash值 文件名 1.2 查看某个人的提交记录：git log --author=jack 1.3 统计代码行数 1.3.1 按提交时间段来统计 1.3.2 按用户名来统计 1.3.3 按用户名和时间段来统计 1.3.4 统计自己一天代码行数 1.3.5 使用find命令统计JS、css代码量 1.4 统计提交次数 1.5 其他的统计方法 2. 合并多个commit 3. 修改最后一次commit注释 4. 代码回退到以前版本 4.1 仅在本地有commit信息：git reset --hard 9e53f3 4.2 代码已经推送到仓库 4.2.1 强制更新仓库：git push -f，适用于影响小的 4.2.2 git revert 创建留下记录的回退 5. git revert 创建留下记录的回退 6. revert后取消revert 7.查看两个分支某个文件的差异 8. 两个仓库间代码同步 9. 将提交转移到其他分支：git cherry-pick 10. 查看项目占用磁盘大小 11. git count-objects：已解压对象文件的数量及其占用的磁盘空间 12. git gc：清理git存储库 13. 在错误分支开发了代码处理方法 13.1 代码还没有commit 13.2 代码已经commit，但是还没有推送到仓库 13.3 代码已经commit，并且已经推送到仓库中 [TOC] GIT特殊功能使用介绍 1. git log 相关 1.1 查看一个文件的修改历史记录：git log -p filename -p作用：可以显示每次提交的diff，不加-p值查看 git log -p doc/git/004-git常用功能使用介绍.md commit 65f8493043498c8f9ad6349129e53a2d81ba3ebe Author: user Date: 2021-06-23 17:12:36 git常用功能使用介绍 文档修改 diff --git a/doc/git/004-git常用功能使用介绍.md b/doc/git/004-git常用功能使用介绍.md index 0ca6418..947d869 100644 --- a/doc/git/004-git常用功能使用介绍.md +++ b/doc/git/004-git常用功能使用介绍.md @@ -174,6 +174,8 @@ git fetch -a && git checkout $branch && git pull `$branch`是Jenkins里面的分支名字变量。 +也可以修改Jenkins配置，在构建环境选项下面，把`Delete workspace before build starts`选线勾选上(在构建前删除工作空间)。然后部署即可，构建成功后在修改配置，把这个选项取消。 1.1.1 查看一个文件的所有改动历史记录：git log --pretty=oneline 文件名 ~ git log --pretty=oneline package.json 60e56ca779e269a4c16a0bb2bb57d845c551f725 添加echarts包 20f437c268646797ce7680c1117eb0c8db23f3b0 添加base-64的包 76087b874926b6b62bd8455309c681bd0c8bc2f7 删除无用的lib a8f7f419b2cb6e279f92a5660141fd32bbd963b3 自动计算高度 ... 1.1.2 查看文件的某次提交的改动记录:git show 提交的hash值 文件名 ~ git show 60e56ca779e26 package.json commit 60e56ca779e269a4c16a0bb2bb57d845c551f725 Author: user Date: Mon May 17 16:28:54 2021 +0800 添加echarts、echarts-gl包 diff --git a/package.json b/package.json index 8118086..08306c8 100644 @@ -15,6 +15,8 @@ \"base-64\": \"^1.0.0\", + \"echarts\": \"^5.0.0\", \"js-cookie\": \"^2.2.1\", 1.2 查看某个人的提交记录：git log --author=jack 1、这里的名字是git配置信息里面的名字，可使用git config --list命令查看配置信息，里面的user.name就是用户名。 ~ git config --list user.name=jack user.email=jack@163.com 2、名字可以不加冒号，如果名字中间有空格需要加冒号：git log --author=jack和git log --author=\"jack\"一样 ~ git log --author=jack commit 12aa...144b9f37c092 (HEAD -> master, origin/master, origin/HEAD) Author: jack Date: 2023-05-24 17:09:08 Mac系统操作习惯设置 文档编辑：添加mac操作系统升级说明 3、显示每次提交修改的代码： git log -p --author=\"jack 4、查看一段时间的提交： git log --author=\"jack\" --since=\"2023-01-01\" --until=\"2030-04-01\" 5、只显示一行信息： git log --author=\"jack\" --oneline 6、统计提交了多少次： git log --author=\"jack\" --oneline | wc -l 1.3 统计代码行数 注意：下面的命令都是统计当前分支的，如果要统计所有分支，需要加--all参数，比如： git log --all --since=2018-01-01 --until=2018-12-31 1.3.1 按提交时间段来统计 git log --since=2018-01-01 --until=2018-12-31 --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf \"added lines: %s, removed lines: %s, total lines: %s\\n\", add, subs, loc }' added lines: 36874, removed lines: 12214, total lines: 24660 上面的git命令按照2018-01-01到2018-12-31这段时间来统计你的代码提交量 1.3.2 按用户名来统计 此方法可以统计项目中，该用户的工作量 git log --author=\"username\" --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf \"added lines: %s, removed lines: %s, total lines: %s\\n\", add, subs, loc }' added lines: 29146, removed lines: 7457, total lines: 21689 注意把username改成真正的用户名。 1.3.3 按用户名和时间段来统计 此方法过滤一段时间内，某个用户的代码量 git log --author=\"username\" --since=2018-10-01 --until=2018-12-31 --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf \"added lines: %s, removed lines: %s, total lines: %s\\n\", add, subs, loc }' added lines: 2068, removed lines: 953, total lines: 1115 注意把username改成真正的用户名。 1.3.4 统计自己一天代码行数 git log --author=\"$(git config --get user.name)\" --no-merges --since=1am --stat git log --author=\"$(git config --get user.name)\" --no-merges --since=1am --stat --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf \"added lines: %s, removed lines: %s, total lines: %s\\n\", add, subs, loc }' 1.3.5 使用find命令统计JS、css代码量 js统计命令：find src/ -name \"*.js*\" |xargs cat|grep -v ^$|wc -l css统计命令: find src/ -name \"*.scss*\" |xargs cat|grep -v ^$|wc -l 1.4 统计提交次数 统计2024年1月1日至今当前分支的提交次数: git log --since=\"2024-01-01\" --author=\"作者名字\" --pretty=oneline | wc -l 统计2024年1月1日至今所有分支的提交次数: git log --all --since=\"2024-01-01\" --author=\"作者名字\" --pretty=oneline | wc -l 统计2023-01-01至2024-01-01当前分支的提交次数： git log --since=\"2023-01-01\" --until=\"2024-01-01\" --author=\"作者名字\" --pretty=oneline | wc -l 统计2023-01-01至2024-01-01所有分支的提交次数： git log --all --since=\"2023-01-01\" --until=\"2024-01-01\" --author=\"作者名字\" --pretty=oneline | wc -l 图片里面的仓库就一个分支，所以查看当前分支和查看所有分支是一样的。 1.5 其他的统计方法 查看仓库提交者排名前 5 git log --pretty='%aN' | sort | uniq -c | sort -k1 -n -r | head -n 5 贡献值统计 git log --pretty='%aN' | sort -u | wc -l 提交数统计 git log --oneline | wc -l 添加或修改的代码行数： git log --stat|perl -ne 'END { print $c } $c += $1 if /(\\d+) insertions/' 2. 合并多个commit 这个合并操作是在本地仓库，如果提交记录已经提交到远程仓库中了，如果别人还没有拉取，那么可以使用强制推送覆盖掉远程仓库的提交git push origin -f 1、如下图，有三个commit需要合并： 复制第四个commit的hash值后，使用git rebase -i 568361540e8c命令开始合并： ~ git rebase -i 568361540e8c 2、执行命令后，终端会进入一个VI编辑界面，如下图： 在VI编辑界面里面，上方未注释的部分是填写要执行的指令，而下方注释的部分则是指令的提示说明。指令部分中由前方的命令名称、commit hash 和 commit message 组成。 目前需要用的指令有两个pick 和 quash，指令的意思： pick：使用这个提交commit reword：使用这个提交commit，并且编辑这个提交信息； edit：选中，rebase时会暂停，允许你修改这个commit squash：选中，会将当前commit与上一个commit合并 fixup：与squash相同，但不会保存当前commit的提交信息 exec：执行其他shell命令 在VI编辑里面，按I按键，进入编辑模式，把第一行指令改成pick，第二行执行改成改成 squash 或 s 后，按esc键后，退出编辑模式，然后按:wq保存并退出，然后会进入到编辑commit界面： 其中, 非注释部分就是两次的 commit message, 进入编辑模式后，编辑提交信息，退出编辑模式，然后按:wq保存并退出。再次输入git log查看 commit 历史信息，你会发现这两个 commit 已经合并了。 3、注意事项：如果这个过程中有操作错误，可以使用 git rebase --abort来撤销修改，回到没有开始操作合并之前的状态。 3. 修改最后一次commit注释 其commit提供了一个--amend参数，可以修改最后一次提交的信息： git commit --amend 这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令）， 那么快照会保持不变，而你所修改的只是提交信息。 git commit --amend 详细教程 4. 代码回退到以前版本 当修改的代码发现有问题，需要回退到以前的版本。代码回退分一下几种情况。 4.1 仅在本地有commit信息：git reset --hard 9e53f3 当commit只在本地，没有推送到仓库中。则可进行如下操作： 1、保证git工作区域是干净的，如果有改动，可以暂存代码： ~ git diff > tmp.patch # 代码改动存放到一个文件中 ~ git checkout . # 取消所有改动 # 代码回退后可使用如下命令来 恢复改动 ~ git apply tmp.patch # 把改动还原回来 2、代码回退到特定的commit： ~ git reset --hard 9e53f30b7ab56e HEAD is now at 9e53f30 开始页面：添加提交按钮。 此时所有历史commit记录可使用git reflog来查找： ~ git reflog 26c5d5a (HEAD -> test, origin/test) HEAD@{0}: reset: moving to 26c5d5a 9e53f30 HEAD@{1}: reset: moving to 9e53f30b7ab56e 26c5d5a (HEAD -> test, origin/test) HEAD@{2}: commit: 添加测试包 9e53f30 HEAD@{3}: commit: 提交信息 如果回退错了，可使用上面命令找到commit的hash值，然后使用git reset --hard 9e53f30把之前的操作还原回来。 4.2 代码已经推送到仓库 4.2.1 强制更新仓库：git push -f，适用于影响小的 此方法适用于以下情况： 1、仅仅只是仓库更新代码了，仓库代码还没有被其他地方更新。2、其他开发人员拉取代码了，但是没有修改代码。3、自动部署拉取代码了，但是支持清理拉取的分支，或者支持清理操作空间。 1、本地代码使用4.1中的方式回退，然后强制推送到仓库中： # 本地仓库回退到指定位置 ~ git reset --hard 9e53f30b7 HEAD is now at 9e53f30 开始页面：添加提交按钮。 # 强制推送到服务器仓库中 ~ git push -f 注意，如果推送的分支是保护分支(gitlab仓库有保护分支设置)，那么只有这个仓库的Maintainer角色权限才能强推代码，或暂时把保护分支关闭才能正确推送代码。 2、其他开发人员拉取代码了，但是没有修改代码：使用git pull origin -f强制拉取服务器代码，覆盖掉本地代码。或者删除本地分支从新拉取这个分支代码。 3、部署工具支持清理代码：以Jenkins自动部署工具为例，在Jenkins配置里面的代码打包脚本里面添加如下命令(需要权限才能看到Jenkins配置项)： # 删除问题分支，然后从新拉取分支, $branch Jenkins里面的 分支名 变量 git checkout master && git branch -d $branch git fetch -a && git checkout $branch && git pull 也可以修改Jenkins配置，在构建环境选项下面，把Delete workspace before build starts选线勾选上(在构建前删除工作空间)。然后部署即可，构建成功后在修改配置，把这个选项取消。 4.2.2 git revert 创建留下记录的回退 由于代码已经在其他地方有了修改并提交了，或者一些环境不能破坏性的退回(git reset)。 此时可以使用git revert命令回退代码。具体参考git revert 命令介绍 5. git revert 创建留下记录的回退 当代码提交后，发现有问题，需要回退代码。但是代码已经扩散被其他成员拉取并修改了，则可以使用 revert 命令退回某个以提交的代码。 revert命令回退指定的commit提交。revert命令会产生一个新的commit信息，就像做了一次修改一样。使得其他环境可以正常的拉取回退代码，而不会导致冲突。 1、使用git log命令找到要回退 commit 的hash值。 2、使用 git revert 命令执行回退操作： ~ git revert d1e81adc50f2 上面的命令在终端执行后，会跳转到VI编辑commit提交信息中，写好回退说明后，保存退出VI编辑。终端使用git log命令就会看到这次回退记录： commit 3806cbee824f86bde4101739b8179211a674e640 (HEAD -> master) Revert \"2.txt文件添加\" This reverts commit d1e81adc50f2a965e17b524fd93ac222032817d4. ....其他记录略。。。。 3、git revert命令还可以一起连续回退几个连续的commit： ~ git revert d1e81adc5^..254524b4 # 注意^和..符号，重要 [master ffe7792] Revert \"3.txt文件添加\" 1 file changed, 0 insertions(+), 0 deletions(-) delete mode 100644 3.txt [master 993a1ac] Revert \"2.txt文件添加\" 1 file changed, 0 insertions(+), 0 deletions(-) delete mode 100644 2.txt 注意：旧的commit在前面，新的commit在后面，中间用..连接，在第一个commit后面放一个^表示这个commit也取消，如果没有^表示当前commit不取消。 在执行命令后，会连续进入几个VI编辑commit信息中，取消几个commit，就会添加几次新commit，其实这个连续revert命令跟一个一个的取消是一样的， 其他参考资料：https://blog.csdn.net/yxlshk/article/details/79944535 6. revert后取消revert 1、找到revert的commit的hash值 2、使用git revert hash的方式来取消回退 7.查看两个分支某个文件的差异 1、查看两个分支某个文件的差异： git diff branchOne branchTwo src/pages/index.js 1、查看两个分支详细差异： git diff branchOne branchTwo 2、查看两个分支简单的diff结果，只查看修改的文件名、修改了多少内容 git diff branchOne branchTwo --stat 8. 两个仓库间代码同步 有2个仓库A、B， 先拉取A仓库代码，代码修改后，提交。 1、在A仓库中，添加B仓库地址： git remote add upstream https://oauth2:H6misJwA@gitlab.xp.aaa.com/data-center/awakens-frontend.git 2、使用 git fetch 命令从 A 仓库中拉取代码到 B 仓库的本地仓库中，但是你应该指定远程仓库的名称（即 upstream），而不是直接使用 URL。 git fetch upstream 3、使用 git merge 命令将从 A 仓库拉取的代码合并到 B 仓库的当前分支。你需要指定要合并的分支，即 upstream/master。 git merge upstream/master # --allow-unrelated-histories 选项来允许合并不相关的历史。 git merge upstream/master --allow-unrelated-histories 注意在合并的时候可能会出现冲突和合并记录，按照要求解决即可，然后提交代码。 4、合并代码后，可以推送到A仓库中： git push # 或者 git push origin 9. 将提交转移到其他分支：git cherry-pick 对于多分支开发，将代码开发转移到另外一个分支是非常常见的操作。这时分两种情况：1、将一个分支所有变动都转移，那么就可以用git merge命令合并分支。2、只需要部分代码变动(某几个提交)，比如修复的bug修改，这个时候则可以采用 cherry-pick 命令。操作如下： 1、找到需要的commit的hash值： # 查看自己开发的提交信息 git log --author=\"Developer Name\" # 一行显示自己开发的提交信息 git log --author=\"Developer Name\" --oneline 2、开始cherry-pick代码，如果这个过程遇到代码冲突，跟合并冲突显示一样，需要手动解决： # 1、执行命令 git cherry-pick fd0c11547 # 如果遇到冲突 # 2、解决冲突后，添加冲突问题件 git add file.js # 3、继续执行cherry-pick git cherry-pick --continue # 4、中断执行 cherry-pick git cherry-pick --abort 3、cherry-pick结束后，推送代码。 参考链接： https://blog.csdn.net/weixin_44799217/article/details/128279250 https://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html 10. 查看项目占用磁盘大小 使用git命令查看： git ls-files | xargs cat | wc -c # 单位字节 其他方式查看 1、github项目，在浏览器中输入地址： https://api.github.com/repos/organization/repository 其中organization替换为项目的所有者(组织)，repository替换为项目的名称。返回的页面是描述这个项目的JSON数据，其中的size指的就是项目的大小，单位为kB(千字节)。结果见上图 2、新克隆一个项目，项目下载后，进入项目文件夹，把查看隐藏文件功能打开，删除.git文件夹，然后查看这个项目文件夹大小，就可以知道整个项目大小。 3、对于仓库在码云中，浏览器打开仓库，选择 统计 -> 仓库数据统计 ，在页面中有一个 仓库大小 显示列，就是这个仓库在码云中的存储大小。注意：由于码云仓库有存储库 GC 功能(位置：管理 -> 存储库 GC)，导致仓库存储会慢慢变大，这个大小会加到 仓库大小 里面，导致显示的大小会比真实的项目大，所以需要先来清理一下 存储库 GC，然后再去看仓库大小. 11. git count-objects：已解压对象文件的数量及其占用的磁盘空间 计算已解压对象文件的数量及其占用的磁盘空间，帮助你决定何时是重新打包的好时机 git count-objects -v 命令 提供更详细的报告，输出结果： git count-objects -v count: 2918 # 松散物体的数量 size: 60032 # 松散对象占用的磁盘空间，单位为 KiB（除非指定 -H） in-pack: 1799 # 包内对象的数量 packs: 4 size-pack: 12264 # 数据包占用的磁盘空间，单位 KiB（除非指定 -H） prune-packable: 4 # 在数据包中也存在的松散对象的数量。可以使用 `git prune-packed`对这些对象进行剪枝。 garbage: 0 # 对象数据库中既不是有效松散对象也不是有效包的文件数 size-garbage: 0 # 垃圾文件占用的磁盘空间，单位 KiB（除非指定 -H） git count-objects -H 命令以人类可读的格式打印对象大小，输出结果： ~ git count-objects -H # 以人类可读的格式打印对象大小 1 objects, 4.00 KiB 这个命令本人是用来清理git空间内容发现的一个命令 参考资料：https://git-scm.com/docs/git-count-objects/zh_HANS-CN 12. git gc：清理git存储库 整理、转载自：https://www.atlassian.com/zh/git/tutorials/git-gc git gc 命令是一个存储库维护命令，\"gc\" 代表垃圾回收。执行 git gc 实际上是让 Git 清理它在当前存储库中造成的混乱。垃圾回收是一个源自解释型编程语言的概念，这些语言会进行动态内存分配。解释型语言中的垃圾回收用于恢复正在执行的程序无法访问的内存。 Git 存储库会积累各种类型的垃圾。有一类 Git 垃圾是孤立提交或不可访问的提交。执行 git resets 或 git rebase 等修改历史记录的命令时，Git 提交可能会变得不可访问。为了保留历史记录和避免数据丢失，Git 不会删除分离的提交。分离的提交仍然可以通过 git log 签出、精心挑选和检查。 除了清理游离的提交外，git gc 还将对存储的 Git 对象执行压缩，从而释放宝贵的磁盘空间。当 Git 识别出一组相似的对象时，它会将它们压缩成一个‘包’。包就像 Git 对象的 zip 文件一样，存在于存储库的 ./git/objects/pack 目录中。 git gc 与 git prune：git gc 是一个父命令，git prune 是一个子命令。git gc 将在内部触发 git prune。git prune 用于移除 git gc 配置认为无法访问的 Git 对象。 git gc 可以使用 --agtressive 命令行选项调用。--aggressive 选项会导致 git gc 在优化工作上花费更多时间。这会导致 git gc 运行速度变慢，但在完成后会节省更多磁盘空间。--aggressive 的效果是持久的，只有在对存储库进行大量变更后才需要运行。 使用例子： git gc --aggressive Enumerating objects: 4070, done. Counting objects: 100% (4070/4070), done. Delta compression using up to 8 threads Compressing objects: 100% (4025/4025), done. Writing objects: 100% (4070/4070), done. Total 4070 (delta 2607), reused 401 (delta 0), pack-reused 0 执行效果可以通过git count-objects -v命令来查看效果，在执行git gc前，count-objects命令count: 2918、size: 60032(见上一节里面的图片)，执行git gc后，变成了count: 1、size: 4 13. 在错误分支开发了代码处理方法 开发代码发现分支不对，需要把当前分支代码移到正确的分支，并且把当前分支代码回退到未修改前的状态。 13.1 代码还没有commit 1、使用git diff > tmp.patch 形式 # 1、保存修改到 tmp.patch 文件中 git diff > tmp.patch # 2、取消所有修改 git checkout . # 3、切换到正确的分支 git checkout branch_name # 4、把修改的代码添加上 git apply tmp.patch # 5、删除临时文件 rm tmp.patch 2、使用 stash 命令： # 1、把当前修改的内容暂存起来，然后我们的工作区就恢复到在没有开发新功能之前的样子。 git stash # 2、切换到正确的分支 git checkout branch_name # 3、把之前暂存的内容，应用到当前分支。 git stash apply 13.2 代码已经commit，但是还没有推送到仓库 1、提交的代码移到正确分支中，有以下两种命令可以实现：1.1 使用 git cherry-pick，这个命令会把commit移到其他分支，详情参考这个文档里面 的命令介绍。1.2 使用git merge 分支合并命令把代码合并到正确分支中。注意：只有在确认了两个分支的差别只有新提交的commit才可以使用这个命令。 2、当前分支代码回退到未修改前： git reset --hard 9e53f30b7ab56e # 所有历史commit记录可使用git reflog来查找，回退错了可以使用这个命令来找到commit 从新回退 git reflog 13.3 代码已经commit，并且已经推送到仓库中 1、提交的代码移到正确的分支中，参考 13.2中的方法。 2、当前分支代码回退到未修改前：参考4.2中的方法。 powered by Gitbook文件最后修改时间： 2025-01-23 14:20:36 "},"doc/git/005-git常见问题及解决.html":{"url":"doc/git/005-git常见问题及解决.html","title":"git常见问题及解决","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 git常见问题及解决 1. 不同操作系统使用git时，CRLF的处理换行问题 1.1 什么是CRLF和LF 1.2 在Git中设置自动转换 2. 多个仓库相同代码推送被拒绝 3. git使用vi编辑器时候报错：Swap file \"./.git/.COMMIT_EDITMSG.swp\" already exists! 4. Git中文乱码的问题 5. GIT不识别大小写文件夹解决 6. 同一个文件跟踪两次 7. 切换分支报错：有文件未跟踪 8. gitlab保护分支，导致本地git push -f报错 9. git rm --cached 报错：recursively without -r 10. GIT添加空文件夹到项目.gitkeep 11. git clone early EOF error 的解决方式 12. git命令报错：xcrun: error: invalid active developer path 13. git pull报错：fatal: refusing to merge unrelated histories 14. 码云仓库上提示代码仓库存储超过500MB 15. git status 提示：Permission denied 16. git忽略本地已存在文件的修改 17. git pull报错：error: cannot lock ref…unable to resolve reference…reference broken 18. git push 报错解决 18.1 the remote end hung up unexpectedly 18.2 RPC failed; HTTP 500 curl 22 The requested URL returned error: 500 [TOC] git常见问题及解决 1. 不同操作系统使用git时，CRLF的处理换行问题 错误信息类似于： # https://git-scm.com/book/zh/v2/自定义-Git-配置-Git ~ git diff > tmp.patch warning: LF will be replaced by CRLF in src/app/theme/components/menuItem/menuItem.component.css. The file will have its original line endings in your working directory. warning: LF will be replaced by CRLF in config/webpack.dev.js. 1.1 什么是CRLF和LF CRLF 是 carriage return line feed的缩写。中文意思是回车换行。LF是line feed的缩写，中文意思是换行。CRLF->Windows-styleLF->Unix StyleCR->Mac StyleCRLF表示句尾使用回车换行两个字符(即我们常在Windows编程时使用\"\\r\\n\"换行)LF表示表示句尾，只使用换行.CR表示只使用回车. 1.2 在Git中设置自动转换 在Git通过下面的命令配置: $git config --global core.autocrlf true # Configure Git on Windows to properly handle line endings 设置为true，添加文件到git仓库时，git将其视为文本文件。他将把crlf变成lf。设置为false时，line-endings将不做转换操作。文本文件保持原来的样子。设置为input时，添加文件git仓库石，git把crlf编程lf。当有人Check代码时还是lf方式。因此在window操作系统下，不要使用这个设置。 1) true: x -> LF -> CRLF2) input: x -> LF -> LF3) false: x -> x -> x 其他的命令 # AutoCRLF #提交时转换为LF，检出时转换为CRLF git config --global core.autocrlf true #提交时转换为LF，检出时不转换 git config --global core.autocrlf input #提交检出均不转换 git config --global core.autocrlf false # SafeCRLF #拒绝提交包含混合换行符的文件 git config --global core.safecrlf true #允许提交包含混合换行符的文件 git config --global core.safecrlf false # 设置这个命令会把警告取消 #提交包含混合换行符的文件时给出警告 git config --global core.safecrlf warn 2. 多个仓库相同代码推送被拒绝 当添加一个仓库后，推送文件上去不允许,错误信息类似于： git push github master To https://github.com/user/my_wiki.wiki.git ! [rejected] master -> master (fetch first) error: failed to push some refs to 'https://github.com/user/my_wiki.wiki.git' hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., 'git pull ...') before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. 如果远程仓库的代码没用了，不要了，则可以选择强推代码解决问题： ~ git push -u github master -f 3. git使用vi编辑器时候报错：Swap file \"./.git/.COMMIT_EDITMSG.swp\" already exists! 非正常关闭vi编辑器时会生成一个.swp文件。使用vi，经常可以看到swp这个文件,那这个文件是怎么产生的呢，当你打开一个文件，vi就会生成这么一个.(filename)swp文件 以备不测（不测下面讨论），如果你正常退出，那么这个这个swp文件将会自动删除 。swp文件的来历，当你强行关闭vi时，比如电源突然断掉或者你使用了Ctrl+ZZ，vi自动生成一个.swp文件，下次你再编辑时，就会出现一些提示。 比如你正在使用vi编辑file.txt文件，然后强制关闭终端，这个时候就会产生.file.txt.swp文件。当再次使用vi打开file.txt文件就会出现提示， 这个时候可使用下面的命令来恢复未保存的操作： vi -r file.txt 这个时候保存中断之前的操作后，.swp文件不会自动删除，需要自己手动删除： rm .file.txt.swp 4. Git中文乱码的问题 在使用git命令的时候，如果文件名是中文的，就会出现如\\200\\273\\347\\273\\223.png的乱码。 解决方法，在终端中输入如下命令： git config --global core.quotepath false core.quotepath设为false的话，就不会对0x80以上的字符进行quote。中文显示正常。 参考链接： http://blog.csdn.net/tyro_java/article/details/53439537 5. GIT不识别大小写文件夹解决 在mac电脑下，git仓库中有文件夹首字母大写，修改成首字母小写后，git没有识别出文件夹的修改， 可使用如下命令设置为大小写敏感： git config core.ignorecase false 6. 同一个文件跟踪两次 由于修改了文件名，仅仅是文件名首字母大小写修改了，然后就导致git同时把这一个文件跟踪了两次，比如我修改了文件夹名字，由Settings 改成 settings,导致文件夹下的文件重复出现： modified: src/views/Settings/TagSet/TagDialog.jsx modified: src/views/settings/TagSet/TagDialog.jsx 此时可使用git rm --cached来取消对重命名之前的文件跟踪 git rm --cached src/views/Settings/TagSet/TagDialog.jsx rm 'src/views/Settings/TagSet/TagDialog.jsx' 取消跟踪后，使用git status查看，就会发现这个文件自动添加到删除中了： ~ git rm --cached src/views/Settings/TagSet/TaDialog.jsx rm 'src/views/Settings/TagSet/TagDialog.jsx' ~ git status On branch master Your branch is up-to-date with 'origin/master'. Changes to be committed: (use \"git reset HEAD ...\" to unstage) deleted: src/views/Settings/RuleSet/RuleDialog.jsx deleted: src/views/Settings/TagSet/TagDialog.jsx modified: src/views/settings/RuleSet/RuleDialog.jsx modified: src/views/settings/TagSet/TagDialog.jsx 7. 切换分支报错：有文件未跟踪 当我切换分支的时候，出现如下错误信息： ~ git co develop error: The following untracked working tree files would be overwritten by checkout: src/data-map/components/atlas-left-Catalog/index.jsx Please move or remove them before you switch branches. 这个文件是不存在的，我之前由于修改了文件夹名大小写并提交了代码，到这这个文件不存在，使用git rm --cached无效， 在网上搜索解决方法： # 删除 一些 没有 git add 的 文件 git clean -d -fx git clean 参数 -n 显示将要删除的文件和目录； -x -----删除忽略文件已经对git来说不识别的文件 -d -----删除未被添加到git的路径中的文件 -f -----强制运行 这个命令会删除所有没被add的文件，使用命令后就删除了node_modules等文件夹，所有使用需谨慎， 我使用这个命令后，并没有解决问题，后来我删除了项目，从新clone一个项目，安装后，在切换分支就好了， 所以可以尝试删除项目，然后从新安装，或者直接从现有的项目中把node_modules文件夹复制过来 8. gitlab保护分支，导致本地git push -f报错 产生原因：服务器提交了错误或者无用的代码，本地回滚代码，然后把代码强推到服务器上，由于gitlab上有分支保护导致代码推送失败： git push origin master -f Total 0 (delta 0), reused 0 (delta 0) remote: GitLab: You are not allowed to force push code to a protected branch on this project. To http://git.baijiahulian.com/yunying/bi-fe.git ! [remote rejected] master -> master (pre-receive hook declined) error: failed to push some refs to 'http://git.baijiahulian.com/yunying/bi-fe.git' 在gitlab上查看保护的分支 在gitlab上打开项目，点击Repository, 然后点击Branches,就能看见所有分支，在分支名字后面有个绿色的protected就是保护分支。 关闭gitlab上的保护分支(需要项目的master或者Owner) 点击项目右上角(用户logo下面)的小齿轮，选择Protected Branches,在打开的页面里面就能看见保护的分支了，然后点击保护分支右边的Unprotect,就能删除对这个分支的保护了。 开启gitlab上的保护分支(需要项目的master或者Owner) 点击项目右上角(用户logo下面)的小齿轮，选择Protected Branches, 在Protect a branch中输入分支名字，选择对应权限，然后点击Protect，就会立刻添加一个保护分支了。 9. git rm --cached 报错：recursively without -r 当需要取消一个文件夹跟踪时，报错： git rm --cached src/css/common/theme/ fatal: not removing 'src/css/common/theme/' recursively without -r 根据网络查找资料，是说这个文件夹需要递归取消跟踪列表里的文件 在命令加上-f即可： git rm -r --cached src/css/common/theme/ rm 'src/css/common/theme/graph/graph-var.less' rm 'src/css/common/theme/graph/graph-var.scss' 10. GIT添加空文件夹到项目.gitkeep 因为git空目录无法add。如果想add一个空目录，则需要在它下面创建一个文件。 这个算设计失误吧，好多项目还得弄个假文件在空文件夹里面占位。 大概是linus一开始就把快照设计成只有文件组成，后来想想要改太难，就算了吧。反正你们可以用假文件来占位（oh，so linux！），为什么要linus亲自实现它。 解决办法是在空文件夹下创建一个.gitkeep文件，然后添加这个文件即可 11. git clone early EOF error 的解决方式 https://www.jianshu.com/p/189fd3c9d0ac 1、在我遇到的这个错误的原因应该是文件太大,解决方式为git添加 compression 配置项: ~ git config --global core.compression -1 compression 是压缩的意思，从 clone 的终端输出就知道，服务器会压缩目标文件，然后传输到客户端，客户端再解压。取值为 [-1, 9]，-1 以 zlib 为默认压缩库，0 表示不进行压缩，1..9 是压缩速度与最终获得文件大小的不同程度的权衡，数字越大，压缩越慢，当然得到的文件会越小。 2、可以增加git的缓存大小 ~ git config --global http.postBuffer 1048576000 将http.postBuffer设置的尽量大，例如git config --global http.postBuffer 524288000 （500M） git config --global http.postBuffer 1048576000 (1G)。再大的应该是依次类推吧 因为下载的时候不止是工程数据，还有其它配置数据，总量会大于工程数据量，所以设置的缓存大小一定要比工程大小多一些。 3、配置git的最低速和最低速时间 git config --global http.lowSpeedLimit 0 git config --global http.lowSpeedTime 999999 单位 秒 12. git命令报错：xcrun: error: invalid active developer path 我的系统是Mac系统，由于我对Mac系统进行了升级，Mac系统升级到了Mojave 10.14.6。 然后，使用git命令后，报错： ~ git st xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun 经过网络查找:https://www.jianshu.com/p/50b6771eb853 需要安装重装xcode command line，终端输入如下命令： xcode-select --install 如果没有解决问题，执行以下命令 sudo xcode-select -switch / 13. git pull报错：fatal: refusing to merge unrelated histories 当使用git pull拉取代码的时候报错： fatal: refusing to merge unrelated histories 经过翻译：拒绝合并无关的历史 错误原因：其实这个问题是因为 两个 根本不相干的 git 库， 一个是本地库， 一个是远端库， 然后本地要去拉取代码， 本地库觉得远端库跟自己不相干， 所以告知无法合并。 解决办法，强制拉取合并： git pull --allow-unrelated-histories git pull origin master --allow-unrelated-histories --allow-unrelated-histories ：把两段不相干的 分支进行强行合并。 由于两个版本不相干，强制拉取下来后会有很多冲突，如果确定本地的分支不需要了，那么可以删除本地分支，然后在拉取远程分支。 此问题参考：https://blog.csdn.net/Websphere_zxf/article/details/90475875 14. 码云仓库上提示代码仓库存储超过500MB 在把代码推送到码云上时，提示代码仓库使用空间超过500MB了， 但是经过查看本地文件大小，发现代码仓库并没有那么大，经过新建仓库，然后把代码推送到新仓库后发现代码并没有那么大，经过查找，需要清理存储库GC。 查看码云仓库控使用空间：打开码云仓库 -> 页面右边 star下面的服务按钮 -> 里面有仓库大小显示。 清理存储库GC：打开码云仓库 -> 页面右边 star下面的管理按钮 -> 左边选择存储库GC -> 点击 存储库GC 按钮清理 也可以在管理页面，选择清空仓库，然后从新把代码推动到仓库中。 15. git status 提示：Permission denied 当使用git status命令时，终端报如下错误： $ git status warning: could not open directory 'csic-vue/src/api/mixin/': Permission denied warning: could not open directory 'csic-vue/src/components/ci-file-upload/': Permission denied 在网上查找资料： https://github.com/vuejs/vue-cli/issues/1809 可尝试使用如下命令： npm cache clear --force sudo npm cache clear --force 16. git忽略本地已存在文件的修改 １、将文件修改忽略 git update-index --assume-unchanged 带路径的文件名 2、取消文件忽略 git update-index --no-assume-unchanged 带路径的文件名 17. git pull报错：error: cannot lock ref…unable to resolve reference…reference broken 当使用git pull拉取远程仓库代码是报错： $ git pull error: cannot lock ref 'refs/remotes/origin/master': unable to resolve reference 'refs/remotes/origin/master': reference broken From bitbucket.org:xx/mkyong-tutorials ! [new branch] master -> origin/master (unable to update local ref) 问题原因：原因是你这个git工程的.git/refs目录下跟踪的某些git分支，在git pull的时候，与远端的对应分支的refs对比发现不同，所以导致git pull报错。 通常产生这个问题的原因是（以分支git/yousa/feature_01为例）：1、有人操作这个分支，在git push的时候使用了git push –force，导致远端分支被覆盖，你本地的refs与远端无法一致，导致问题。 2、git分支是不区分大小写的，如果有人删除掉这个远端分支又重新新建了一个这个分支也会出现同样的问题。 解决办法：1、强行拉取远程代码，执行git pull -p，这种可能会导致本地提交内容被删除掉。2、删除掉有问题的refs，再进行git pull(以分支master为例)，可以直接在.git/refs下面根据错误提示删除对应的refs文件，比如上面报错就是需要删除refs/remotes/origin/master文件（嫌麻烦直接删除整个refs目录也行） 使用git命令删除相应refs文件： git update-ref -d refs/remotes/origin/master 使用终端命令直接删除这个文件，如下方式： $ rm .git/refs/remotes/origin/master $ git fetch From bitbucket.org:xx/mkyong-tutorials df0eee8..3f7af90 master -> origin/master $ git pull Already up to date. 18. git push 报错解决 18.1 the remote end hung up unexpectedly 当推送代码到远程仓库的时候，发生报错： ~ git push mayun Compressing objects: 100% (184/184), done. send-pack: unexpected disconnect while reading sideband packet Writing objects: 100% (188/188), 4.55 MiB | 6.36 MiB/s, done. Total 188 (delta 111), reused 0 (delta 0), pack-reused 0 fatal: the remote end hung up unexpectedly Everything up-to-date # 错误信息大概意思：发送数据时意外断开。致命错误：远程意外挂起 经过在网络上搜索发现问题可能原因： 网络连接问题 在推送过程中，网络连接中断或不稳定可能会导致这个错误 如果网络连接较慢，推送数据包可能会超过远程服务器的超时设置，从而导致连接中断 远程服务器配置问题 如果远程仓库所在的服务器存储空间不足，也可能导致推送失败 如果一次性推送的数据量过大（例如，推送大文件或大量提交记录），可能会超过服务器的处理能力，从而中断连接 本地 Git 配置问题 Git的默认缓冲区大小可能不足以处理大规模推送操作，导致错误发生 经过排查，我的网络没有问题，代码推送到github仓库能成功推送。 我推送的远程仓库是码云，码云的仓库有大小限制(500MB)，之前仓库有过存储大于500MB了，然后我清理了 存储库GC。我这次清理后，然后在 统计 -> 仓库数据统计 里面仓库大小不到100MB了。再次推送代码，还是报错。然后我又清空了仓库，推送代码还是不行，所以远程仓库问题基本排除了。 剩下的基本就是git的默认缓存区大小问题。 解决办法： 1、增加Git的默认缓冲区大小，设置单位为字节 # 只在项目中设置，增加Git的默认缓冲区大小 git config http.postBuffer 524288000 # 扩大缓存为500MB # 查看项目下的git配置命令 git config --list # 也可以全局设置，这样每个项目都能生效 git config --global http.postBuffer 524288000 # 查看全局的git配置命令 git config --global --list # 如果仓库使用的ssh形式拉取的，则需要如下命令 # git config ssh.postBuffer 524288000 设置后，在次推送代码，发现推送成功，问题解决 2、对于网络问题，可以尝试配置git的最低速度和最低速度时间： # 报错：fatal: The remote end hung up unexpectedlyB | 2.00 KiB/s git config http.lowSpeedLimit 0 git config http.lowSpeedTime 999999 # 单位 秒 # 如果全局设置使用 git config --global 命令 这个本人没有试过，如果出现这个网络问题了，可以试试这个 3、以上都无效，可以试试这个: git config sendpack.sideband false # 如果全局设置使用 git config --global 命令 这个没试过，如果以上方法都没解决，可以试试这个 参考资料： https://blog.csdn.net/qq_37380933/article/details/140922355 https://www.cnblogs.com/rgqjson/p/13297526.html https://github.com/orgs/community/discussions/39210 18.2 RPC failed; HTTP 500 curl 22 The requested URL returned error: 500 当使用git push 命令推送代码的时候，报如下错误： Enumerating objects: 318, done. Counting objects: 100% (318/318), done. Delta compression using up to 8 threads Compressing objects: 100% (310/310), done. error: RPC failed; HTTP 500 curl 22 The requested URL returned error: 500 send-pack: unexpected disconnect while reading sideband packet Writing objects: 100% (310/310), 1.54 MiB | 4.74 MiB/s, done. Total 310 (delta 54), reused 0 (delta 0), pack-reused 0 fatal: the remote end hung up unexpectedly Everything up-to-date 经过网络查找，这个问题跟 上面的 18.1 问题是一样的，是由于 git 缓冲区大小造成的(默认为1MB)。经过查看代码，我这里提交里面有一些图片(共计1.7MB)，超过了缓存区大小，因此报错了，解决方案就是增加缓存大小： git config --global http.postBuffer 157286400 # 全局配置，缓存区增加到150MB， 单位是字节 配置好后，再次推送代码就成功了。 参考资料：https://community.atlassian.com/t5/Bitbucket-questions/git-push-returns-500-server-error/qaq-p/2809308 powered by Gitbook文件最后修改时间： 2024-12-18 15:00:28 "},"doc/git/006-git代码冲突处理软件P4Merge.html":{"url":"doc/git/006-git代码冲突处理软件P4Merge.html","title":"git代码冲突处理软件P4Merge","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. 下载安装 2. 配置脚本 参考链接 [TOC] 1. 下载安装 下载地址：https://www.perforce.com/downloads/helix-visual-client-p4v下载教程：http://blog.csdn.net/wirelessqa/article/details/9035215这里下载之前需要注册。 2. 配置脚本 编写一个全局包装脚本来运行你的命令。 我们会使用 Mac 上的路径来指定该脚本的位置，在其他系统上，它将是 p4merge 二进制文件所在的目录。 创建一个名为 extMerge 的脚本包装 merge 命令，让它把参数转发给 p4merge 二进制文件： $ cat /usr/local/bin/extMerge #!/bin/sh /Applications/p4merge.app/Contents/MacOS/p4merge $* 创建一个extDiff的脚本： $ cat /usr/local/bin/extDiff #!/bin/sh [ $# -eq 7 ] && /usr/local/bin/extMerge \"$2\" \"$5\" 确保这些脚本具有可执行权限： $ sudo chmod +x /usr/local/bin/extMerge $ sudo chmod +x /usr/local/bin/extDiff 配置git命令支持这个软件： $ git config --global merge.tool extMerge # 下面的参考链接里面这部分有误，照这个做 $ git config --global mergetool.extMerge.cmd 'extMerge \"$BASE\" \"$LOCAL\" \"$REMOTE\" \"$MERGED\"' $ git config --global mergetool.extMerge.trustExitCode false $ git config --global diff.external extDiff 或编辑你的 ~/.gitconfig 文件，添加以下各行： # 上面终端命令跟下面的做法是一样的 [merge] tool = extMerge [mergetool \"extMerge\"] cmd = extMerge \"$BASE\" \"$LOCAL\" \"$REMOTE\" \"$MERGED\" trustExitCode = false [diff] external = extDiff 待一切设置妥当后，如果你像这样运行 diff 命令git diff 32d1776b1^ 32d1776b1 Git 将启动 P4Merge，而不是在命令行输出比较的结果.如果你尝试合并两个分支，随后遇到了合并冲突，运行 git mergetool，Git 会调用 P4Merge 让你通过图形界面来解决冲突。 参考链接 git-book： https://git-scm.com/book/zh/v2/自定义-Git-配置-Git csdn： http://blog.csdn.net/ccf0703/article/details/7661789 powered by Gitbook文件最后修改时间： 2021-03-11 10:06:50 "},"doc/git/007-git内部原理揭秘.html":{"url":"doc/git/007-git内部原理揭秘.html","title":"git内部原理揭秘","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 说明 [TOC] 说明 转载自知乎：https://zhuanlan.zhihu.com/p/96631135 powered by Gitbook文件最后修改时间： 2021-03-17 22:05:38 "},"doc/git/008-动图展示10大Git命令.html":{"url":"doc/git/008-动图展示10大Git命令.html","title":"动图展示10大Git命令","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 动图展示10大Git命令 1. 合并 1.1 Fast-forward (—ff) 1.2 No-fast-foward (—no-ff) 2. 合并冲突 3. 变基（Rebasing） 4. 交互式变基（Interactive Rebase） 5. 重置（Resetting） 5.1 软重置 5.2 硬重置 6. 还原（Reverting） 7. 拣选（Cherry-picking） 8. 取回（Fetching） 9. 拉取（Pulling） 10. Reflog [TOC] 动图展示10大Git命令 本文整理、转载自：https://zhuanlan.zhihu.com/p/132573100 git merge、git rebase、git reset、git revert、git fetch、git pull、git reflog……你知道这些 git 命令执行的究竟是什么任务吗？如果你还有些分不清楚，那千万不能错过这篇文章。在本文中，熟知 JavaScript、TypeScript、GraphQL、Serverless、AWS、Docker 和 Golang 的 21 岁年轻软件顾问 Lydia Hallie 通过动图形式直观地介绍了这些常用 git 命令的工作过程，包你过目不忘。 选自dev.to，作者：Lydia Hallie，机器之心编译，参与：Panda、杜伟。 尽管 Git 是一款非常强大的工具，但如果我说 Git 用起来简直是噩梦，大多数人也会认同我的说法。我发现在使用 Git 时，在头脑里可视化地想象它会非常有用：当我执行一个特定命令时，这些分支会如何交互，又会怎样影响历史记录？为什么当我在 master 上执行硬重启，force push 到原分支以及 rimraf 我们的 .git 文件夹时，我的同事哭了？ 我觉得创建一些最常用且最有用的 Git 命令的可视化示例会是一个完美的用例！下面我将介绍的很多命令都有可选参数——你可以使用这些参数来改变对应命令的行为。而我的示例只会涵盖命令的默认行为，而不会添加（或添加太多）可选配置！ 1. 合并 拥有多个分支是很方便的，这样可以将不同的新修改互相隔离开，而且还能确保你不会意外地向生产代码推送未经许可或破损的代码修改。但一旦这些修改得到了批准许可，我们就需要将其部署到我们的生产分支中！ 可将一个分支的修改融入到另一个分支的一种方式是执行 git merge。Git 可执行两种类型的合并：fast-forward 和 no-fast-forward。现在你可能分不清，但我们马上就来看看它们的差异所在。 1.1 Fast-forward (—ff) 在当前分支相比于我们要合并的分支没有额外的提交（commit）时，可以执行 fast-forward 合并。Git 很懒，首先会尝试执行最简单的选项：fast-forward！这类合并不会创建新的提交，而是会将我们正在合并的分支上的提交直接合并到当前分支。 完美！现在，我们在 dev 分支上所做的所有改变都合并到了 master 分支上。那么 no-fast-forward 又是什么意思呢？ 1.2 No-fast-foward (—no-ff) 如果你的当前分支相比于你想要合并的分支没有任何提交，那当然很好，但很遗憾现实情况很少如此！如果我们在当前分支上提交我们想要合并的分支不具备的改变，那么 git 将会执行 no-fast-forward 合并。 使用 no-fast-forward 合并时，Git 会在当前活动分支上创建新的 merging commit。这个提交的父提交（parent commit）即指向这个活动分支，也指向我们想要合并的分支！ 没什么大不了的，完美的合并！现在，我们在 dev 分支上所做的所有改变都合并到了 master 分支上。 2. 合并冲突 尽管 Git 能够很好地决定如何合并分支以及如何向文件添加修改，但它并不总是能完全自己做决定。当我们想要合并的两个分支的同一文件中的同一行代码上有不同的修改，或者一个分支删除了一个文件而另一个分支修改了这个文件时，Git 就不知道如何取舍了。 在这样的情况下，Git 会询问你想要保留哪种选择？假设在这两个分支中，我们都编辑了 README.md 的第一行。 如果我们想把 dev 合并到 master，就会出现一个合并冲突：你想要标题是 Hello! 还是 Hey!？ 当尝试合并这些分支时，Git 会向你展示冲突出现的位置。我们可以手动移除我们不想保留的修改，保存这些修改，再次添加这个已修改的文件，然后提交这些修改。 完成！尽管合并冲突往往很让人厌烦，但这是合理的：Git 不应该瞎猜我们想要保留哪些修改。 3. 变基（Rebasing） 我们刚看到可通过执行 git merge 将一个分支的修改应用到另一个分支。另一种可将一个分支的修改融入到另一个分支的方式是执行 git rebase。 git rebase 会将当前分支的提交复制到指定的分支之上。 完美，现在我们在 dev 分支上获取了 master 分支上的所有修改。 变基与合并有一个重大的区别：Git 不会尝试确定要保留或不保留哪些文件。我们执行 rebase 的分支总是含有我们想要保留的最新近的修改！这样我们不会遇到任何合并冲突，而且可以保留一个漂亮的、线性的 Git 历史记录。 上面这个例子展示了在 master 分支上的变基。但是，在更大型的项目中，你通常不需要这样的操作。git rebase 在为复制的提交创建新的 hash 时会修改项目的历史记录。 如果你在开发一个 feature 分支并且 master 分支已经更新过，那么变基就很好用。你可以在你的分支上获取所有更新，这能防止未来出现合并冲突。 4. 交互式变基（Interactive Rebase） 在为提交执行变基之前，我们可以修改它们！我们可以使用交互式变基来完成这一任务。交互式变基在你当前开发的分支上以及想要修改某些提交时会很有用。 在我们正在 rebase 的提交上，我们可以执行以下 6 个动作： reword：修改提交信息； edit：修改此提交； squash：将提交融合到前一个提交中； fixup：将提交融合到前一个提交中，不保留该提交的日志消息； exec：在每个提交上运行我们想要 rebase 的命令； drop：移除该提交。 很棒！这样我们就能完全控制我们的提交了。如果你想要移除一个提交，只需 drop 即可。 如果你想把多个提交融合到一起以便得到清晰的提交历史，那也没有问题！ 交互式变基能为你在 rebase 时提供大量控制，甚至可以控制当前的活动分支。 5. 重置（Resetting） 当我们不想要之前提交的修改时，就会用到这个命令。也许这是一个 WIP 提交或者可能是引入了 bug 的提交，这时候就要执行 git reset。 git reset 能让我们不再使用当前台面上的文件，让我们可以控制 HEAD 应该指向的位置。 5.1 软重置 软重置会将 HEAD 移至指定的提交（或与 HEAD 相比的提交的索引），而不会移除该提交之后加入的修改！ 假设我们不想保留添加了一个 style.css 文件的提交 9e78i，而且我们也不想保留添加了一个 index.js 文件的提交 035cc。但是，我们确实又想要保留新添加的 style.css 和 index.js 文件！这是软重置的一个完美用例。 输入 git status 后，你会看到我们仍然可以访问在之前的提交上做过的所有修改。这很好，这意味着我们可以修复这些文件的内容，之后再重新提交它们！ 5.2 硬重置 有时候我们并不想保留特定提交引入的修改。不同于软重置，我们应该再也无需访问它们。Git 应该直接将整体状态直接重置到特定提交之前的状态：这甚至包括你在工作目录中和暂存文件上的修改。 Git 丢弃了 9e78i 和 035cc 引入的修改，并将状态重置到了 ec5be 的状态。 6. 还原（Reverting） 另一种撤销修改的方法是执行 git revert。通过对特定的提交执行还原操作，我们会创建一个包含已还原修改的新提交。 假设 ec5be 添加了一个 index.js 文件。但之后我们发现其实我们再也不需要由这个提交引入的修改了。那就还原 ec5be 提交吧！ 完美！提交 9e78i 还原了由提交 ec5be 引入的修改。在撤销特定的提交时，git revert 非常有用，同时也不会修改分支的历史。 7. 拣选（Cherry-picking） 当一个特定分支包含我们的活动分支需要的某个提交时，我们对那个提交执行 cherry-pick！对一个提交执行 cherry-pick 时，我们会在活动分支上创建一个新的提交，其中包含由拣选出来的提交所引入的修改。 假设 dev 分支上的提交 76d12 为 index.js 文件添加了一项修改，而我们希望将其整合到 master 分支中。我们并不想要整个 dev 分支，而只需要这个提交！ 现在 master 分支包含 76d12 引入的修改了。 8. 取回（Fetching） 如果你有一个远程 Git 分支，比如在 GitHub 上的分支，当远程分支上包含当前分支没有的提交时，可以使用取回。比如当合并了另一个分支或你的同事推送了一个快速修复时。 通过在这个远程分支上执行 git fetch，我们就可在本地获取这些修改。这不会以任何方式影响你的本地分支：fetch 只是单纯地下载新的数据而已。 现在我们可以看到自上次推送以来的所有修改了。这些新数据也已经在本地了，我们可以决定用这些新数据做什么了。 9. 拉取（Pulling） 尽管 git fetch 可用于获取某个分支的远程信息，但我们也可以执行 git pull。git pull 实际上是两个命令合成了一个：git fetch 和 git merge。当我们从来源拉取修改时，我们首先是像 git fetch 那样取回所有数据，然后最新的修改会自动合并到本地分支中。 很好，我们现在与远程分支完美同步了，并且也有了所有最新的修改！ 10. Reflog 每个人都会犯错，但犯错其实没啥！有时候你可能感觉你把 git repo 完全搞坏了，让你想完全删了了事。 git reflog 是一个非常有用的命令，可以展示已经执行过的所有动作的日志。包括合并、重置、还原，基本上包含你对你的分支所做的任何修改。 如果你犯了错，你可以根据 reflog 提供的信息通过重置 HEAD 来轻松地重做！ 假设我们实际上并不需要合并原有分支。当我们执行 git reflog 命令时，我们可以看到这个 repo 的状态在合并前位于 HEAD@{1}。那我们就执行一次 git reset，将 HEAD 重新指向在 HEAD@{1} 的位置。 我们可以看到最新的动作已被推送给 reflog。 英文原文链接：https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1 powered by Gitbook文件最后修改时间： 2021-03-10 22:11:07 "},"doc/git/009-git忽略文件方法.html":{"url":"doc/git/009-git忽略文件方法.html","title":"git忽略文件方法","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 git忽略文件的方式 1. .gitignore 文件(整个仓库都忽略) 2. 本机开发忽略.git/info/exclude 3. 忽略已跟踪文件改动 assume-unchanged、skip-worktree 4. 各种忽略文件的方法对比 5. 本机全局忽略(不常用) 6. 参考资料 [TOC] git忽略文件的方式 1. .gitignore 文件(整个仓库都忽略) 文件指定了 Git 追踪时应忽略的文件。在文件里配置忽略规则，同时把 .gitignore 文件加入版本管理。 文件 .gitignore 的格式规范如下： 所有空行或者以 # 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。 一个 .gitignore 文件的例子： # 忽略所有的 .a 文件 *.a # 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件 !lib.a # 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO /TODO # 忽略任何目录下名为 build 的文件夹 build/ # 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt doc/*.txt # 忽略 doc/ 目录及其所有子目录下的 .pdf 文件 doc/**/*.pdf 注意：1、GitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表， 你可以在 https://github.com/github/gitignore 找到它。2、在最简单的情况下，一个仓库可能只根目录下有一个 .gitignore 文件，它递归地应用到整个仓库中。 然而，子目录下也可以有额外的 .gitignore 文件。子目录中的 .gitignore 文件中的规则只作用于它所在的目录中。 （Linux 内核的源码库拥有 206 个 .gitignore 文件。） 参考： Git 基础 - 记录每次更新到仓库 gitignore说明 2. 本机开发忽略.git/info/exclude 单个仓库下忽略，不会同步该设置至远程仓库，只在本机起作用；配置方法是直接编辑仓库根目录下的.git/info/exclude文件，把要忽略的规则直接写入。文件内容规则跟.gitignore文件一样 3. 忽略已跟踪文件改动 assume-unchanged、skip-worktree git update-index 说明文档 对于已经提交、跟踪的文件，如果想要忽略修改的记录。可以使用assume-unchanged和skip-worktree命令。让git认为这个文件没有修改。如果想要git从新追踪这个文件，则需要使用命令从新标记。 添加本地忽略 git update-index --assume-unchanged 【文件路径】 git update-index --skip-worktree 【文件路径】 移除本地忽略(恢复跟踪) git update-index --no-assume-unchanged vue.config.js git update-index --no-skip-worktree vue.config.js 可以使用git ls-files -v查看所有文件列表，小写h开头是assume-unchanged 标记的文件,大写S是skip-worktree标记的文件。 # 查看 assume-unchanged 命令 忽略的文件 git ls-files -v | grep '^h\\ ' # 显示文件路径 git ls-files -v | grep '^h\\ ' | awk '{print $2}' # 所有被忽略的文件，取消忽略 git ls-files -v | grep '^h' | awk '{print $2}' | xargs git update-index --no-assume-unchanged # 查看 skip-worktree 命令 忽略的文件 git ls-files -v | grep '^S' # 显示文件路径 git ls-files -v | grep '^S' | awk '{print $2}' # 所有被忽略的文件，取消忽略 git ls-files -v | grep '^S' | awk '{print $2}' | xargs git update-index --no-skip-worktree 两个参数的区别： assume-unchanged：这个会关闭文件与远程仓库的跟踪，认为这个文件远程仓库是不会修改，所以每次pull都是本地的文件。 skip-worktree：这个不会关闭文件与远程仓库的跟踪，只是告诉Git不要跟踪对本地文件的更改，每次pull时会拉取最新的变化会提示冲突，但因为没有跟踪本地更改，所以需要使用--no-skip-worktree命令后再操作。 4. 各种忽略文件的方法对比 .gitignore 说明：显式地阻止提交文件。 优势：.gitignore 文件本身提交至远程仓库，全组共享忽略文件配置。 局限：如果项目已经存在远程仓库，即使被加入 .gitignore，仍然可以进行修改并提交。本地的修改会显示在 git status 结果中。 .git/info/exclude 说明：显式地阻止提交文件。 优势：exclude 文件本身不会提交至远程仓库，因此适合放一些个人定制的 「gitignore」 项目。 局限：和 .gitignore 存在同样地局限。文件若已存在远程仓库，则本地修改仍可以提交至远程仓库。本地的修改会显示在 git status 结果中。 assume-unchanged 说明：声明本地远程都不会修改这个文件。 优势：git 直接跳过这些文件的处理以提升性能。文件不会出现在 git status。 局限：不适合本地或远程需要修改的文件。本地会忽略掉之后远程文件的修改。 skip-worktree 说明：声明忽略文件的本地修改。 优势：本地可以对文件做一些个人定制。文件不会出现在 git status。 局限：拉取远程文件更新，或切换分支时有可能出现冲突，需要撤销忽略后手动解决冲突。 5. 本机全局忽略(不常用) 忽略规则由本机所有仓库共用，配置方法如下： 编辑 ~/.gitconfig 文件(excludesfile 标记)： [gui] encoding = utf-8 [core] excludesfile = ~/.gitignore 也可以通过命令行来添加配置： git config --global core.excludefile ~/.gitignore 6. 参考资料 Git 小技巧 - 忽略不想要提交的本地修改 git 忽略文件的四种方式 git本地忽略assume-unchanged和skip-worktree powered by Gitbook文件最后修改时间： 2025-01-07 16:20:39 "},"doc/git/010-git-daemon命令开启git服务器.html":{"url":"doc/git/010-git-daemon命令开启git服务器.html","title":"git daemon命令开启git服务器","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 git daemon命令开启git服务器，供局域网其他电脑拉取、上传代码 1. 创建文件夹，用于存放repository 2. 把git代码文件夹放到创建的文件夹中 3. 启动git带的服务，开启仓库 4. 局域网中其他电脑设置仓库地址 [TOC] git daemon命令开启git服务器，供局域网其他电脑拉取、上传代码 1. 创建文件夹，用于存放repository 首先在自己电脑一个地方创建文件夹，这个文件夹里面用来存放repository仓库。 比如创建的文件夹名字：gitRepository 2. 把git代码文件夹放到创建的文件夹中 复制git代码仓库到gitRepository文件夹后，终端打开这个代码仓库，执行如下命令： git config receive.denyCurrentBranch ignore 此命令解决如下报错的： remote: error: refusing to update checked out branch: refs/heads/master remote: error: By default, updating the current branch in a non-bare repository remote: is denied, because it will make the index and work tree inconsistent remote: with what you pushed, and will require 'git reset --hard' to match remote: the work tree to HEAD. remote: remote: You can set the 'receive.denyCurrentBranch' configuration variable remote: to 'ignore' or 'warn' in the remote repository to allow pushing into remote: its current branch; however, this is not recommended unless you remote: arranged to update its work tree to match what you pushed in some remote: other way. remote: remote: To squelch this message and still keep the default behaviour, set remote: 'receive.denyCurrentBranch' configuration variable to 'refuse'. To git://192.168.1.116/ttt ! [remote rejected] master -> master (branch is currently checked out) error: failed to push some refs to 'git://192.168.1.116/ttt' 3. 启动git带的服务，开启仓库 终端打开gitRepository文件夹后，运行如下命令： git daemon --reuseaddr --base-path=. --export-all --verbose --enable=receive-pack 上面的命令可以克隆仓库、推送代码。 如果希望只克隆仓库，可使用如下命令： git daemon --verbose --export-all --base-path=. 4. 局域网中其他电脑设置仓库地址 如果是下载仓库，则： git clone git://192.168.1.116/ttt git remote add origin git://192.168.1.116/ttt powered by Gitbook文件最后修改时间： 2021-03-27 22:43:36 "},"doc/git/011-使用Gitblit软件开启git服务器.html":{"url":"doc/git/011-使用Gitblit软件开启git服务器.html","title":"使用Gitblit软件开启git服务器","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 使用Gitblit软件开启git服务器，供局域网其他电脑当做git仓库服务 1. java依赖环境安装 2. Mac系统操作 2.1 下载Gitblit、配置参数 2.2 启动服务 2.3 终止服务：停止脚本即可 3. window系统操作 3.1 下载Gitblit、配置参数 3.2 启动服务 3.3 终止服务：停止脚本即可 4. 仓库的创建与管理 4.1 给仓库添加新的用户 4.2 删除一个仓库 参考资料 [TOC] 使用Gitblit软件开启git服务器，供局域网其他电脑当做git仓库服务 有的时候，代码需要在局域网中电脑间共享，并协调工作，则可以使用Gitblit软件在本地电脑搭建一个git服务器，供局域网其他电脑使用。 关于Gitblit： Gitblit是一个开放源代码的纯Java堆栈，用于管理，查看和服务Git存储库。它主要是为希望托管集中存储库的小型工作组设计的工具。 注：其实在网上还找到了使用git daemon命令启动服务的，经过尝试， 在自己的电脑中 拉取、上传代码没有问题，但是局域网中其他电脑只能拉取代码，不能上传代码。代码仓库中已经加入了：git config receive.denyCurrentBranch ignore 配置。启动服务的命令：git daemon --reuseaddr --base-path=. --export-all --verbose --enable=receive-pack 所以在网上又找到了这个软件，经过尝试这个软件是有效的。 1. java依赖环境安装 Gitblit软件需要依赖java环境，所以需要安装java依赖，如果已安装请忽略这部分，如果么有安装需要安装一下。 打开链接：https://www.oracle.com/java/technologies/javase-downloads.html 在这个页面中选一个版本，然后点击JDK Download按钮，进入下载版本，本人安装的是8的版本： https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html 在这个页面中，选择对应系统的安装包下载，Mac系统的是jdk-8u281-macosx-x64.dmg 安装成功后，在终端中输入java -version命令，如果出现版本号，则表示安装成功： $ java -version java version \"1.8.0_231\" Java(TM) SE Runtime Environment (build 1.8.0_231-b11) Java HotSpot(TM) 64-Bit Server VM (build 25.231-b11, mixed mode) 2. Mac系统操作 2.1 下载Gitblit、配置参数 官网下载地址：http://gitblit.github.io/gitblit/ 如果打开失败了，在Gitblit的源码仓库github页面中寻找：https://github.com/gitblit/gitblit 打开网站后，选择Download Gitblit GO (Linux/OSX) 点击下载，下载后，文件名：gitblit-1.9.1.tar.gz，解压后，把文件夹放到一个指定的位置，我这里放在了用户文件夹下~/。 在解压的文件夹中gitblit-1.9.1的data文件夹中，找到defaults.properties文件，使用编辑器打开，并编辑如下内容： # 大约30行，git服务器的文件夹地址，这个文件夹用来存放git仓库，绝对地址 git.repositoriesFolder = /Users/user/gitblit-1.9.1/gitRepository # 大约2069行，配置浏览器访问的端口 server.httpPort = 7070 git.repositoriesFolder的值是一个绝对路径，这个路径指向一个文件夹，用来存放git仓库。这个文件夹需要事先创建好。 文件修改完成后，保存即可。 2.2 启动服务 在gitblit-1.9.1文件夹中，有一个gitblit.sh脚本文件，终端执行此文件，就可以启动服务： ./gitblit.sh 2021-03-28 20:11:38 [INFO ] _____ _ _ _ _ _ _ | __ \\(_)| | | | | |(_)| | | | \\/ _ | |_ | |__ | | _ | |_ | | __ | || __|| '_ \\ | || || __| http://gitblit.com | |_\\ \\| || |_ | |_) || || || |_ @gitblit \\____/|_| \\__||_.__/ |_||_| \\__| 1.9.1 2021-03-28 20:11:38 [INFO ] Running on Mac OS X (10.14.6) 2021-03-28 20:11:38 [INFO ] JVM version 1.8.0_231 (Oracle Corporation) ..... 2021-03-28 20:11:41 [INFO ] Started o.e.j.w.WebAppContext@fd0e5b6{/,file:/Users/user/gitblit-1.9.1/data/temp/webapp/,AVAILABLE}{file:/Users/user/gitblit-1.9.1/gitblit.jar} 2021-03-28 20:11:41 [INFO ] Started ServerConnector@c8eb6b3{SSL-HTTP/1.1}{0.0.0.0:8443} 2021-03-28 20:11:41 [INFO ] Started ServerConnector@362a019c{HTTP/1.1}{0.0.0.0:7070} 2021-03-28 20:11:41 [INFO ] Started @2923ms 执行脚本后，终端出现上面的输出信息表示启动成功。 本地电脑通过：http://127.0.0.1:7070/ 访问，局域网中通过这台电脑的内网地址加端口访问。Mac局域网地址可通过2种方式查看局域网中IP地址： 1、系统设置 -> 网络 -> 高级 -> TCP/IP 选项里面的 IPv4 Address。 2、终端使用ifconfig命令，在输出的信息中找到en0里面的地址。 2.3 终止服务：停止脚本即可 如果要停止服务，终端停止执行脚本即可。停止后，刷新访问地址，可以看见网页无法打开了。 在终端使用control + C快捷键来终止脚本的运行： 2021-03-28 22:29:10 [INFO ] Stopped ServerConnector@362a019c{SSL-HTTP/1.1}{0.0.0.0:8443} 2021-03-28 22:29:10 [INFO ] Stopped ServerConnector@1d9bec4d{HTTP/1.1}{0.0.0.0:7070} 2021-03-28 22:29:10 [INFO ] Gitblit context destroyed by servlet container. 2021-03-28 22:29:10 [INFO ] Git Daemon stopping... 2021-03-28 22:29:10 [INFO ] Git Daemon stopped. 2021-03-28 22:29:10 [INFO ] SSH Daemon stopping... 2021-03-28 22:29:10 [INFO ] Stopped o.e.j.w.WebAppContext@fd0e5b6{/,file:/Users/user/gitblit-1.9.1/data/temp/webapp/,UNAVAILABLE}{file:/Users/suer/gitblit-1.9.1/gitblit.jar} 3. window系统操作 Window系统下搭建GIT本地服务器 3.1 下载Gitblit、配置参数 官网下载地址：http://gitblit.github.io/gitblit/ 打开网站后，选择window版本的下载，下载后，解压。然后放到一个文件夹中，比如放在E盘根目录下。 在解压的文件夹中gitblit-1.9.1的data文件夹中，找到defaults.properties文件，使用编辑器打开，并编辑如下内容： # 大约30行，git服务器的文件夹地址，这个文件夹用来存放git仓库，绝对地址 git.repositoriesFolder = E:/gitblit-1.9.1/gitRepository # 大约2069行，配置浏览器访问的端口 server.httpPort = 7070 文件修改完成后，保存即可。 3.2 启动服务 在gitblit-1.9.1文件根目录中找到gitblit.cmd文件，在终端软件中运行这个文件： ./gitblit.cmd 2021-03-28 20:11:38 [INFO ] 执行脚本后，终端出现上面的输出信息表示启动成功。 本地电脑通过：http://127.0.0.1:7070/ 访问，局域网中通过这台电脑的内网地址加端口访问。 windows系统查看ip，在终端中输入ipconfig来查看。 3.3 终止服务：停止脚本即可 在终端使用control + C快捷键来终止脚本的运行。 4. 仓库的创建与管理 仓库的创建与管理都需要通过网站来完成，在浏览器中打开服务网站。 1、打开网站后，右上角输入账号/密码：admin/admin。 2、登陆后，点击版本库菜单，进入git仓库管理页面，然后点击创建版本库，如下图： 3、在创建仓库页面，输入创建仓库的信息，然后点击创建 按钮，创建仓库： 4、创建后，就会进入到创建的仓库页面，在这个页面有一个仓库地址，复制这个地址给其他同事，然后其他同事添加这个仓库源。注意：地址一定要是局域网IP形式的地址。其他人拉取、上传git时，输入的密码就是地址中用户的密码(下面图片中URL中的密码是admin账号的密码) 5、后期查看仓库可点击版本库按钮进入仓库管理界面。 4.1 给仓库添加新的用户 1、首先添加一个gitblit用户：登陆admin账号后，点击账号 -> 点击 用户 按钮 -> 在出现的页面中点击添加用户按钮，添加新用户。 2、给git仓库添加新用户：仓库页面 -> 点击 编辑按钮 -> permissions 4.2 删除一个仓库 仓库页面 -> 编辑 -> 管理 -> 删除 参考资料 本地搭建Git服务器，两台电脑共享代码如此简单 gitblit 软件github地址 Gitblit 官网 powered by Gitbook文件最后修改时间： 2021-06-09 23:39:03 "},"doc/git/012-github推送代码方式.html":{"url":"doc/git/012-github推送代码方式.html","title":"github推送代码方式","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 github推送代码方式 1. 使用access tokens方式 2. 使用ssh方式 3. 使用ssh遇到的问题 3.1 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! 3.2 git push报错：ssh: connect to host github.com port 22: Operation timed out 参考资料 [TOC] github推送代码方式 从2021-08-13号开始，github不在支持密码认证方式来推送代码了，所以需要使用新的形式来推送代码。 ~ git push remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead. remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information. fatal: unable to access 'https://github.com/user/repo.git/': The requested URL returned error: 403 1. 使用access tokens方式 github网站登陆后， 点击右上角的用户图标 -> settings -> 选择 Developer settings -> 选择 Personal access tokens，或者打开链接https://github.com/settings/tokens 1、在access token页面，点击Generate new token按钮进入新建token页面。 2、在新建页面，输入token名字、选择过期时间、勾选权限后。点击Generate token按钮，生成一个新token。生成成功后会返回 access tokens页面。 3、在access token页面，会显示新建的token的值，复制，保存。 4、clone一个仓库、修改仓库地址： # git clone https://oauth2:[access tokens]@github.com/user/repo git clone https://oauth2:ghp_GjguOh******KZm@github.com/user/repo # 修改仓库 git remote set-url origin https://oauth2:ghp_GjguOh******ThzKZm@github.com/user/repo 2. 使用ssh方式 在 Linux/macOS 系统中，一般都会自带ssh。windows下的git终端里有ssh。 1、终端打开~/.ssh文件夹，使用ll命令查看文件，查看是否存在id_rsa和id_rsa.pub文件。如果没有这两个文件，终端使用ssh-keygen -o名称生成一个秘钥和公钥: $ ssh-keygen -o Generating public/private rsa key pair. Enter file in which to save the key (/home/schacon/.ssh/id_rsa): Created directory '/home/schacon/.ssh'. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/schacon/.ssh/id_rsa. Your public key has been saved in /home/schacon/.ssh/id_rsa.pub. The key fingerprint is: d0:82:24:8e:d7:f1:bb:9b:33:53:96:93:49:da:9b:e3 schacon@mylaptop.local 如果上面命令报错，尝试使用ssh-keygen -t rsa -C 'user@gmail.com' 2、打开生成的秘钥所在文件夹，终端使用cat id_rsa.pub命令查看公钥内容，复制显示的内容： ~ cat id_rsa.pub ssh-rsa AAAAB3..省略内容..utlook.com 3、github网站登陆后， 点击右上角的用户图标 -> settings -> 选择 SSH and GPG keys，点击New SSH key按钮新建一个，在新建页面中，输入title和之前复制的公钥内容，然后点击Add SSH key按钮就好了。 4、使用终端使用如下命令测试是否配置成功： ~ ssh -T git@github.com The authenticity of host 'github.com (13.250.177.223)' can't be established. RSA key fingerprint is SHA256:nT*******5SY8. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added 'github.com,13.250.177.223' (RSA) to the list of known hosts. # 出现如下语句，说明设置成功了 Hi user! You've successfully authenticated, but GitHub does not provide shell access. 如果测试失败了，等一会在测试，如果还是失败，查看终端是否能访问github(代理)，然后在测试 4、ssh设置好后，就可以使用ssh方式clone仓库或者修改已存在的仓库使用ssh方式： ~ git clone git@github.com:user/my_blog.git # 修改已存在的仓库使用ssh git remote set-url origin git@github.com:user/my_blog.git 3. 使用ssh遇到的问题 3.1 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! 当使用ssh方式推送代码到github时候，终端报如下错误： @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! Someone could be eavesdropping on you right now (man-in-the-middle attack)! It is also possible that a host key has just been changed. The fingerprint for the RSA key sent by the remote host is SHA256:uNiVztksCsDhcc0u9e8BujQXVUpKZIDTMczCvj3tD2s. Please contact your system administrator. Add correct host key in /Users/dragon/.ssh/known_hosts to get rid of this message. Offending RSA key in /Users/dragon/.ssh/known_hosts:6 RSA host key for github.com has changed and you have requested strict checking. Host key verification failed. fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. 原因分析： It is also possible that a host key has just been changed. 我之前对ssh服务器重装了系统，导致所有与原系统建立过ssh连接的系统都无法再建立连接，因为在于原系统建立首次连接时，双方相互记录了对方的公钥（ssh基于非对称密钥技术），在ssh服务主机重装系统后，公钥改变了，任以旧版本公钥的主机自然是无法与新系统连接的。 解决方案： 打开~/.ssh/known_hosts, 找到github部分，删除这行，保存。然后后再次建立新的连接，即可获得新的公钥。 如果不确定文件里面内容是哪个，可以在备份这个文件后，直接删除，然后从新建立链接即可。 3.2 git push报错：ssh: connect to host github.com port 22: Operation timed out 当往github网站推送代码的时候，报如下错误： ssh: connect to host github.com port 22: Operation timed out fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. 解决办法： 打开~/.ssh/config文件，在文件下面追加如下代码： # 2024-01-18解决github推送报错问题 Host github.com Hostname ssh.github.com Port 443 保存文件后，推送项目就不会报错了 参考资料 Git - 生成 SSH 公钥 powered by Gitbook文件最后修改时间： 2024-01-18 16:33:29 "},"doc/mac/001-Mac下常用的软件.html":{"url":"doc/mac/001-Mac下常用的软件.html","title":"Mac下常用的软件","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. Homebrew 2. Homebrew Cask 2.1 安装cask提示：Error: Unknown command: cask 3. 替换系统默认Shell — Oh My ZSH! 4. 窗口管理软件 – SizeUp 5. 快速切换和打开应用程序 — Manico 6. FileZilla 7. keyCue 8. CheatSheet 9. IINA视频播放器 10. Office 2016 for Mac 11. install gadmin3 12. caffeine 防止mac电脑休眠软件 13. 好用的截屏工具-Snip 14. go2shell 快速进入Shell 15. 增强资源管理器 — XtraFinder 16. 替换系统默认终端 — iTerm 2 17. 有道词典Mac版本 mac 右上角菜单栏时间显示点击出现日历 18. Bandwidth+ Mac上免费流量监测软件 19. MagicanLite 流量监控，CPU,内存使用 温度监控 20. CHM View .chm格式文件阅读器 21. Foxmail 邮件客户端 22. lantern 蓝灯翻墙软件 23. paintbrush 类似Windows画图板的软件 Paintbrush version:2.1.1 类似于Windows下面的画板 24. fHash 计算 MD5、SHA1文件校验软件 25. Kill Mouse Accel 关闭mac下鼠标加速 26. MagicPrefs 苹果鼠标的多手势辅助软件 27. Hostbuddy修改host地址的软件 28. FOLX 5Downloader for Mac 29. Charles 抓包工具 30. duet 扩展屏软件 31. sublime text 3 32. expect 可以与终端交互的脚本语言 33. 文件恢复软件TestDisk 34. Mac下 罗技G602无线鼠标驱动下载 35. 解压工具 7z : brew install p7zip 36. typora: Markdown编辑器 37. PS6 安装 38. gif截图工具：Gifox 39. Mac 下载软件 40. Itsycal: 工具栏上显示日历 41 工具栏流量监视工具 42 在Mac下启动Tomcat 43 在文件夹里面鼠标右键新建文件 目录 [TOC] 1. Homebrew Mac下包管理工具，官方称之为 The missing package manager for OS X 。 官网：https://brew.sh/index.html 安装步骤：先打开 Terminal 应用，输入： ~ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 有了 brew 以后，要下载工具，比如 MySQL、Gradle、Maven、Node.js 等工具，就不需要去网上下载了，只要一行命令就能搞定： ~ brew install name PS：安装 brew 的时候会自动下载和安装 Apple 的 Command Line Tools。 卸载Homebrew： ~ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\" 安装后，命令中使用brew -v命令出现版本号说明安装成功： ~ brew -v Homebrew 3.0.10 Homebrew/homebrew-core (git revision f2f80f72d5; last commit 2021-04-04) Homebrew/homebrew-cask (git revision 9169a5fc30; last commit 2021-04-04) 注意： Homebrew 3.0.10 版本 已经不需要再安装 Cask了，可以直接安装软件了。 2. Homebrew Cask 注意：Homebrew 3.0.10 版本 已经不需要再安装 Cask了，可以直接安装软件了。 brew cask 允许你使用命令行安装 OS X 应用。比如你可以这样安装 Chrome： brew cask install google-chrome 。还有 Evernote、Skype、Sublime Text、VirtualBox 等都可以用 brew cask 安装。brew-cask 是社区驱动的，如果你发现 brew cask 上的应用不是最新版本，或者缺少你某个应用，你可以自己提交 pull request。应用也可以通过 App Store 安装，而且有些应用只能通过 App Store 安装，比如 Xcode 等一些 Apple 的应用。App Store 没有对应的命令行工具，还需要 Apple ID。倒是更新起来很方便。几乎所有常用的应用都可以通过 brew cask 安装，而且是从应用的官网上下载，所以你要安装新的应用时，建议用 brew cask 安装。如果你不知道应用在 brew cask 中的 ID，可以先用 brew cask search 命令搜索。 # 安装cask ~ brew install caskroom/cask/brew-cask # 如果上面命令失败了，则用下面的命令安装：http://www.cnblogs.com/dayou123123/p/6867936.html ~ brew install brew-cask-completion # 搜索软件 ~ brew cask search chrome # 安装软件 ~ brew cask install chrome # 卸载软件 ~ brew cask uninstall chrome 2.1 安装cask提示：Error: Unknown command: cask homebrew 从 2.5.11 后，cask 就取消了，可以直接通过brew安装了： ~ brew search iterm2 ==> Casks iterm2 ✔ homebrew/cask-versions/iterm2-legacy homebrew/cask-versions/iterm2-beta homebrew/cask-versions/iterm2-nightly ~ brew install iterm2 3. 替换系统默认Shell — Oh My ZSH! Bash作为大多数系统默认安装的Shell，大家都多少有所接触，Zsh和Bash类似都是一个Shell，但是Zsh更注重用户体验和与人的交互，OS X默认也安装好了Zsh，然而你想自己从头开始配置一个顺手的Zsh是比较浪费时间的，有人已经帮我们配置好了，这个流行的Zsh配置叫—Oh My ZSH!，直观的效果如下图所示，代码开源在github。 # Mac OS X默认已经安装好了Zsh，你可以打开终端，输入zsh --version来确认 ~ zsh --version # 切换默认Shell为Zsh, 成功后需要重启终端 ~ chsh -s /bin/zsh # 切换Zsh为Shell， 成功后需要重启终端 ~ chsh -s /bin/bash # 查看zsh配置的环境变量： ~ cat ~/.zshrc # 此时还没有酷炫的效果，需要安装插件 # 安装Oh My ZSH! ~ sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" # 卸载Oh My ZSH，注意：卸载后，.zshrc文件还在 ~ uninstall_oh_my_zsh https://www.jianshu.com/p/d194d29e488c 遇到的问题解决： 在安装好后，打开终端出现 执行.sh脚本，异常/bin/sh^M: bad interpreter: No such file or directory 注意，提示中出现了^m符号，这是不同系统编码格式引起的，^M在Linux/Unix中是非常常见的，也就是我们在Win中见过的\\r回车符号，可使用vim编辑器打开脚本文件，在命令行模式下，输入下面命令来删除^M: :%s/\\r//g :wq 这句命令的意思是：％指匹配整个文件，s是指置换的意思，\\r代表^M（或者可以使用Ctrl+V Ctrl +M来输入^M，即也可以使用命令:/s^M$//g来达到同样的目的），M后面的$代表匹配行尾的内容，最后的g表示每行中匹配的内容都要进行替换 Unix系统里，每行结尾只有“”，即\"\\n\"；Windows系统里面，每行结尾是“”，即“\\r\\n”；Mac系统里，每行结尾是“”，即\"\\r\"；。一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。 4. 窗口管理软件 – SizeUp SizeUp快速移动软件窗口在屏幕之间，可以在一个屏幕中上下左右移动，也可以在2个显示器之间移动，该软件可以永久免费试用。 sizeup网站介绍： http://www.irradiatedsoftware.com/sizeup/ SizeUp需要你的授权才能控制窗口， 打开‘系统与偏好设置’ -> ‘安全与隐私’ -> '隐私' -> '辅助功能'，把sizeup前面打上对号。 # 使用brew cask安装 ~ brew cask install sizeup 5. 快速切换和打开应用程序 — Manico MacBook系统默认设置了一个快捷键来显示当前运行中的应用程序，同时按下tab + command.Manico 是一个为 OS X 设计的快速的 App 启动和切换工具。 manico网站：https://manico.im/ # 使用brew cask安装,也可以去网站上下载后安装 ~ brew cask install manico 6. FileZilla 这个软件可以连接远程电脑并且可以上传下载文件，并且在线编辑文件。这个软件在Windows，Linux，Mac OS 都有客户端，下载地址：https://filezilla-project.org/download.php?type=client 7. keyCue 安装后，只要按住cmd键，就可以显示当前所有可用快捷键，放开后恢复，非常方便。效率生活必备。http://www.yxdown.com/soft/247108.html注册码： KC-FMO-032015-S-426-631227-819538-50 8. CheatSheet CheatSheet 能够显示当前程序的快捷键列表，默认的快捷键是长按 ⌘ 。安装： ~ brew cask install cheatsheet ​ 9. IINA视频播放器 https://lhc70000.github.io/iina/https://github.com/lhc70000/iina终端： brew cask install iina ​ 10. Office 2016 for Mac http://bbs.feng.com/read-htm-tid-10868252.html安装完后不要打开office软件，打开破解补丁.dmg，里面有把蓝色的钥匙，双击，出现一把黑色的锁，点击，输入系统密码，OK~搞定Office 2016 for Mac破解版（含破解补丁）百度盘下载链接: https://pan.baidu.com/s/1c1HIrks 密码: r9khhttp://jingyan.baidu.com/article/ce09321b7478072bff858f03.htmlpc6下载：http://www.pc6.com/mac/137931.html 11. install gadmin3 # 终端，已经安装了brew ，cask ~ brew search pgadmin3 Caskroom/versions/pgadmin3 ~ brew install Caskroom/versions/pgadmin3 12. caffeine 防止mac电脑休眠软件 #终端，已经安装了brew ，cask ~ brew search caffeine Caskroom/cask/caffeine ~ brew cask install caffeine # 还可以网站下载后安装：http://lightheadsw.com/caffeine/ 13. 好用的截屏工具-Snip 使用过QQ的朋友肯定用过上面的自带截图功能,非常好用, 支持添加圈,点,箭头甚至文字, 只要打开QQ, 任何时候都可以通过Ctrl+Command+a来截图, 但是本人平时不太常使用QQ, 截屏功能又非常常用，怎么办呢? 腾讯很贴心地把QQ里的截图功能完整地拆了出来, 成了一个新的App–Snip. ~ brew search snip esniper Caskroom/cask/snip Caskroom/cask/snippets Caskroom/cask/snippet-edit ~ brew cask install snip 14. go2shell 快速进入Shell go2shell是一个对开发者来说非常有用的app, 使用它可以在Finder里快速进入shell环境. 在 App Store中搜索go2shell，点击安装 安装go2shell后，打开finder的application文件夹，找到go2shell 按住command，用鼠标将go2shell拖到finder的toolbar上 在打开的terminal中，输入： open -a Go2Shell --args config命令来修改go2shell的配置安装好以后, 打开Finder, 点击Finder上的图标即可进入terminal: ~ brew search go2shell Caskroom/cask/go2shell # 安装 ~ brew cask install go2shell # 配置文件 ~ open -a Go2Shell --args config # 卸载，仅适用于用cask命令安装的 ~ brew cask uninstall go2shell 15. 增强资源管理器 — XtraFinder MacBook自带的资源管理器(Finder)已经可以满足一般的需要，但是当你有大量文件维护操作后，你就需要一个更强大的Finder。XtraFinder完全集成到Finder里面，你根本感觉不出它是一个第三方的应用程序，同时还提供很多增强特性，比如： 像浏览器那样的标签页(Tab)支持双操作面板(Panel)增强的全局快捷键，例如新建文件(New File)等多彩的侧边栏图标快速在当前文件夹打开终端快速在当前文件夹新建文件 ~ brew search XtraFinder Caskroom/cask/xtrafinder ~ brew cask install xtrafinder ~ brew cask uninstall xtrafinder 16. 替换系统默认终端 — iTerm 2 如果你经常使用终端，那么推荐你使用iTerm 2来替代系统自带的终端。关于iTerm 2的特性，请看这里。iterm2的介绍：http://www.cnblogs.com/theswiftworld/p/4679010.htmlhttps://www.iterm2.com/features.html 设置 F12 启动iterm2： 1.打开System Preferences，选择Keyboard，切换到Shortcuts这个Tab下，点击Mission Control，取消对应F12的快捷键。2.打开iTerm的Preferences...， 在ProfilesTab里面，点击下面的[+]添加一个新的profile，为什么要新建一个profile？答案是为了定制将来弹出的终端样式和大小等等参数。新的profile假设命名为guake，(注：guake这个名称是为了向Linux下的Guake终端致敬)，你可以自己任意起个名称，下面会用到。3.再切换到WindowTab下，将Style，Screen和Space这3个值设置一下。4.再切换到KeysTab下，设置如下图所示的HotkeyF12。5.现在你按下F12，就立即得到一个占满全屏的黑色命令行终端，再按一下F12隐藏终端，非常的方便。6.iterm2终端透明度设置 profile -> 点中profile名字 -> window -> transparency ~ brew cask search iterm2 # 安装 iterm2 ~ brew cask install iterm2 ​ 17. 有道词典Mac版本 官网下载：http://cidian.youdao.com/index-mac.html取词方便，打开后，可使用快捷键唤起界面进行查词(alt + cmd + X) mac 右上角菜单栏时间显示点击出现日历 https://shauninman.com/archive/2016/10/20/day_o_2_mac_menu_bar_clock 18. Bandwidth+ Mac上免费流量监测软件 款可以实时查看网络流量的小软件，支持对 Mac 连接的无线 Wi-Fi 以及移动热点上下行流量进行实时监控记载，而且还能对网络流量进行定额记录，就在 Menubar 下可以看到流量的消耗，并且能够以天为单位将每个网络流量记录导出称 csv 文件。 在 App Store 中搜索 Bandwidth+, 点击安装。 19. MagicanLite 流量监控，CPU,内存使用 温度监控 http://www.magicansoft.com.cn/这款软件免费，可以监控流量， cup的使用率温度，GPU温度， 内存的使用率等。 在 App Store 中搜索 MagicanLite, 点击安装。 20. CHM View .chm格式文件阅读器 免费的.chm文件阅读器。 在 App Store 中搜索 CHM View, 点击安装。 21. Foxmail 邮件客户端 http://www.foxmail.com/mac/ 22. lantern 蓝灯翻墙软件 https://github.com/getlantern/forumhttps://www.getlantern.org/点击下载安装就好， 每月免费500MB流量。 23. paintbrush 类似Windows画图板的软件 http://mac.brothersoft.com/paintbrush-download.htmlhttp://mac.brothersoft.com/paintbrush.htmlPaintbrush的按钮布局和功能与PC电脑Windows自带的画图都很接近，基本不用介绍了。注意那个地雷按钮！他的作用是清除整个画面---没错，炸成白板---我已经中招了（囧），还好后悔操作的快捷键和系统默认的“后退”键一样：“CMD+Z”。安装后，右键的打开方式菜单里会有用paintbrush打开这一项。 Paintbrush version:2.1.1 类似于Windows下面的画板 Paintbrush-2.1.1 http://mac.brothersoft.com/paintbrush-download.html 链接: https://pan.baidu.com/s/1miObeac 密码: qikg 24. fHash 计算 MD5、SHA1文件校验软件 https://itunes.apple.com/cn/app/fhash/id1055555711?l=en&mt=12app Store 软件中搜索fHash 安装即可。 25. Kill Mouse Accel 关闭mac下鼠标加速 用于罗技等无线鼠标卡顿解决的小插件。 移的越快，鼠标移动距离就越大，这就是鼠标加速度。http://bbs.feng.com/read-htm-tid-445826.html 26. MagicPrefs 苹果鼠标的多手势辅助软件 下载地址： http://magicprefs.com/ 注意：这个软件会是系统的快速移动鼠标以定位鼠标位置 27. Hostbuddy修改host地址的软件 官网地址 Hostbuddy 是Mac里最简单的方法来管理和更新的 /etc/hosts 文件。添加新条目，打开和关闭现有的通过一次单击。这是完美的临时和生产服务器间进行切换，或只是为了测试你的新网站在上线之前。 快速而无需使用命令行添加主机条目 打开/关闭主机组通过一次单击 不会覆盖现有的 /etc/hosts 文件 与 VirtualHostX 兼容 自动刷新 DNS 缓存 28. FOLX 5Downloader for Mac https://mac.eltima.com/download-manager.html mac 下下载工具，有免费版。 29. Charles 抓包工具 Charles 是在 Mac 下常用的网络封包截取工具，在做 移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。 Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。 除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。 使用注意事项： 如果没有抓取到数据，尝试关闭代理或浏览器的代理。 选择菜单中的 “Proxy” –> “Mac OS X Proxy” 来将 Charles 设置成系统代理 “Proxy” –> “Proxy Settings” -> \"macOS\" 要把 里面选项都勾选上 Enable macOS proxy ​ Use HTTP proxy Enable macOS proxy on launch 如果不勾选上面选项，则不能抓取到包 使用教程： https://www.cnblogs.com/mawenqiangios/p/8270238.html 30. duet 扩展屏软件 https://www.duetdisplay.com/ Duet Display 就可以把 iPad 或 iPhone 变成你电脑的第二台显示器！相对于通过「网络远程控制」实现屏幕扩展的同类 APP，Duet 通过 USB 数据线传输画面，无论清晰度、稳定性还是流畅度都完胜。即使开启 Retina 视网膜分辨率，仍能保持 60 FPS 低延迟不卡顿，实际体验相当好 DuetDisplay 电脑端支持 macOS 和 Windows，也就是说，无论是 PC 台式机、笔记本还是 Macbook、iMac 等设备通通都能用它来扩展桌面！而且不仅仅是显示内容，Duet 还可以让这块 “扩展屏幕” 增加「触摸和手势操作」、支持 Apple Pencil 数字笔、以及增加 TouchBar 等特性的支持。 31. sublime text 3 http://www.sublimetext.com/官网下载后直接安装 32. expect 可以与终端交互的脚本语言 ~ brew search expect ~ brew install expect 33. 文件恢复软件TestDisk http://www.cgsecurity.org/wiki/下载_TestDisk下载 Mac OS X Intel 的版本。 解压软件 终端进入软件目录， 运行./photorec 进入界面后上下键 选择 磁盘， 左右键选择下方的 search 按钮进行搜索 选择磁盘系统的类型 选择恢复文件存储的目录。 按C键开始恢复。 34. Mac下 罗技G602无线鼠标驱动下载 http://support.logitech.com.cn/zh_cn/product/g602-wireless-gaming-mouse#imagegallery http://support.logitech.com.cn/zh_cn/product/g602-wireless-gaming-mouse/downloads 35. 解压工具 7z : brew install p7zip ~ brew search 7z ~ brew install p7zip Downloading https://homebrew.bintray.com/bottles/p7zip-16.02.high_sierra.bot ######################################################################## 100.0% ==> Pouring p7zip-16.02.high_sierra.bottle.tar.gz 🍺 /usr/local/Cellar/p7zip/16.02: 103 files, 4.7MB # 解压命令 解压 演讲稿.7z 7z e 演讲稿.7z 36. typora: Markdown编辑器 https://www.typora.io/这个 Mac、Windows 都有，可以显示编辑软件，下载相应版本后安装就可以了。 这个编辑器的好处是可以显示 [TOC]目录结构在左边，方便预览查看。详细介绍： https://www.jianshu.com/p/5256ecc06eec 注意下载安装更新科学上网速度快，否则下载速度很慢。 37. PS6 安装 软件下载： https://pan.baidu.com/s/1boZWCzHhttps://pan.baidu.com/s/1boZWCzH 安装 断开网络。 双击安装程序，选择试用(try)，然后点击安装。 在应用程序文件夹里面找到PS6，右键显示包内容(show package content), 然后找到contents/framework文件夹，把amtlib.framework文件拷贝到里面，OK。 参考链接： https://www.jianshu.com/p/097353202b66 38. gif截图工具：Gifox 下载地址：https://gifox.io/， 也可以在 App Store中搜索Gifox来下载。 该软件是收费的，不过有免费版的，经过使用，发现免费版最多录制10秒，不知道是不是由于是免费的原因。 还可以使用QQ的截图，里面有录屏然后转成gif就可以。 39. Mac 下载软件 https://www.zhihu.com/question/19552868 下载工具： FOLX 5：https://mac.eltima.com/download-manager.html 40. Itsycal: 工具栏上显示日历 Mac 的工具栏上的时间，真的只是时间，如果想看日历，只能打开日历应用，很不方便。 Itsycal 可以将日历放到工具栏上，并且支持展示日历时间。 当然也以通过 Itsycal 快速的添加你的日程，而不需要再打开你的日历。 下载地址：https://www.mowglii.com/itsycal/ 下载后， 解压，把软件拖到Applications文件夹中 41 工具栏流量监视工具 https://github.com/yujitach/MenuMeters 42 在Mac下启动Tomcat 将加压好的 Tomcat 安装包放在某个路径下，重命名为 Tomcat 。 终端 进到 Tomcat 的 bin 目录下 输入 sudo chmod 755 *.sh 设置权限 输入 sudo sh startup.sh 启动 Tomcat。在浏览器中输入localhost:8080 看到 Tomcat 主页即为成功。 输入 sudo sh shutdown.sh 关闭 Tomcat。 参考资料：https://blog.csdn.net/u011886447/article/details/69361711 43 在文件夹里面鼠标右键新建文件 mac系统自身不支持在文件夹中鼠标右键创建文件，需要安装第三方插件： 1、New File Menu Free：在 App Store 上搜索，这个是免费版的，只能创建txt文件 2、GMRightMouse：在 App Store 上搜索。 powered by Gitbook文件最后修改时间： 2022-02-28 11:33:17 "},"doc/mac/002-Mac系统操作习惯设置.html":{"url":"doc/mac/002-Mac系统操作习惯设置.html","title":"Mac系统操作习惯设置","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Mac系统操作习惯设置 0. 关于操作系统升级 0.1 我想升级到某个旧版本怎么办？ 0.2 升级完后悔了怎么办？ 1. finder与文件相关操作 1.1 finder 进入特定目录 1.2 finder中标题栏显示全路径 1.3 .DS_Store文件(禁止自动生成、删除、取消禁止生成) 1.4 把应用程序图标放在finder上 1.5 一次性修改finder文件夹显示选项 1.6. 修改Mac文件默认打开方式 1.7 finder中显示与隐藏文件 2. Mac系统相关 2.1 鼠标、触模板相关 2.1.1 鼠标滚轮跟windos统一 2.1.2 触摸板设置三指选则文本 2.2 mac关闭开机声音 2.4 右上角顶级菜单中图标管理 2.4.1. 图标顺序管理 2.4.2. 删除无用的图标 2.5 隐藏docker中正在运行的应用图标 2.6 Dashboard 2.9 读写mac格式的移动硬盘（去掉写入权限提示） 2.10 系统桌面背景图片位置 2.11 去掉屏幕右上角的用户名 2.12 英文输入时，单词首字母自动大写关闭 2.13 设置外接显示器为主屏幕 2.14 查看已连接的WIFI密码 2.15 关闭dock中 系统更新提示小红点 2.16 调整Mac桌面图标大小 2.17 软件无法打开：因为它可能损坏或不完整 2.18 软件打不开：来自身份不明开发者 2.19 windows系统的TXT文件在mac中打开显示乱码 2.20 将搜狗输入法设置为默认输入法 3. Mac下一些软件配置 3.1 app Store相关 3.1.1 关闭自动更新app Store 3.1.2 删除正在从app store下载的应用程序 3.2 应用程序安装目录 3.3 创建 APP/文件夹 桌面快捷方式 3.4 允许第三方软件运行:开启任何来源选项 3.5 ShadowSocks 自定义代理规则 3.6 ssh远程连接mac 3.7 完全删除garageband音乐创作软件 3.8 使用Mail绑定outlook邮箱 3.8.1 Mail设置邮件到一个文件夹中 3.9 腾讯视频.app应用下载的视频存放位置 4. Mac下的 tree 命令 终端展示你的目录树结构 5. Mac 了解应用安装后占用的磁盘空间 5.1 App最喜欢的几个目录 5.2 ~/Library/Application Support 5.3 ~/Library/Preferences 5.4 ~/Library/Containers 5.5 ~/Library/LaunchAgents 6. Mac 清理磁盘空间 [TOC] Mac系统操作习惯设置 OS X EI Capitan Version 10.11.6 (15G31) 0. 关于操作系统升级 注意： intel的机器无论是2020还是2019还是再往前 请停留在Catalina。 升级系统版本的时候，需要使用时间机器老保存一下当前系统，如果新系统有问题，可以用时间机器来恢复旧版本。 macOS 每一代系统的“变化”程度不一样。即使是同一个版本的 macOS 系统，在不同年代、不同型号的 Mac 上，运行表现也会有差异。甚至同一型号的 Mac，因为不同的硬件配置也可能会导致升级后体验有差异。 如果你的 Mac 是 M1 系列芯片，可以放心升级到当前最新的 macOS Monterey 版本。 如果是 Intel 处理器的 Mac，就要看情况了。 我在网上看到不少 2019 款 MacBook Pro，升级了 Monterey 后甚至感觉比 Big Sur 更流畅一些，续航也略有提升。但是也有不少很老的 Mac，升级后既卡顿，电池又变得不耐用。 我今天还特地把家里那台 2016 年 13 英寸低配的 MacBook Pro 从 Catalina 升级到最新的 Monterey 12.2.1。操作了一会发现居然运行起来还挺流畅，甚至比之前用 Catalina 还更顺畅一些。这让我感觉还挺意外的。记得去年我有一次把这台 Mac 升级到刚发布的 Big Sur，就卡得不行，后来又降回 Catalina。 小版本推荐升级，大版本谨慎升级：小版本更新一般都是针对当前系统版本的优化和问题、漏洞修复。比如今天早上的 12.2.1 小更新就解决了一个导致连接到 Mac 的蓝牙设备消耗过多电池的错误，Monterey 用户还没更新的赶快去。所以一般都推荐及时更新小版本。比如从 12.2.0 更新到 12.2.1。 大的系统升级，比如从 Big Sur 升级到 Monterey，或者从 Mojave 升级到 Catalina，就需要谨慎。如果你又想尝试新系统带来的新功能，又不想冒险。要么在升级前用外置存储做一次彻底的时间机器备份。要么等系统版本经过几次小更新比较稳定后再考虑升级，比如你想体验 Monterey，可以等更新到 Monterey 12.2.x 以上的时候再考虑升级。 0.1 我想升级到某个旧版本怎么办？ 用 Safari 浏览器打开以下旧版系统对应链接，然后会自动在 App Store 中打开旧版安装器。下载安装器后，安装器会自动打开。 macOS Ventura(13.6.1)：https://apps.apple.com/cn/app/macos-ventura/id1638787999?mt=12 macos monterey (12.7.1)：https://apps.apple.com/cn/app/macos-monterey/id1576738294?mt=12 下载安装 macOS Big Sur：https://apps.apple.com/cn/app/macos-big-sur/id1526878132?mt=12 下载安装 macOS Catalina：https://apps.apple.com/cn/app/macos-catalina/id1466841314?mt=12 下载安装 macOS Mojave：https://apps.apple.com/cn/app/macos-mojave/id1398502828?mt=12 下载安装 macOS High Sierra：https://apps.apple.com/cn/app/macos-high-sierra/id1246284741?mt=12 Mac 可以降到的最低系统版本是新机出厂预装的那个版本。比如我的 iMac M1 购买时预装版本是 Big Sur，现在用的是最新的 Monterey。如果我想降级，也只能降到 Big Sur 的版本，更老的版本是无法安装的。 0.2 升级完后悔了怎么办？ macOS 系统降级永远比升级麻烦得多，通常需要抹盘重装。所以大版本升级建议一定做好重要数据的备份。最好做「时间机器」备份。 1. finder与文件相关操作 1.1 finder 进入特定目录 finder左上角的菜单中 finder -> 前往(go) -> 前往文件夹(go to folder)，输入路径即可： 1.2 finder中标题栏显示全路径 打开终端输入如下命令： # finder中标题栏显示全路径 ~ defaults write com.apple.finder _FXShowPosixPathInTitle -bool TRUE;killall Finder # finder中标题栏只显示文件夹名字 ~ defaults delete com.apple.finder _FXShowPosixPathInTitle;killall Finder 1.3 .DS_Store文件(禁止自动生成、删除、取消禁止生成) .DS_Store是Mac OS保存文件夹的自定义属性的隐藏文件，如文件的图标位置或背景色，相当于Windows的desktop.ini。 3.1. 禁止 .DS_Store 生成 打开 “终端” ，复制黏贴下面的命令，回车执行，重启Mac即可生效。 defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE 3.2. 恢复 .DS_Store 生成 终端输入下面命令： defaults delete com.apple.desktopservices DSDontWriteNetworkStores 3.3. 删除所有的 .DS_Store 文件 在terminal中输入以下代码，可以删除所有.DS_Store文件 sudo find / -name \".DS_Store\" -depth -exec rm {} \\; # 命令在10.14.2系统中，已经失效 sudo find / -name .DS_Store -exec rm {} + 3.4. 上面命令不管用，安装 App 解决 .DS_Store 污染问题 安装 Asepsis (https://asepsis.binaryage.com/) 可以解决这个问题，不过该 App 目前不开发了。ASEPSIS 会把所有的.DS_Store重定向到 /usr/local/.dscage 内。 1.4 把应用程序图标放在finder上 按住 cmd键，鼠标拖动应用即可。 1.5 一次性修改finder文件夹显示选项 由于修改了Mac屏幕的分辨率，在打开finder查看文件的时候发现文件图标和文件名大小不合适了，需要修改。 在当前finder文件夹下，右上角的View -> show view options, 或者直接使用快捷键cmd + J来直接打开，在打开的界面中： Icon Size: 此选项是设置文件图标的大小，可选择适应的大小 Text Size:此选项是设置文件名字体大小的，选择对应的大小 Use as Defaults: （可能是）如果勾选了此选项则字文件夹及子文件夹内容都会应用此选项 此设置只在当前目录设置有效。如果想要所有目录都生效，则使用如下方式： 1、打开finder，连续使用快捷键Command + ↑方向箭头上，直到目录不在动为止，把目录切换到顶级目录(磁盘图标)，不要选择任何文件。 2、按Command + J或者点击工具栏的小齿轮，打开“查看显示选项(show view options)”； 3、在显示选项内调整好自己想要的效果，图标大小、文件名字体大小等。 4、打开终端，输入如下命令： sudo find / -name .DS_Store -exec rm {} + 注意此命令在MacOS 10.14.2系统版本中，已经失效。可试一下如下命令： sudo find / -name \".DS_Store\" -depth -exec rm {} \\; 此命令目的是删除所有文件夹下的.DS_Store文件，此文件会记录文件夹选项。 5、等待第 4 步完成后，点击屏幕左上角的小苹果图标选择“强制退出(Force Quit)”； 6、在强制退出应用程序窗口中选择“Finder”后点击“重新开启”即可完成。 参考资料：https://bbs.feng.com/mobile-news-read-0-688186.html 1.6. 修改Mac文件默认打开方式 参考：https://www.cnblogs.com/junstudys/p/12198092.html 右键->显示简介->打开方式->全部更改 1、在需要操作的文件上右键，选择Get Info(显示简介) 2、在出现的弹窗中，找到Open with(打开方式)选项，选择需要设置默认的程序，然后点击Change All(全部更改)，然后就修改成功了。 1.7 finder中显示与隐藏文件 1、使用快捷键：shift + command + . 2、使用终端命令： ~ defaults write com.apple.finder AppleShowAllFiles Yes && killall Finder # 显示隐藏文件 ~ defaults write com.apple.finder AppleShowAllFiles No && killall Finder # 不显示隐藏文件 2. Mac系统相关 2.1 鼠标、触模板相关 2.1.1 鼠标滚轮跟windos统一 首先打开左上角全局菜单中的“偏好设置” 然后在偏好设置中找到“鼠标”点击进去 最后在“鼠标”设置中把“滚动方向：自然”前面的勾去掉就和windows中一样了。 2.1.2 触摸板设置三指选则文本 系统偏好设置-->辅助功能--->鼠标与触控板--->触控板选项 启用拖移 三指拖移 System Preferences -> Accessibility -> Mouse & Trackpad -> Trackpad Options -> 勾选 Enable Dragging -> 选择 three finger drag 注意：勾选此选项后，使用三指在触摸板上滑触发的Mission Control 就自动改成使用四指触发 2.2 mac关闭开机声音 # 打开终端 # 关闭声音 $ sudo nvram SystemAudioVolume=%80 # 如果想要恢复正常的开机生硬，只要在终端中再次输入如下命令即可： $ sudo nvram -d SystemAudioVolume 2.4 右上角顶级菜单中图标管理 2.4.1. 图标顺序管理 按下Command然后用鼠标拖动图标即可调整顺序。 2.4.2. 删除无用的图标 搜狗输入法中有一个语音输入，导致在右上角有个 话筒的图标， 可在 搜狗输入法设置里把语音输入取消即可。 2.5 隐藏docker中正在运行的应用图标 终端下进入该应用的目录中，使用sudo vi命令打开Info.plist # 进入APP目录 cd /Applications/ # 查看目录下安装的软件 ls # 假设你的软件名字是 YouAppName cd YouAppName/Contents # 编辑配置文件 vim Info.plist 进入编辑器之后，找到的部分节点，插入下面红框内的内容 : LSUIElement 保存之后，退出相关程序，再次打开，DOCK栏上就没有这个软件的图标了。 参考链接:http://blog.csdn.net/fungleo/article/details/52262315 2.6 Dashboard 偏好设置 --> Mission Control --> Dashboard不是所有 Mac 上的工作都需要使用大型应用程式，有些简单的工作不妨让 [tiger] 上的新功能 Dashboard 来为您完成。只要按下一个键，半透明的 Dashboard 就会浮现在电脑桌面上，供您快速取用多种有趣又实用的迷你应用程式 widget。需要加减乘除吗？交给“计算机”widget 吧！想知道心爱的人所坐的班机飞到哪了吗？请看看 Flight Tracker widget。办公室没有窗户让您一窥外头的情况吗？打开 Weather widget 就知道现在窗外是什么天气。http://jingyan.baidu.com/article/066074d6910570c3c21cb0d9.html 2.9 读写mac格式的移动硬盘（去掉写入权限提示） 右键移动硬盘，最下面的 共享与权限，点开，把锁打开，然后把当前的用户添加上就可以写入的时候不用输入管理员密码了。 2.10 系统桌面背景图片位置 /Library/Desktop Pictures/ 2.11 去掉屏幕右上角的用户名 系统偏好设置－－用户与群组－－左侧菜单栏选择登陆选项－－右侧“将快速用户切换菜单显示为...”左边的勾去掉就行了 system preferences -> user and groups -> login options，有一条show fast user switching menu as，有三个选项可以设置。不想要勾掉就好了 2.12 英文输入时，单词首字母自动大写关闭 System Preferences -> Keyboard -> Text: Capitalize words automatically(去掉前面的对号即可) 2.13 设置外接显示器为主屏幕 选取苹果菜单 >“系统偏好设置”，然后点按“显示器”。 点按“排列”标签页。 确保“镜像显示器”复选框处于未选中状态。 排列您的显示器，以便与您办公桌上的布置保持一致。 要更改显示器的位置，请将它拖移到所需位置。 ... 要将另一台显示器设置为主显示器，请将菜单栏拖移到另一台显示器。 2.14 查看已连接的WIFI密码 1、打开launchpad找到 Keychain Access(钥匙串访问) 软件, 2、软件左上角点击 System(系统) ，然后找到要查看的WIFI名字，右键，选择Get Info(显示简介) 3、在出现的弹窗中，在attributes(属性) tab中， 勾选上Show password(显示密码)，然后会出现输入操作系统账号、密码。然后就可以看到WiFi密码了。 参考：http://www.xitongcheng.com/jiaocheng/dnrj_article_48495.html 2.15 关闭dock中 系统更新提示小红点 取消小红点： defaults write com.apple.systempreferences AttentionPrefBundleIDs 0 killall Dock 运行killall Dock后，dock会重新启动，然后系统更新提示的小红点就消失了。 恢复小红点显示: sudo softwareupdate --reset-ignored 其他操作： 查看可更新列表： sudo softwareupdate -l Software Update Tool Finding available software Software Update found the following new or updated software: * Safari14.0MojaveAuto-10.14.6 macOS Supplemental Update (10.14.6), 67310K [recommended] [restart] * macOS Mojave Security Update 2021-003-10.14.6 macOS Mojave Security Update 2021-003 (10.14.6), 1733666K [recommended] [restart] * Safari14.0.3MojaveAuto-14.0.3 Safari (14.0.3), 83320K [recommended] 忽略某个版本的更新： sudo softwareupdate --ignore \"XXX\" 例如： sudo softwareupdate --ignore \"macOS Catalina\" sudo softwareupdate --ignore \"macOS Catalina 10.15.4 Update\" 2.16 调整Mac桌面图标大小 1、桌面空白处右键，选择Show View Options(查看显示选项)，或者按快捷键cmd + J。 2、出现的弹窗中，在Icon size(图标大小)选线下面滑动，选择合适的大小。 2.17 软件无法打开：因为它可能损坏或不完整 1、首先查看这个软件，看软件大小，有的软件在更新的时候中断，大小变为0或者就是损坏了。 2、可以按照2.18的操作尝试，如果还不行那就只能从新下载。 2.18 软件打不开：来自身份不明开发者 1、打开系统偏好设置界面，进入安全性与隐私 2、在通用里面，点按左下角的锁头图标，解锁更改权限 3、将允许从以下位置下载的应用，更改为 “ 任何来源 ” ，然后再打开应用即可 若没有“任何来源”这个选项，按以下步骤执行： 1、打开终端（Terminal.app） 2、拷贝粘贴sudo spctl --master-disable按回车键 3、输入你的账户密码，按回车键确认执行（输入密码不会显示，直接输入确定正确即可） 参考：https://new.qq.com/rain/a/20220427A08O0H00.html 2.19 windows系统的TXT文件在mac中打开显示乱码 在Mac下打开“文本编辑”程序之后，选择菜单“文本编辑” -> “偏好设置”。2）在“偏好设置”中选择第二个标签页“打开和存储”，选择“纯文本文件编码”中的“打开文件”和“存储文件”修改成为“中文（GB 18030）”。3）退出“文本编辑”程序，再次打开时，就OK啦！ TextEdit -> Preferences -> Open and Save -> Plain Text File Encoding: Opening files: Chinese(GB 18030) （默认选项是Automatic） Saving files: Chinese(GB 18030) （默认选项是Automatic， 这个可以不修改） 如果想恢复，可以点击 Restore All Defaults 按钮来恢复默认选项 2.20 将搜狗输入法设置为默认输入法 系统版本：13.6.3 (22G436) 1、打开设置，点击键盘，找到文字输入，输入法中选择编辑 2、点击左下角的+加号，然后拉倒最下面，在其他选项里面找到Unicode十六进制输入，点击添加，Unicode输入法切换后尝试后和「ABC」是一样的 3、这个时候选择ABC输入法，然后点左下角的-减号就能删除了 恢复ABC输入法： 1、点击➕，左侧选择「英语」，右侧你会找到「ABC」，点击添加即可，然后再移除Unicode输入法 3. Mac下一些软件配置 3.1 app Store相关 3.1.1 关闭自动更新app Store 用户必须先进入“系统偏好设置”，找到Mac app store。 点击进去之后就就能看到Mac App Store的更新设置，这个时候只需要把自动更新设置去掉即可。 3.1.2 删除正在从app store下载的应用程序 打开Launchpad, 点击一下正在下载的程序暂停。 Launchpad里面，按住option 这个按键，应用图标左上角就会出现X按钮，点击，会出现问你是否删除，点击删除， 完成 3.2 应用程序安装目录 硬盘名称(如macintoch HD) /Applications 硬盘点开就能看到一个叫应用程序的文件夹，直接安装或拖拽过去就可以了，http://jingyan.baidu.com/article/363872ecd5b8406e4aa16f5e.html 3.3 创建 APP/文件夹 桌面快捷方式 1、在 Finder 中的应用程序中，找到想要创建快捷图标的应用程序。 2、按住键盘上的 option+command 键。 3、把想要在桌面上创建快捷方式的应用程序拖到桌面，先松鼠标，当看到有一个快捷箭头以后再把 option+command 键松开。 创建 文件夹 桌面快捷方式 跟APP创建快捷方式一样 3.4 允许第三方软件运行:开启任何来源选项 Mac在macOS Sierra系统下，系统偏好设置中的“安全与隐私”默认已经去除了允许“任何来源”App的选项，如果不开启会直接影响到无法运行一些第三方应用。 查看是否开启 打开系统偏好设置 -> 点击“安全与隐私” -> 如果没有“任何来源”这个选项就是没有开启。 开启任何来源选项 打开终端, 输入下面命令： sudo spctl --master-disable 然后输入管理员密码后关闭终端，再次打开系统设置-> 安全与隐私 即可开启。 参考资料：https://jingyan.baidu.com/article/9f63fb9162e3e6c8400f0e30.html 3.5 ShadowSocks 自定义代理规则 ShadowSocks 默认使用的是 adblock plus 的引擎，要想自己添加规则最好熟悉一下其规则，下面是ShadowSocks 的 pac 规则。 规则大概描述如下 通配符支持，如 *.example.com/* 实际书写时可省略 如 .example.com/ 意即 `.example.com/*` 正则表达式支持，以\\开始和结束， 如 \\[\\w]+:\\/\\/example.com\\ 例外规则 @@，如 @@*.example.com/* 满足@@后规则的地址不使用代理 匹配地址开始和结尾 |，如 |http://example.com、example.com| 分别表示以 http://example.com 开始和以 example.com结束的地址 || 标记，如 ||example.com 则 http://example.com 、https://example.com 、ftp://example.com 等地址均满足条件，只用于匹配地址开头 注释 ! 如 ! Comment 分隔符^，表示除了字母、数字或者 _ - . % 之外的任何字符。如 http://example.com^ ，http://example.com/ 和 http://example.com:8000/ 均满足条件，而 http://example.com.ar/ 不满足条件 如何使用自定义规则 点击ShadowSocks -> proxy Setting -> Edit User Rules For PAC 参考资料 https://adblockplus.org/zh_CN/filters ShadowSocks 自定义规则 3.6 ssh远程连接mac mac 默认安装了openssh。依次代开系统设置－－共享，把remote login勾上，选择允许的用户，就ok了在共享里面可以看见ssh命令，看这个命令就可以了。 终端无法使用小键盘 终端：偏好设置-->描述文件-->高级-->（去掉勾选）允许VT100应用程序小键盘模式 3.7 完全删除garageband音乐创作软件 garageband是Mac下的制作音乐的软件，如果不用可以删除，需要的时候在下载。 删除软件后在磁盘管理还能看见这个软件的一些占用的空间，经过在网上查找资料，可用如下方法彻底删除。 终端下运行如下命令： rm -rf /Library/Application\\ Support/GarageBand rm -rf /Library/Application\\ Support/Logic rm -rf /Library/Audio/Apple\\ Loops Macintosh HD/Applications/GarageBand.app (1.16GB)Macintosh HD/Library/Application Support/GarageBand (995MB)Macintosh HD/Library/Application Support/Logic (880MB)Macintosh HD/Library/Audio/Apple Loops (up to 10GB)*xx 3.8 使用Mail绑定outlook邮箱 打开Mail， 左上角菜单中， mail -> add account(邮件 -> 添加账户) 选择 Exchange > 继续 输入Exchange账户的名称、电子邮件地址和密码 > 登陆 选择想要使用此账户Mac应用程序 单击完成 如果邮件程序不能自动设置您的帐户，请稍等几分钟或几小时，然后重复这些步骤。如果重复步骤之后，邮件仍不能自动设置帐户，请参阅本文中的我还需了解哪些信息？。 mac 支持 3.8.1 Mail设置邮件到一个文件夹中 https://jingyan.baidu.com/article/363872ec11d4046e4ba16fb2.html 1、 创建一个文件夹： 打开mail，鼠标移到邮箱(Mailboxes)右边出现一个加号，点击，输入一个名字后创建一个文件夹。 2、创建邮件规则： 中文版：菜单（邮件）→偏好设置→添加规则，根据实际需要建立规则就可以了。 英文版：右上角Mail -> Preferences -> 出现的弹窗中选择Rules -> Add Rule 3.9 腾讯视频.app应用下载的视频存放位置 /Users/*(用户名文件）/Library/Containers/com.tencent.tenvideo/Data/Library/Application Support/Download/video 里面视频是被分开截的，所以要用腾讯的播放器才能看，其他mac下播放器离线缓存视频同理只能用对应的播放器看。其他播放器（优酷、iqiyi等）路径也在Containers对应的播放器文件目录的/Data/Library/Application Support/Download/video里（也是被截成的片段） 删除视频的时候注意看看这里是否也被删除了。 4. Mac下的 tree 命令 终端展示你的目录树结构 find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g' 打开 bash 配置文件,把上面命令拷贝粘贴进去 vi ~/.bash_profile # 把下面命令复制到.bash_profile alias tree=\"find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'\" # 保存后执行下面命令 source .bash_profile 直接安装tree工具： ~ brew install tree /Users/zhangzhi/code/angular-phonecat git:(master) >brew install tree ==> Downloading http://mama.indstate.edu/users/ice/tree/src/tree-1.6.0.tgz Already downloaded: /Library/Caches/Homebrew/tree-1.6.0.tgz ==> make prefix=/usr/local/Cellar/tree/1.6.0 MANDIR=/usr/local/Cellar/tree/1.6.0/share/man/man1 CC=c 🍺 /usr/local/Cellar/tree/1.6.0: 7 files, 140K, built in 2 seconds # 帮助查看 ~ tree --help 5. Mac 了解应用安装后占用的磁盘空间 https://segmentfault.com/a/1190000005035742 5.1 App最喜欢的几个目录 Mac和Windows操作系统有一个很大的不同，大部分App是没有安装程序的，一般下载下来就是一个dmg文件，解开之后直接将App拖到应用程序目录下就可以了，所以给人感觉卸载也就是将App拖到废纸篓然后清空。如果真这样做就大错特错，即使一个最简单的App都会在下面几个目录中或多或少留下纪念，这些目录一般有： ~/Library ~/Library/Application Support ~/Library/Application Support/CrashReporter ~/Library/Caches ~/Library/Containers ~/Library/LaunchAgents ~/Library/Preferences ~/Library/PreferencePanes 如果一个程序是通过pkg方式安装，或者是在第一次运行时请求管理员权限，那一般还会在如下几个目录中留点纪念： /Library /Library/Application Support /Library/Extensions /Library/LaunchAgents /Library/LaunchDaemons /Library/PreferencePanes /Library/Preferences 以上都还是只是列出了部分，不同的App由于需要还会在其他目录中安装一些文件，比如字处理软件一般会在/Library/Fonts下面安装字体，有些扩展组件会放在/Library/ScriptingAdditions下面。 5.2 ~/Library/Application Support 这个目录可以说是App最重要的文件目录，一些App本身并不大，但是需要的支持组件和内容非常多，特别是采用第三方插件和缓存网络内容的软件，例如我用的Dash，本身的大小只有24MB左右，但是由于经常浏览资料，所以缓存了很多网络内容，使得它的Support目录达到了1.37GB！可想而知，如果只是将App扔到废纸篓，几乎不会节省任何空间。 5.3 ~/Library/Preferences 这个目录下保存的是App设置，一般来说，稍微有点规模的软件都有自己的配置信息，放在这里的文件虽然占空间不多，但是清理掉还是有好处的，例如有些App不能正常工作，即使卸载重装也不行，往往就是配置文件出错了，把这里清理掉之后再重装就会有比较好的效果。 5.4 ~/Library/Containers 这个目录对于App Store上下载的软件来说，是最重要的一个目录，由于Apple的限制，AppStore的软件都在沙箱中运行，每个软件在沙箱都有自己的一个完整空间，对于App来说，它以为自己在一个正常的目录系统中运行，但实际上不是，操作系统重定位了读写位置到沙箱之中。要是卸载软件的时候，只是简单的在Launchpad中点一下叉来删除，那不知道又有多少空间莫名其妙地消失了，我曾经用这种方式卸载了网易云音乐，结果后来才发现，整整417MB的空间不见了…… 5.5 ~/Library/LaunchAgents Mac上的随机启动方式之一，熟悉OS X操作系统的同学应该立刻想到了launchctl，这里就是存放启动配置文件的地方，大部分App只会往这里写启动信息，请神容易送神难，要送神，只有用第三方工具或是自己手动清理了，还有，LaunchAgents 和 LaunchDaemons 是有一些区别的，两者虽然都是随机启动， 6. Mac 清理磁盘空间 除资源库（Library）没用的大东西可删。电脑固定自带的文件夹（资源库、图片、桌面、音乐、下载、影片、公共、文稿、应用程序）和应用程序不删。 Library清理指南： 一、Caches 该缓存占很大的空间，可删除 二、Applications Support 应用软件的支持，可删除已经卸载的软件文件 三、Applications Script 应用软件的脚本，可删除已经卸载的软件文件 四、Containers 可删除已经卸载的软件文件 可卸载重装以删除数据 五、Preferences 软件的配置，可删除已经卸载的软件文件 六、Logs 日志文件，可删除 powered by Gitbook文件最后修改时间： 2024-11-04 14:49:57 "},"doc/mac/003-Mac快捷键和一些常用操作.html":{"url":"doc/mac/003-Mac快捷键和一些常用操作.html","title":"Mac快捷键和一些常用操作","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Mac快捷键和一些常用操作 1. 睡眠重启关机 2. 一个应用多个窗口之间切换快捷键 3. 多个桌面切换快捷键 4. 全屏(变成一整个桌面)，退出全屏再按一次 5. 最小化应用 6. 应用窗口最大化(铺满屏幕) 7. 同一个应用多个窗口切换 8. 关闭窗口 9. 退出应用 10. 强制退出Mac程序 10.1 使用快捷键：Command+Option+Esc 10.2 使用终端命令强制退出程序 11. 调整OS X系统窗口大小 12. 浏览器快捷键 13. 隐藏/显示Dock 14. 删除文件快捷键 15. 检测文件参数MD5、sha1、sha256 [TOC] Mac快捷键和一些常用操作 Mac 官方快捷键地址： https://support.apple.com/zh-cn/HT201236 1. 睡眠重启关机 Ctrl+Shift+Power: 关闭屏幕Cmd+Opt+Power: 睡眠 (sleep)Cmd+Ctrl+Power: 重启 (restart)Cmd+Ctrl+Opt+Power: 关机 (shutdown) 2. 一个应用多个窗口之间切换快捷键 默认 cmd+` 就是程序内窗口切换。 触摸板手势：四指下滑（有些人用三指的） 3. 多个桌面切换快捷键 Control + 箭头 → ← 触摸板手势： 四指（三指）左右滑动 4. 全屏(变成一整个桌面)，退出全屏再按一次 Control-Command-F 5. 最小化应用 Command + M 6. 应用窗口最大化(铺满屏幕) 按住 Option 全屏按钮就会变为 + ， 点就是垂直最大化； 按住 shift+Opt 全屏按钮也会变为 + ， 点击就是最大化，而不是全屏； 7. 同一个应用多个窗口切换 Command + ~(就是esc下面那个按键) 8. 关闭窗口 Command + W 9. 退出应用 Command + Q 10. 强制退出Mac程序 10.1 使用快捷键：Command+Option+Esc 来打开“强制退出应用程序”的窗口，然后选中你需要退出的程序，再点右下方的“强制退出”即可。 10.2 使用终端命令强制退出程序 终端中输入命令killall [程序名称].比如说强制退出Safari，就输入 killall Safari 再回车即可，这样有关Safari的全部进程就都退出了；如果你想分的细一些，可以通过 ps 或者 ps aux 命令查找某些单独的进行，然后使用 kill -9 [pid] 来单独结束某个进程。很多情况下强制退出程序，之前的内容可能就会不在了，需要注意一下。 使用键盘快捷键强制退出处于活跃状态的Mac程序:快捷键：Command+Option+Shift+Esc , 这样按住一两秒钟，就可以强制退出当前程序了，算是最方便的一种方法。 http://www.cnbeta.com/articles/tech/175447.htm 11. 调整OS X系统窗口大小 1.Option 键双向加宽，按着Option 键再一起拖曳窗口会变成往两边伸展。2.Shift 键放射状加大， shift把窗口长宽一起加大。3.在窗口顶部按两下，最大化窗口。 12. 浏览器快捷键 cmd+1（2、3...）分别是打开书签栏的第一个、第二个...网址切换网页 ：Option + Command + 箭头 → ←从新打开关闭的标签： shift + command +T刷新网页： cmd + R 13. 隐藏/显示Dock option + command + D 14. 删除文件快捷键 Command + Delete(|\\上面的按键)：将某个项目直接删除至废纸篓。Shift + Command + Delete：清空废纸篓。Shift + option + Command + Delete：强制清空废纸篓（无警告）。 15. 检测文件参数MD5、sha1、sha256 # 查看文件MD5： md5[空格][拖曳要检测的文件到此处] # 查看文件SHA1: openssl dgst -sha1[空格][拖曳要检测的文件到此处] # 查看文件SHA256： openssl dgst -sha256[空格][拖曳要检测的文件到此处] powered by Gitbook文件最后修改时间： 2021-05-19 16:57:39 "},"doc/mac/004-Mac下终端常用设置、命令、快捷键.html":{"url":"doc/mac/004-Mac下终端常用设置、命令、快捷键.html","title":"Mac下终端常用设置、命令、快捷键","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. 介绍 2. 终端设置 2.1 修改mac终端命令行前缀的显示 2.2 修复终端hostname被篡改为bogon 2.3 终端shell与zsh之间的切换 2.4 设置终端使用命令打开vscode软件打开当前目录 3. 快捷键 3.1 终端光标做操快捷键 3.2 处理窗口和标签页快捷键 4. 终端常用操作 4.1 查看进程 4.2 查看端口号 4.3 终端使用代理 4.3.1 终端临时使用代理，只对这个终端有效，关闭后失效： 4.3.2 终端永久使用代理： 把代理服务器地址写入shell配置文件.bashrc或者.zshrc 4.4 终端进入名称带空格的目录 4.5 终端刷新DNS缓存 5. 终端一些命令安装 5.1 wget安装 5.2 tree命令安装 6. 删除终端history历史命令记录 参考资料 [TOC] 1. 介绍 macos的很多用户都是做it相关的人，类unix系统带来了很多方面，尤其是经常和Linux打交道的人。 但是作为经常使用linux 命令行的人发现macos中的命令行工具很多都是bsd工具，跟linux下得使用方式开始差距挺大的 Max OS X使用的是 BSD版本的命令行工具，这些命令跟 Linux版本是有些不同的，然而它们都遵循 POSIX 标准。 资料： http://blog.csdn.net/orangleliu/article/details/47357339 2. 终端设置 2.1 修改mac终端命令行前缀的显示 /etc/bashrc 中的PS1变量就是用来设置前缀显示的。 终端打开/etc/bashrc文件： sudo vim /etc/bashrc 修改PS1变量，例如修改为如下形式(把原来的注释掉： # PS1='\\h:\\W \\u\\$ ' PS1='\\u\\$ ' wq!保存并退出，将终端退出重新打开生效。 变量代表的含义 \\h表示本地主机名 \\W表示符号~ \\u表示用户名 \\$表示符号$ 2.2 修复终端hostname被篡改为bogon 终端显示bogon原因： terminal显示hostname之前会先根据本机IP做一次rDNS反向查询，就是通过ip地址查询hostname，如果没有查询到，那么使用本机设置的hostname。本机IP通常是局域网IP地址（保留IP地址），一般是查不到的，所以terminal一般显示的本机设置的hostname，比如laowang's-macbook。 上面提到，局域网IP地址一般是查不到hostname，是因为ISP提供商或者用户防火窗的屏蔽保留IP地址，因为保留IP地址在公网中没啥用，即便是没有被屏蔽掉，rDNS服务器一般也会关闭响应保留IP地址的查询请求。凡事都有例外，rDNS服务器对这种保留IP地址对查询一律返回bogon。在ipv4对地址划分中，除了公网分配在用对IP地址外，其余保留IP地址统一叫做bogon space 解决方法： 将DNS设置为Google的DNS服务器地址 8.8.8.8 终端输入如下命令： sudo hostname MBP sudo scutil --set LocalHostName $(hostname) sudo scutil --set HostName $(hostname) 注：上面MBP就是你想要修改的新名字。 2.3 终端shell与zsh之间的切换 # 切换默认Shell为Zsh, 成功后需要重启终端 ~ chsh -s /bin/zsh # 切换Zsh为Shell， 成功后需要重启终端 ~ chsh -s /bin/bash # 查看zsh配置的环境变量： ~ cat ~/.zshrc 2.4 设置终端使用命令打开vscode软件打开当前目录 1、找到打开软件的路径： 打开finder -> Applications(应用程序) -> 找到 vscode，右键，选择Show Package Contents(显示包内容) ….,一级一级的找下去，最终的文件类似于如下： /Applications/Visual Studio Code.app/Contents/Resources/app/bin/code 2、打开终端，进入用户根目录： cd # 或者 cd ~ # 找到.zshrc文件 la -al 3、打开.zshrc文件，在文件的末尾添加如下命令： # 终端使用 code . 命令使用vscode打开当前目录 alias code='/Applications/Visual\\ Studio\\ Code.app/Contents/Resources/app/bin/code' 4、从新应用配置或重启终端后，终端打开一个项目文件，使用code .即可使用vscode打开项目。 source .zshrc 3. 快捷键 control + L # 终端清屏，相当于 clear命令 open 文件名 # 使用默认程序打开文件 如 open . 使用finder打开该目录 3.1 终端光标做操快捷键 Mac Terminal终端和Linux上终端光标的快捷键操作是一样的，都是来自Emacs这个神级的编辑器,跟VIM不一样。 Ctrl + a 光标移动到行首（Ahead of line），相当于通常的Home键 Ctrl + e 光标移动到行尾（End of line） Alt+← 或 ESC+B：左移一个单词； Alt+→ 或 ESC+F：右移一个单词； Ctrl + d 删除一个字符，相当于通常的Delete键（命令行若无所有字符，则相当于exit；处理多行标准输入时也表示eof） Ctrl + h 退格删除一个字符，相当于通常的Backspace键 Ctrl + u 删除光标之前到行首的字符 Ctrl + k 删除光标之前到行尾的字符 Ctrl + c 取消当前行输入的命令，相当于Ctrl + Break Ctrl + f 光标向前(Forward)移动一个字符位置 Ctrl + b 光标往回(Backward)移动一个字符位置 Ctrl + l 清屏，相当于执行clear命令 Ctrl + p 调出命令历史中的前一条（Previous）命令，相当于通常的上箭头 Ctrl + n 调出命令历史中的下一条（Next）命令，相当于通常的上箭头 Ctrl + r 显示：号提示，根据用户输入查找相关历史命令（reverse-i-search） 次常用快捷键： Alt + f 光标向前（Forward）移动到下一个单词 Alt + b 光标往回（Backward）移动到前一个单词 Ctrl + w 删除从光标位置前到当前所处单词（Word）的开头 Alt + d 删除从光标位置到当前所处单词的末尾 Ctrl + y 粘贴最后一次被删除的单词 3.2 处理窗口和标签页快捷键 操作 快捷键 新建窗口 Command-N 使用相同命令新建窗口 Control-Command-N 新建标签页 Command-T 使用相同命令新建标签页 Control-Command-T 显示或隐藏标签页栏 Shift-Command-T 显示所有标签页或退出标签页概览 Shift-Command-反斜杠 () 新建命令 Shift-Command-N 新建远程连接 Shift-Command-K 显示或隐藏检查器 Command-I 编辑标题 Shift-Command-I 编辑背景颜色 Option-Command-I 放大字体 Command-加号键 (+) 缩小字体 Command-减号键 (–) 下一个窗口 Command-重音符键 (`) 上一个窗口 Command-Shift-波浪符号 (~) 下一个标签页 Control-Tab 上一个标签页 Control-Shift-Tab 将窗口拆分为两个面板 Command-D 关闭拆分面板 Shift-Command-D 关闭标签页 Command-W 关闭窗口 Shift-Command-W 关闭其他标签页 Option-Command-W 全部关闭 Option-Shift-Command-W 滚动到顶部 Command-Home 滚动到底部 Command-End 上一页 Command-Page Up 下一页 Command-Page Down 上一行 Option-Command-Page Up 下一行 Option-Command-Page Down 4. 终端常用操作 4.1 查看进程 # 搜索特定进程， ~ ps aux|grep 进程名字 # 动态显示进程 ~ top 4.2 查看端口号 # 搜索端口号为8080, 可以看见进程名字与ID lsof -i:8080 # 查看IPv4端口：(最好加 sudo) ~ lsof -Pnl +M -i4 # 查看IPv6协议下的端口 lsof -Pnl +M -i6 ~ sudo netstat antup 参考链接： http://blog.csdn.net/u011619283/article/details/53116291http://blog.csdn.net/winkenjiang/article/details/7588658 4.3 终端使用代理 4.3.1 终端临时使用代理，只对这个终端有效，关闭后失效： export http_proxy=http://proxyAddress:port export http_proxy=\"http://127.0.0.1:1080\" export https_proxy=\"http://127.0.0.1:1080\" 这个办法的好处是简单直接，并且影响面很小（只对当前终端有效）。 4.3.2 终端永久使用代理： 把代理服务器地址写入shell配置文件.bashrc或者.zshrc 直接在.bashrc或者.zshrc添加下面内容: # vi ~/.ashrc export http_proxy=\"http://localhost:port\" export https_proxy=\"http://localhost:port\" # 以使用shadowsocks代理为例，ss的代理端口为1080,那么应该设置为： export http_proxy=\"http://127.0.0.1:1080\" export https_proxy=\"http://127.0.0.1:1080\" localhost就是一个域名，域名默认指向 127.0.0.1，两者是一样的。然后ESC后:wq保存文件，接着在终端中执行source ~/.bashrc或者退出当前终端再起一个终端。 这个办法的好处是把代理服务器永久保存了，下次就可以直接用了。 4.4 终端进入名称带空格的目录 可使用\\ ' ' \" \" 将空格转义就可以了。 1. cd Appications/Android\\ Studio.app/sdk 2. cd Appications/Android' 'Studio.app/sdk 3. cd Appications/Android\" \"Studio.app/sdk 4.5 终端刷新DNS缓存 sudo killall -HUP mDNSResponder 5. 终端一些命令安装 5.1 wget安装 wget是unix上一个发送网络请求的命令工具，不过mac本身并没有，mac自带的是curl，都是发送网络请求，但是两者之间肯定存在一些差异。一般来说，wget主要专注于下载文件，curl长项在于web交互、调试网页等。 需要使用homebrew进行安装，如果没安装请先安装这个 终端安装wget命令： brew install wget --with-libressl ==> Installing dependencies for wget: libunistring, libidn2 and openssl ==> Installing wget dependency: libunistring ==> Downloading https://homebrew.bintray.com/bottles/libunistring-0.9.10.high_si ######################################################################## 100.0% ==> Pouring libunistring-0.9.10.high_sierra.bottle.tar.gz 🍺 /usr/local/Cellar/libunistring/0.9.10: 54 files, 4.4MB ==> Installing wget dependency: libidn2 ==> Downloading https://homebrew.bintray.com/bottles/libidn2-2.0.5.high_sierra.b ######################################################################## 100.0% ==> Pouring libidn2-2.0.5.high_sierra.bottle.tar.gz 🍺 /usr/local/Cellar/libidn2/2.0.5: 68 files, 668.6KB ==> Installing wget dependency: openssl ==> Downloading https://homebrew.bintray.com/bottles/openssl-1.0.2q.high_sierra. ######################################################################## 100.0% ==> Pouring openssl-1.0.2q.high_sierra.bottle.tar.gz ==> Caveats A CA file has been bootstrapped using certificates from the SystemRoots keychain. To add additional certificates (e.g. the certificates added in the System keychain), place .pem files in /usr/local/etc/openssl/certs and run /usr/local/opt/openssl/bin/c_rehash openssl is keg-only, which means it was not symlinked into /usr/local, because Apple has deprecated use of OpenSSL in favor of its own TLS and crypto libraries. If you need to have openssl first in your PATH run: echo 'export PATH=\"/usr/local/opt/openssl/bin:$PATH\"' >> ~/.zshrc For compilers to find openssl you may need to set: export LDFLAGS=\"-L/usr/local/opt/openssl/lib\" export CPPFLAGS=\"-I/usr/local/opt/openssl/include\" ==> Summary 🍺 /usr/local/Cellar/openssl/1.0.2q: 1,794 files, 12.1MB Warning: wget: this formula has no --with-libressl option so it will be ignored! ==> Installing wget ==> Downloading https://homebrew.bintray.com/bottles/wget-1.20.high_sierra.bottl ######################################################################## 100.0% ==> Pouring wget-1.20.high_sierra.bottle.tar.gz 🍺 /usr/local/Cellar/wget/1.20: 50 files, 3.9MB ==> Caveats ==> openssl A CA file has been bootstrapped using certificates from the SystemRoots keychain. To add additional certificates (e.g. the certificates added in the System keychain), place .pem files in /usr/local/etc/openssl/certs and run /usr/local/opt/openssl/bin/c_rehash openssl is keg-only, which means it was not symlinked into /usr/local, because Apple has deprecated use of OpenSSL in favor of its own TLS and crypto libraries. If you need to have openssl first in your PATH run: echo 'export PATH=\"/usr/local/opt/openssl/bin:$PATH\"' >> ~/.zshrc For compilers to find openssl you may need to set: export LDFLAGS=\"-L/usr/local/opt/openssl/lib\" export CPPFLAGS=\"-I/usr/local/opt/openssl/include\" ➜ ~ ~ wget --version GNU Wget 1.20 built on darwin17.7.0. 参考资料：https://www.jianshu.com/p/f6b290710262 5.2 tree命令安装 tree命令用来在终端下显示目录树结构，在Mac下默认是没有安装该命令的。 需要使用终端使用brew命令来安装tree： brew install tree ==> Downloading http://mama.indstate.edu/users/ice/tree/src/tree-1.7.0.tgz Already downloaded: /Library/Caches/Homebrew/tree-1.7.0.tgz ==> make prefix=/usr/local/Cellar/tree/1.7.0 MANDIR=/usr/local/Cellar/tree/1.7.0/share/man/man1 CC=c 🍺 /usr/local/Cellar/tree/1.7.0: 7 files, 140K, built in 2 seconds 安装后可使用tree --help来查看使用帮助。 在使用过程中，如果目录中有中文文件，会显示乱码，可使用tree -N命令来解决。 6. 删除终端history历史命令记录 由于长时间没有清除history历史命令，导致历史命令记录很多，需要删除终端历史命令记录 默认登录 shell 是 zsh的话，用以下命令： ~ history ~ rm ~/.zsh_history 默认登录 shell 是 bash ，用以下命令： ~ history ~ rm ~/.bash_history 删除结束后，重启终端生效 参考资料 “终端”键盘快捷键 powered by Gitbook文件最后修改时间： 2024-11-13 15:15:31 "},"doc/mac/005-Mac下Iterm2使用及快捷键.html":{"url":"doc/mac/005-Mac下Iterm2使用及快捷键.html","title":"Mac下Iterm2使用及快捷键","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. 光标控制 2. 终端操作快捷键 2.1 窗口面板管理：一个窗口分割 2.2 新建Tab标签页 2.3 多个窗口操作 2.4 其他功能 2.4.1 粘贴历史 2.4.2 即时回放 2.5 自定义快捷键设置 2.5.1设置光标按照单词快速移动 3. 个性化的设置 3.1 设置无分栏边框 3.2 终端显示边框 3.2 显示、隐藏终端快捷键 3.3 鼠标移动切换窗口 3.4 设置光标形状 3.5 新窗口打开的路径跟当前终端的路径一直 3.6 新窗口在电脑获取焦点的窗口生成 3.7 设置开机启动不显示界面 4. iterm2软件版本更新 参考资料 [TOC] 1. 光标控制 ctrl + a: 到行首 ctrl + e: 行末 ctrl + f/b: 前进后退，相当于左右方向键，但是显然比移开手按方向键更快 ctrl + p: 上一条命令，相当于方向键上 ctrl + r: 搜索命令历史，这个大家都应该很熟悉了 ctrl + d: 删除当前字符 ctrl + h: 删除之前的字符 ctrl + w: 删除光标前的单词 ctrl + k: 删除到文本末尾 ctrl + t: 交换光标处文本 ⌘ + —/+/0: 调整字体大小 ⌘ + r:清屏，其实是滚到新的一屏，并没有清空。ctrl + l 也可以做到。 2. 终端操作快捷键 2.1 窗口面板管理：一个窗口分割 垂直分割: Command + D 水平分割: Shift + Command + D 前一个面板: Command + [ 或 Option + Command + 左右方向键 后一个面板: Command + ] 切换到上/下/左/右面板: Option + Command + 上下左右方向键 关闭panel：⌘ + w 最大化Tab中的pane，隐藏本Tab中的其他pane：⌘+ shift +enter , 再次还原 2.2 新建Tab标签页 新建标签页: Command + T 关闭标签页: Command + W 前一个标签页: Command + 左方向键，Shift + Command + [ 后一个标签页: Command + 右方向键，Shitf + Command + ] 进入标签页1，2，3…: Command + 标签页编号 Expose 标签页: Option + Command + E（将标签页打撒到全屏，并可以全局搜索所有的标签页） 窗口太多，可以使用 ⌘ + / 快速定位到光标所在位置 2.3 多个窗口操作 新建窗口：command + N 关闭窗口： command + w 前一个窗口：command + ` 后一个窗口：Shitf + command + ` 进入窗口 1,2,3：option + command + 编号 2.4 其他功能 支持自定义全局快捷键用于显示和隐藏iTerm2 Preference -> Keys －> Show/hide iTerm2 with a system-wide hotkey 打上勾之后 进入和退出全屏: Command + Enter 查看当前终端中光标的位置: Command + / 命令自动补全: Command + ;（很少用这个，还是感觉Zsh的补全更好用） 开启和关闭背景半透明: Command + u 清屏（重置当前终端）: Command + r 2.4.1 粘贴历史 使用Command + Shift + h 可以呼出粘贴历史，支持模糊检索。还可以设置将粘贴历史保存在磁盘上（Preferences -> General） 2.4.2 即时回放 使用Command + Opt + b 打开即时回放，按Esc退出。即时回放可以记录终端输出的状态，让你“穿越时间”查看终端内容。默认每个会话最多储存4MB的内容，可以在设置中更改（Preferences -> Genernal -> Instant Replay）。 2.5 自定义快捷键设置 2.5.1设置光标按照单词快速移动 iTerm2之后，发现option+←和option+→这两组快捷键并不能实现光标按照单词快速移动， 在Mac自带的终端中是可以使用这两个快捷键的，经过查找和测试发现，需要重新配置相应的映射。iTerm2中将这两组快捷键用作了其他的功能。 打开iTerm2的Preferences设置 选择相应的Profile（默认为Default），选择“Keys”选项卡，然后可以在Key Mappings看到option+←和option+→这两组快捷键用作了其他功能，这里我们只需要重新绑定新的映射即可 找到option+← ， 双击就会弹出一个编辑框，选择Action为“Send Escape Sequence”, 然后在 Esc+选项中输入b 找到option+→， 双击就会弹出一个编辑框，选择Action为“Send Escape Sequence”, 然后在 Esc+选项中输入f 修改映射之后，再重新启动iTerm2就可以使用option+←和option+→来实现光标按单词快速移动了，非常方便。如果不想使用option+←和option+→这两个组合键的话，也可以自行添加新的Shortcut即可。 3. 个性化的设置 3.1 设置无分栏边框 preference->appearance： 取消：Show per-pane title bar with split panes 勾选：Hide scrollbars 3.2 终端显示边框 preference->appearance： 勾选：Show border around window 3.2 显示、隐藏终端快捷键 Preferences -> Keys -> Hotkey: 勾选： Show/hide iTerm2 with a system-wide hotkey 然后在下面的Hotkey里面填上F12， 这个F12可能被系统占用了，这修改系统的快捷键，或更换别的快捷键。 3.3 鼠标移动切换窗口 当一个终端打开了多个窗口，可以设置鼠标移动窗口时获取焦点 Preferences -> Pointer: 勾选：Focus follows mouse 3.4 设置光标形状 Preferences -> Profiles -> Profile Name -> Text -> Cursor 选择一个自己喜欢的样式 3.5 新窗口打开的路径跟当前终端的路径一直 Preferences -> Profiles -> General -> Working Directory -> reuse previous session's directory 3.6 新窗口在电脑获取焦点的窗口生成 Preferences -> Profiles -> General -> Window -> Settings for New Windows -> Screen 选择：No Preference 或者选择：Screen with Cursor（在鼠标的窗口） 3.7 设置开机启动不显示界面 1、打开系统设置(System Perferences) -> 通用 -> 登陆项(Login Items)，登录时打开-> 点击加号，然后去应用程序里面找到Iterm2添加到启动项里面。 2、启动iterm2程序，打开一个窗口，然后手动点击关闭按钮，确保电脑右上角苹果图标右边是iTerm2,然后 按【Command】+【Shift】+【S】，保存名为No Window 3、打开一个iterm2终端界面，然后按cmd + ,打开iterm的设置界面，选择Arrangements，点击刚才保存的No Window， 然后点击Set Default。 4、在iterm的设置界面选择General, 在Startup中选择Open Default Window Arrangement。 参考资料：https://blog.csdn.net/weixin_34023863/article/details/85958226 4. iterm2软件版本更新 由于我本人mac系统升级(10.14升级到13.7.1)，导致iterm2软件出现了一些问题，比如：终端半透明效果没有了，查看终端内容上下滚动的时候部分内容消失了。因此需要升级软件版本来解决这些问题 1、官网下载软件：https://iterm2.com/ 打开页面后，直接点击Download按钮下载软件。 2、软件下载下载后，是一个压缩包，解压缩。 3、完全退出iterm2软件，然后双击解压的软件，软件会提示是否移动到应用文件夹。移动成功后会自动打开软件，此时就是最新的软件了。 更新后软件设置都是之前一样的，没有变动。出现的问题都会修复。 参考资料 iterm2使用快捷键 关于iTerm2 你不知道的一些事 Mac下iTerm2光标按照单词快速移动设置 打造有情怀的 iTerm2 终端 powered by Gitbook文件最后修改时间： 2024-11-23 15:24:34 "},"doc/mac/006-Mac中常见错误以及处理方法.html":{"url":"doc/mac/006-Mac中常见错误以及处理方法.html","title":"Mac中常见错误以及处理方法","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Mac中常见错误及处理方法 1. The GitHub credentials in the macOS keychain may be invalid. 2. ftp Received unexpected end-of-file from SFTP server 3. 键盘大小写切换灯不亮，但是可以切换大小写 4. Mac右上角导航栏WiFi图标点击后卡死 [TOC] Mac中常见错误及处理方法 1. The GitHub credentials in the macOS keychain may be invalid. 错误信息： 解决方法： # 终端命令,https://github.com/Homebrew/brew/issues/93 ~ brew update # 这个命令执行时间有点长要耐心等待 2. ftp Received unexpected end-of-file from SFTP server https://superuser.com/questions/901992/filezilla-does-not-open-connection-putty-does https://www.digitalocean.com/community/questions/sftp-connection-error-received-unexpected-end-of-file-from-sftp-server 3. 键盘大小写切换灯不亮，但是可以切换大小写 可能是QQ音乐播放器导致的，退出QQ音乐就好了。 4. Mac右上角导航栏WiFi图标点击后卡死 在Mac10.14版本，电脑右上角导航栏，WiFi图标有的时候点击会卡死，重启就好了。 后来Mac系统升级到了Mojave 10.14.6版本， 有几次发现WiFi图标又有好几次卡死现象，然后去网络上查找解决办法。 经过我的尝试，发现终端输入如下命令解决了问题： sudo killall airportd 输入密码后， WiFi就好了。 killall 命令用于终止某个指定名称的服务所对应的全部进程，格式为：“killall [参数] [服务名称]”。 这个命令终止airportd。airportd会重启，在Mac任务管理其中，搜索airportd可以查看到airportd 网络上还有的说终止SystemUIServer顶部菜单栏程序，但是我终止后，并没有解决WiFi卡死问题。 https://blog.csdn.net/yanglei3kyou/article/details/101708837 关于Mac进程的介绍：https://www.cnblogs.com/jinjiangongzuoshi/p/5373711.html powered by Gitbook文件最后修改时间： 2021-05-19 17:06:57 "},"doc/mac/007-Mac下vscode编辑器设置.html":{"url":"doc/mac/007-Mac下vscode编辑器设置.html","title":"Mac下vscode编辑器设置","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. 配置设置 1.1 设置格式化缩进为2个空格 1.2 设置一类文件tab键为两个空格 1.2.1 设置当前文件缩进 1.3 关闭文件预览 1.4 react中可以使用emmet 1.5 关闭右侧缩略图（预览面板） 1.6 编辑区域面板拆分 1.7 前端vue相关配置 1.7.1 设置.vue文件HTML模板中emmet支持vue特有的标签 1.8 关闭点击对应文件是，资源管理器自动定位到该文件 1.9 标题栏显示文档全路径 1.10 关闭编辑器的预览，免得打开新文件胡替换老的文件 1.11 设置鼠标双击才打开文件 1.12 编辑器tab标签下面显示打开文件的导航 1.13 编辑器文字超出了编辑器可视区域，是否自动在下一行显示 1.14 修改vscode上终端的字体大小 1.15 添加代码片段snippets 1.16 编辑代码后自动保存 1.17 代码保存后自动格式化 1.18 代码保存后自动格式化成ESLint规范形式 1.19 设置自定义代码片段在提示的最上面 2. 快捷键设置 2.1 复制一行快捷键自定义：command + D 2.2 格式化代码快捷键： option + cmd + L 2.3 格式化选中的代码快捷键：cmd + L 2.4 删除一行快捷键： command + delete 2.5 将选择添加到下一个查找匹配项(Add Selection To Next Find Match) 2.6 切换编辑器组布局(垂直/水平): option + cmd + 数字零 2.7 当前行向上移动一行： option + 向上箭头 2.8 当前行向下移动一行： option + 向下箭头 2.9 当前行缩进 2.10 减少行缩进 3. vscode一些快捷操作 3.1 变量重命名：选中后按F2 4. vscode的一些插件 安装离线插件 4.1 ESLint: JavaScript代码格式化检查插件 4.2 stylelint：CSS代码规范检查插件 4.3 适用于 VS Code 的中文（简体）语言包 4.4 Beautify ：代码变得非常好看的格式 4.4.1 Beautify css/sass/scss/less CSS格式化插件 4.5 GitLens supercharges : 显示每行代码GIT的提交记录 4.6 CSS Peek：追踪至样式表中 CSS 类和 ids 定义的地方 4.7 color info: css中颜色的其他写法 4.8 Document This：自动为TSc和JS文件生成详细的JSDoc注释 4.9 vscode-icons:资源树目录加上图标 4.10 Auto Rename Tag:修改标签名称的时候自动修改结束标签 4.10 自动关闭标签：Auto Close Tag 4.11 open native terminal : 在右键菜单中添加打开终端 4.12 console-snippets: console.log快捷插件 4.13 Turbo Console Log: 选中变量快捷添加console.log 4.14 Vim：让vscode像vim中一样使用命令 4.15 Bookmarks：添加标签，快速定位标记的代码 4.16 Bracket Pair Colorizer:代码的各种括号呈现不同的颜色 4.17 对 webpack 别名路径或者自定义别名路径进行快速跳转的插件 4.18 计算引入包的大小 4.19 设置tab强调色 4.20 代码缩进着色 4.21 Settings Sync: 同步vscode设置及扩展配置 4.22 Path Intellisense:路径只能提示 4.23 HTML CSS Support: html中css类补全 4.24 代码翻译：翻译(英汉词典) 4.25 Code Spell Checker:英文单词拼写错误检查 4.26 同步你的VSCode设置及扩展插件，换机不用愁 4.27 AI编程工具：TONGYI Lingma 5. VUE框架相关的插件 5.1 vetur：语法高亮插件 5.2 Vue VSCode Snippets: vue模板 6. 使用vscode遇到的问题 6.1 html文件使用快捷键注释不对 6.2 保存时，自动把var变量改成了let 6.3 vue代码格式化方式不对 6.4 vue使用iView时标签报错 Parsing error: x-invalid-end-tag 6.5 Could not create temporary directory: Permission denied 6.6 安装离线插件失败，有兼容性问题 6.7 Prettier格式化vue中html代码问题 其他插件资料 [TOC] 1. 配置设置 打开配置文件：vscode菜单： Code -> Preferences -> Settings(快捷键command + ，)，打开配置文件。 1.1 设置格式化缩进为2个空格 // 一个tab为2个空格 // 如果设置了editor.detectIndentation = true 则会根据根据文件内容进行重写。 \"editor.tabSize\": 2, // 2018-10-20 关闭检测缩进，设置后代码格式化时就会自动变成2个空格了 \"editor.detectIndentation\": false, // 按tab键会变成插入空格 \"editor.insertSpaces\": true, 1.2 设置一类文件tab键为两个空格 // 2018-10-20 关闭检测缩进，设置后代码格式化时就会自动变成2个空格了 \"editor.detectIndentation\": false, // 设置tab键的空格数量为2 \"[html]\": { \"editor.tabSize\": 2 }, \"[css]\": { \"editor.tabSize\": 2 }, \"[javascript]\": { // 按 \"Tab\" 时插入空格。该设置在 `editor.detectIndentation` 启用时根据文件内容进行重写。 \"editor.insertSpaces\": true, // 一个制表符等于的空格数。该设置在 `editor.detectIndentation` 启用时根据文件内容进行重写。 \"editor.tabSize\": 2 }, \"[typescript]\": { \"editor.tabSize\": 2 }, https://blog.csdn.net/example440982/article/details/81543096?utm_source=blogxgwz1 1.2.1 设置当前文件缩进 https://blog.csdn.net/qq_34446663/article/details/88184680 1、点击文件右下角的Tab Size:，会出现一个选择框。 2、点击Indent Using Tabs 3、根据需求，选择自己需要的缩进 1.3 关闭文件预览 单击文件名的缘故，这个是“预览模式”，所以再单击其他文件时，会覆盖当前打开的文件。 预览模式是现在各类编辑器的默认功能，如果你实在不喜欢，可以关掉的,给你配置settings.json里加一条： \"workbench.editor.enablePreview\": false, 1.4 react中可以使用emmet 在配置文件中加入下面代码： \"emmet.syntaxProfiles\": { \"javascript\": \"jsx\" }, 1.5 关闭右侧缩略图（预览面板） 设置里面搜索 \"editor.minimap.enabled\"，设置为false即可。 配置文件中： // Controls if the minimap is shown 关闭右侧缩略图（预览面板） \"editor.minimap.enabled\": false, 1.6 编辑区域面板拆分 右上角 View -> Editor Layout -> 即可选择编辑区域拆分 还可以点击编辑器右上角的拆分按钮，默认垂直拆分， 键盘按住alt键，然后点击此时可水平拆分。 1.7 前端vue相关配置 1.7.1 设置.vue文件HTML模板中emmet支持vue特有的标签 Code -> Preferences -> Settings(快捷键command + ，)，打开配置文件。 // 2018-07-17 设置VUE在.vue的模板HTML中vue标签也可以使用emmet // 启用后，按下 TAB 键，将展开 Emmet 缩写。 \"emmet.triggerExpansionOnTab\": true, // vscode 1.25.1版本以后不写下面的配置也会生效，旧版本可能需要 \"emmet.includeLanguages\": { \"vue-html\": \"html\", \"vue\": \"html\" }, 1.8 关闭点击对应文件是，资源管理器自动定位到该文件 Code -> Preferences -> Settings(快捷键command + ，)，打开配置文件 // 控制资源管理器是否应在打开文件时自动进行显示并选择。 \"explorer.autoReveal\": false, 1.9 标题栏显示文档全路径 Code -> Preferences -> Settings(快捷键command + ，)，打开配置文件： \"window.title\": \"${activeEditorLong}${separator}${rootName}\" activeEditorMedium:相对于工作区文件夹的文件路径 (如 myFolder/myFile.txt)。 activeEditorLong:文件的完整路径 (如 /Users/Development/myProject/myFolder/myFile.txt)。 1.10 关闭编辑器的预览，免得打开新文件胡替换老的文件 Code -> Preferences -> Settings(快捷键command + ，)，打开配置文件： // 控制打开的编辑器是否显示为预览。预览编辑器可以重新使用，直到将其保留(例如，双击或编辑)。 \"workbench.editor.enablePreview\": false, 1.11 设置鼠标双击才打开文件 Code -> Preferences -> Settings(快捷键command + ，)，打开配置文件： \"workbench.list.openMode\": \"doubleClick\", 如果想改回单击打开文件，可改回参数：singleClick, 设置双击打开文件后，预览模式就不需要在设置了。 1.12 编辑器tab标签下面显示打开文件的导航 View -> toggle breadcrumbs 1.13 编辑器文字超出了编辑器可视区域，是否自动在下一行显示 Code -> Preferences -> Settings(快捷键command + ，)，打开配置文件： // Controls how lines should wrap. // - off: Lines will never wrap. // - on: Lines will wrap at the viewport width. // - wordWrapColumn: Lines will wrap at `editor.wordWrapColumn`. // - bounded: Lines will wrap at the minimum of viewport and `editor.wordWrapColumn`. \"editor.wordWrap\": \"off\", 1.14 修改vscode上终端的字体大小 1、使用cmd + ,打开设置页面，或者屏幕左上角 code -> 首选项 -> 设置。 2、搜索终端，或者 功能 -> 终端。 3、找到Integrated: Font Size，控制终端的字号，设置成自己想要的字体大小即可。 1.15 添加代码片段snippets https://www.jianshu.com/p/1f1132df1def https://segmentfault.com/a/1190000018457312 windows系统: File > Preferences > User Snippets， Mac系统：Code > Preferences > User Snippets 在出现的弹窗中，选择New Global Snippets file新建一个全局的代码，或者选择一个已经存在的代码片段继续编辑 vscode代码片段存放路径 /Users/用户名/Library/Application Support/Code/User/snippets/tt.code-snippets 例如：/Users/dragon/Library/Application Support/Code/User/snippets/tt.code-snippets 1.16 编辑代码后自动保存 vscode版本：1.46.0 打开vscode配置文件：code -> preferences -> settings(或者快捷键cmd + ,) 在setting里面，Flies: Auto Save 选择一下。 1.17 代码保存后自动格式化 在settings.json文件里面添加如下： // \"editor.formatOnType\": true, // 写这一个就可以 \"editor.formatOnSave\": true https://www.cnblogs.com/hellofangfang/p/9266752.html 1.18 代码保存后自动格式化成ESLint规范形式 如果安装了eslint插件，保存代码后，可设置自动格式化成符合eslint规范的代码，在配置文件中添加： // eslint 保存代码时自动格式化符合eslint规范 2020-06-12 \"editor.codeActionsOnSave\": { \"source.fixAll\": true, \"source.fixAll.eslint\": true }, 注意：这个配置随着eslint产检版本升级可能会变化，需要去github上查看： https://github.com/Microsoft/vscode-eslint 1.19 设置自定义代码片段在提示的最上面 在设置中搜索到editor.snippetSuggestions这个设置，其中有四个选项top、bottom、inline、none四个选项，选择top即可。 默认的选项是：inline 2. 快捷键设置 打开快捷键界面和快速找到想要修改的快捷键 打开快捷键页面： vscode菜单： Code -> Preferences -> Keyboard Shortcuts , 打开快捷键界面。 快速找到要修改的快捷键 在搜索中输入相关关键词 查看快捷键是否已经被占用 在搜索中输入快捷键： 比如想要查看'cmd + /'快捷键是否已经被占用，则在搜索框中输入：\"cmd + /\" 如果有结果就说明该快捷键已经被占用了 shift、control(ctrl)、option(alt)、command(cmd) 2.1 复制一行快捷键自定义：command + D 在搜索框中输入： copy, 找到Copy Line Down向下复制一行快捷键，修改为自己习惯的快捷键：command + D。 2.2 格式化代码快捷键： option + cmd + L 在搜索框中输入：format, 找到Format Document格式化文档，修改为自己的快捷键：control + alt + L，默认的快捷键：shift + alt + F. 2.3 格式化选中的代码快捷键：cmd + L 在搜索框中输入： formatSelection(格式化选定代码)， 可以修改成自己的快捷键 2.4 删除一行快捷键： command + delete 在搜索框中输入：delete, 找到Delete Line删除一行，修改为自己的快捷键：command + delete，默认的快捷键：shift + command + K. 2.5 将选择添加到下一个查找匹配项(Add Selection To Next Find Match) 在快捷键页面搜索框中输入：Add Selection To Next(将选择添加到下一个)事件的默认快捷键：cmd + D 2.6 切换编辑器组布局(垂直/水平): option + cmd + 数字零 关键字：toggleEditorGroupLayout 2.7 当前行向上移动一行： option + 向上箭头 关键字 ： moveLinesUpAction 2.8 当前行向下移动一行： option + 向下箭头 关键字： moveLinesDownAction 2.9 当前行缩进 关键字：indentLines 设置的快捷键: cmd + ] 2.10 减少行缩进 关键字：outdentLines 设置的快捷键： cmd + [ 3. vscode一些快捷操作 3.1 变量重命名：选中后按F2 可以选中后按F2，输入新的名字，回车，会发现所有的文件都修改过了。 4. vscode的一些插件 安装离线插件 由于有的电脑环境不能连接互联网，可以通过安装离线包方式安装插件。 获取离线插件包 在线搜索插件：https://marketplace.visualstudio.com/vscode，或者在vscode插件中，找到插件，然后点击插件名字会直接跳转到插件的网址。 在出现的插件页面中，点击Download Extension 按钮，下载离线包： 安装离线插件 1、打开vscode编辑器，点击插件部分。 2、在搜索框右边的上面有三个点，点击。 3、在出现的弹窗中，选择Install from VSIX...选项。 4、在出现的弹窗中，选择插件离线包所在的目录，选择需要安装的插件，然后点击install按钮进行安装。 4.1 ESLint: JavaScript代码格式化检查插件 ESLint 插件， 插件github地址：https://github.com/Microsoft/vscode-eslint eslint中文官网：http://eslint.cn/ airbnb规范地址：https://github.com/lin-123/javascript 如果想要在保存文件的时候，会自动把代码格式化成符合eslint风格的代码，比如把var变量自动变成let，需要在配置文件中写了如下配置： \"editor.codeActionsOnSave\": { \"source.fixAll\": true, \"source.fixAll.eslint\": true } 注意，这个配置项会随着eslint插件版本升级而改变，需要查看插件的文档来做对应修改。 这个插件生效需要项目里面有eslint配置文件，如：.eslintrc.js: module.exports = { parser: 'babel-eslint', // 规定了代码检查使用哪个规范，如airbnb extends: ['airbnb', 'prettier', 'plugin:compat/recommended'], } 如果不想代码检查某个文件，那么在配置文件里面忽略：.eslintignore： /scripts /config 一般在package.json文件里面也安装了对应包，用于命令行检查： \"eslint\": \"^5.16.0\", \"eslint-config-airbnb\": \"^17.1.0\", \"eslint-config-prettier\": \"^4.3.0\", \"eslint-plugin-babel\": \"^5.3.0\", \"eslint-plugin-compat\": \"^3.1.1\", \"eslint-plugin-import\": \"^2.17.3\", \"eslint-plugin-jsx-a11y\": \"^6.2.1\", \"eslint-plugin-markdown\": \"^1.0.0\", \"eslint-plugin-react\": \"^7.13.0\", 4.2 stylelint：CSS代码规范检查插件 stylelint 插件地址 插件github地址：https://github.com/stylelint/vscode-stylelint stylelint官网：https://stylelint.io/ stylelint规范地址：https://stylelint.io/user-guide/rules/list 中文介绍：https://segmentfault.com/a/1190000017335655 注意：这个插件有好几个同名的插件，选择图标跟stylelint官网一样的图标插件。 这个插件生效需要项目里面有stylelint的配置文件，如.stylelintrc.json { \"extends\": [ \"stylelint-config-standard\", \"stylelint-config-css-modules\", \"stylelint-config-rational-order\", \"stylelint-config-prettier\" ], \"plugins\": [\"stylelint-order\", \"stylelint-declaration-block-no-ignored-properties\"], \"rules\": { \"no-descending-specificity\": null, \"plugin/declaration-block-no-ignored-properties\": true } } 一般在package.json文件里面也安装了对应包，用于命令行检查： \"stylelint\": \"^10.0.1\", \"stylelint-config-css-modules\": \"^1.4.0\", \"stylelint-config-prettier\": \"^5.2.0\", \"stylelint-config-rational-order\": \"^0.1.2\", \"stylelint-config-standard\": \"^18.3.0\", \"stylelint-declaration-block-no-ignored-properties\": \"^2.1.0\", \"stylelint-order\": \"^3.0.0\", 4.3 适用于 VS Code 的中文（简体）语言包 Chinese (Simplified) Language Pack for Visual Studio Code 安装后，在 locale.json 中添加 \"locale\": \"zh-cn\"，即可载入中文（简体）语言包。要修改 locale.json，你可以同时按下 Ctrl+Shift+P 打开命令面板，之后输入 \"config\" 筛选可用命令列表，最后选择配置语言命令。请参阅文档并获取更多信息。 4.4 Beautify ：代码变得非常好看的格式 它可以让你的html，javascript,json,CSS,Sacc 和 html 代码变得非常好看的格式 4.4.1 Beautify css/sass/scss/less CSS格式化插件 该插件安装后，可以格式化css/sass/scss/less后缀的CSS文件， 使用VSCODE默认的格式化快捷键即可实现快速格式化 https://marketplace.visualstudio.com/items?itemName=michelemelluso.code-beautifier 4.5 GitLens supercharges : 显示每行代码GIT的提交记录 这个插件安装好后在编辑器右上角会有几个按钮 (其中有一个类似git的图标) 4.6 CSS Peek：追踪至样式表中 CSS 类和 ids 定义的地方 使用此插件，你可以追踪至样式表中 CSS 类和 ids 定义的地方。当你在 HTML 文件中右键单击选择器时，选择“ Go to Definition 和 Peek definition ”选项，它便会给你发送样式设置的 CSS 代码。 CSS peek 4.7 color info: css中颜色的其他写法 这个便捷的插件，将为你提供你在 CSS 中使用颜色的相关信息。你只需在颜色上悬停光标，就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了。 color info 4.8 Document This：自动为TSc和JS文件生成详细的JSDoc注释 “Document This”是一个Visual Studio代码扩展，可自动为TypeScript和JavaScript文件生成详细的JSDoc注释。 Document This 使用方法： 鼠标光标放在方法名前面。 按快捷键 Ctrl+Alt+D再按一次Ctrl+Alt+D，即可生成注释文档 4.9 vscode-icons:资源树目录加上图标 vscode-icons 安装手使用： Linux & Windows => File > Preferences > File Icon Theme > VSCode Icons. MacOS => Code > Preferences > File Icon Theme > VSCode Icons. 4.10 Auto Rename Tag:修改标签名称的时候自动修改结束标签 Auto Rename Tag，非常实用！要修改标签名称的时候自动修改结束标签，节省一半时间，提升效率，非常棒！ Auto Rename Tag 4.10 自动关闭标签：Auto Close Tag Auto Close Tag 自动重命名成对的HTML/XML标记，与Visual Studio IDE相同。用这个插件可以告别每次改变标签的时候要重复修改头部和尾部标签。特别是标签内内容非常多的时候，要改确实很费劲的。 4.11 open native terminal : 在右键菜单中添加打开终端 这个插件可以很方便的直接在VSCODE中打开终端操作 open native terminal 4.12 console-snippets: console.log快捷插件 console-snippets cl or clog console.log() cwarn console.warn() cdir console.dir() ci console.info() cerr console.error() cg console.group() cge console.groupEnd() 4.13 Turbo Console Log: 选中变量快捷添加console.log Turbo Console Log 使用方法： 1，选中变量， 2 按快捷键： control + option + i 注释掉有插件创建的console： control + option + q 取消注释插件创建的console：control + option + u 删除由插件创建的console: control + option + d 注：此插件的创建console与我自己的快捷键冲突了，可打开vscode的快捷键设置， 然后搜索：Turbo Console Log ， 就会出现此插件相关的快捷键，选择冲突的快捷键修改别的快捷。 4.14 Vim：让vscode像vim中一样使用命令 Vim 4.15 Bookmarks：添加标签，快速定位标记的代码 Visual Studio中的Bookmark能加速代码导航能力。可能有一些代码，需要频繁的相互切换。通常你可能是滚动页面，找到该代码块的。Visual Studio已经提供了通过使用快捷键，非常快速地移动到指定的代码段。这就是代码的书签功能。 bookmarks 可设置快捷键，打开快捷键页面（code -> Preferences -> keyboards ShortCuts） 在里面输入bookmarks就能看见相关的快捷键设置: option + cmd + k:开启关闭标签 option + cmd + L:跳到下一个标签 option + cmd + k:跳到上一个标签 还可以在编辑器左边有个书签图标，可以点击在里面管理添加的书签。 可以选一个文件，然后右键店家clear清理所有标记的标签。 4.16 Bracket Pair Colorizer:代码的各种括号呈现不同的颜色 Bracket Pair Colorizer 让代码的各种括号呈现不同的颜色。 4.17 对 webpack 别名路径或者自定义别名路径进行快速跳转的插件 Jump To Alias File https://github.com/wanfu920/jumpToAliasFile 可以对 webpack 别名路径或者自定义别名路径进行快速跳转的插件. 默认webpack配置的alias可自动识别 如果没识别 可以在setting.json里配置webpeckConfigPath或者jumpToAliasFile.alias 4.18 计算引入包的大小 Import Cost 插件会在代码import一个包后计算该包的大小 4.19 设置tab强调色 Material Theme 插件安装好后，会修改vscode编辑器主题色，可以修改回原先的主题色。 修改打开标签页下划线颜色： 打开命令面板(cmd + shift + P)，输入Material，选择Material Theme: Set accent color，然后从出现的列表中选择一个颜色，它将更改选项卡的下划线颜色。 4.20 代码缩进着色 indent-rainbow 安装此插件后，代码的每级缩进都会有不同的颜色，便于区分代码块。 安装此插件即可，不需要进行任何配置。你也可以自己修改缩进的颜色，看介绍文档配置。 4.21 Settings Sync: 同步vscode设置及扩展配置 Settings Sync 实现同步的功能主要依赖于VSCode插件“Settings Sync”。它是基于 GitHub Tokens 和 GitHub Gist 功能实现，可以一键轻松实现上传下载跨多台机器同步设置、代码片段、主题、文件图标、启动、键绑定、工作区和扩展。 配置存在：https://gist.github.com/ 4.22 Path Intellisense:路径只能提示 Path Intellisense 加入此插件让我们在应用文件（例如图片）时，有智能的路径提示。 4.23 HTML CSS Support: html中css类补全 HTML CSS Support 补充了VSCode中缺少的CSS支持。类属性补全、ID属性补全和全文件搜索CSS和SCSS提示等。 4.24 代码翻译：翻译(英汉词典) 翻译(英汉词典) 英语不是很好的童鞋，在写代码的时候经常会使用“某道翻译”，但是其实对于代码来说，很多时候我们会用驼峰、小驼峰、下划线等等写法来写变量名、属性名、类名和方法名的。这种写法想使用“某道翻译”在编辑器中悬浮翻译就是不可能了。 找了很久我为大家找到一个非常好用的一个插件可以解决这个问题！ 本地77万词条英汉词典，不依赖任何在线翻译API，无查询次数限制。可翻译驼峰和下划线命名，及对整个文件中的标识符批量翻译。 安装好后，在vscode底部的状态栏中会出现翻译 4.25 Code Spell Checker:英文单词拼写错误检查 Code Spell Checker 一个基本的拼写检查器，可以检测驼峰写法。这个拼写检查程序的目标是帮助捕获常见的拼写错误。在编写代码的时候，我们都是用英文单词，很多时候我们都会写错单词的可能性。用错了单词其实对于维护性是有一定的影响的。 使用有意义的单词做为方法名、类名和变量名会给自己代码更多的意义和含义。当自己或者别人去查看代码时更容易懂其中的用意。但是如果我们拼错了单词，有些时候就无法理解这个单词是什么意思了。 所以这个插件对我们来说非常实用，就算是老外都非常多人在使用它。（目前有100多万下载量） 4.26 同步你的VSCode设置及扩展插件，换机不用愁 https://segmentfault.com/a/1190000020894066 4.27 AI编程工具：TONGYI Lingma 通义灵码最全使用指南：https://developer.aliyun.com/article/1605527 在vscode插件里面搜索：TONGYI Lingma。点击下载后，需要登陆账号，登陆阿里云的账号就可以 5. VUE框架相关的插件 5.1 vetur：语法高亮插件 5.2 Vue VSCode Snippets: vue模板 安装此插件后，在.vue文件中 输入vbase然后按tab键可以快速生成一个vue项目的模板。其他的请看文档 Vue VSCode Snippets 6. 使用vscode遇到的问题 6.1 html文件使用快捷键注释不对 当在HTML文件中，使用注释快捷键cmd + /，时注释的代码是下面这样子的： {# #} 这个是错误的。 1、首先查看编辑器右下角看看是不是HTML格式的，然后在看看配置等。 2、经过我的查找是由于使用了插件导致的，插件名字：TWIG pack,禁用这个插件后，再次使用快捷键注释就好了： --> 6.2 保存时，自动把var变量改成了let 在打开代码文件时，修改后，保存后，发现编辑器把var变量自动改成了let，导致旧浏览器出现了兼容性问题。 经过查询： 安装了eslint插件 在配置文件里面配置了\"eslint.autoFixOnSave\": true, 安装了eslint插件并配置了参数后， 在保存文件的时候，就会自动把不符合eslint格式的代码自动改成符合eslint要求的代码，所以就把var改成了let，导致了旧浏览器出现了兼容性问题。 解决方法： 在配置文件中注销或删除配置：\"eslint.autoFixOnSave\": true,即可。 6.3 vue代码格式化方式不对 经过查找，发现.vue文件代码格式化时使用了Vetur形式，经过过查找，发现可使用Prettier来格式化代码，可以安装Prettier插件，然后在vscode编辑器会提示使用哪种工具来格式化代码，此时要选择Prettier，如果不小心还是选择了Vetur，那么可找到这个插件，然后先禁用掉，然后回到代码中，在格式化，编辑器会从新然呢选择格式化工具，此时可再次选择Prettier。 Prettier支持配置文件，在项目根目录下，.prettierrc.js: module.exports = { \"semi\":false, \"singleQuote\": true, \"printWidth\": 80 } 那么格式化会按照这个配置文件来做。 6.4 vue使用iView时标签报错 Parsing error: x-invalid-end-tag 法规 当使用iview中的Input标签时，报Parsing error: x-invalid-end-tag.eslint-plugin-vue 错误。 原因： iView将标签渲染为原生html标签时，由于这些标签是自闭合的，所以有end标签会报错。 解决方案： 修改eslint配置文件，添加一行： 'vue/no-parsing-error': [2, { 'x-invalid-end-tag': false }], 如果还不行，尝试下面修改： 这是vetur中eslint的问题，在vscode菜单中，文件->首选项->设置， 找到 “vetur.validation.template”: true 将其改为false，就可关闭eslint的检查，错误消失。 参考资料：vscode 解决 iview 报错 6.5 Could not create temporary directory: Permission denied 当点击vscode的Check for Updates选项来升级软件时，在编辑器的右下角出现了提示： Could not create temporary directory: Permission denied 发现由于没有权限，导致升级失败，经过查找使用如下命令删除两个vscode的临时文件即可： sudo rm -Rf ~/Library/Caches/com.microsoft.VSCode.ShipIt sudo rm -Rf ~/Library/Caches/com.microsoft.VSCodeInsiders.ShipIt 在输入管理员密码后，在执行更新就发现没问题了。 6.6 安装离线插件失败，有兼容性问题 当安装离线插件的时候，会报如下错误： Unable to install extension 'eamodio.gitlens'as it is not compatible with VS Code '1.52.1'. 经过尝试，安装插件的历史版本也会报同样的错误。 解决方法：卸载vscode，安装最新版本的vscode软件后，在安装离线插件就能成功安装了。 6.7 Prettier格式化vue中html代码问题 在使用Prettier格式化vue中的html代码的时候，标签结束符号会单独到一行中，经过查找资料，发现需要在Prettier配置文件中添加： module.exports = { // \"singleQuote\": true, // 字符串使用 单引号 \"printWidth\": 100, // 每行最多 100个字符 \"htmlWhitespaceSensitivity\": \"ignore\" // 解决html中元素标签结束标志(>)单独一行问题 } https://zhuanlan.zhihu.com/p/64627216 其他插件资料 https://zhuanlan.zhihu.com/p/27905838 vscode 插件推荐 - 献给所有前端工程师 segmentfaul powered by Gitbook文件最后修改时间： 2024-11-27 18:41:36 "},"doc/mac/008-Mac下vscode快捷键.html":{"url":"doc/mac/008-Mac下vscode快捷键.html","title":"Mac下vscode快捷键","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. Mac 键盘符号说明 2. 常用 3. 基本编辑 4. 多光标和选择 5. 搜索和替换 6. 丰富的语言编辑 7. 导航 8. 编辑器管理 9. 文件管理 10. 显示 11. 调试 12. 集成终端 参考资料 [TOC] 1. Mac 键盘符号说明 ⌘ == Command ⇧ == Shift ⇪ == Caps Lock ⌥ == Option ⌃ == Control ↩ == Return/Enter ⌫ == Delete ⌦ == 向前删除键（Fn+Delete） ↑ == 上箭头 ↓ == 下箭头 ← == 左箭头 → == 右箭头 ⇞ == Page Up（Fn+↑） ⇟ == Page Down（Fn+↓） Home == Fn + ← End == Fn + → ⇥ == 右制表符（Tab键） ⇤ == 左制表符（Shift+Tab） ⎋ == Escape (Esc) ⏏ == 电源开关键 2. 常用 描述 Mac 快捷键 显示命令面板 ⇧⌘P, F1 快速打开 ⌘P 新建 窗口/实例 ⌘N(之前的：⇧⌘N) 关闭 窗口/实例 ⌘W 侧边栏开关 command + B 控制台开关 command + J 合并当前行 control + J 整个项目搜索内容 command + shift + F 创建分屏快捷键 command + \\ 批量替换当前文件中所有匹配的文本 command + F2 复制光标向上或向下批量添加内容 option + command + 上下箭头 切换tab显示 option + command + 左右箭头 3. 基本编辑 Mac 快捷键 介绍 ⌘X 剪切 ⌘C 复制 ⌥↓ / ⌥↑ 移动当前行向 下/上 ⇧⌥↓ / ⇧⌥↑ 复制当前行向 下/上 ⇧⌘K 删除当前行 ⌘Enter / ⇧⌘Enter 在下/上 插入一行 ⇧⌘\\ 跳转到匹配的括号 ⌘] / ⌘[ 向左/向右 缩进当前行 Home / End 跳到当前行的头部，尾部 ⌘↑ / ⌘↓ 跳到当前行的开始，结束 ⌃PgUp 滚动到 ⌃PgDown 滚动到行头/行尾 ⌘PgUp /⌘PgDown 滚动到页头/页尾 ⇧⌘[ / ⇧⌘] 折叠/展开区域 ⌘K ⌘[ / ⌘K ⌘] 折叠/展开所有子区域 ⌘K ⌘0 / ⌘K ⌘J 折叠/展开所有区域 ⌘K ⌘C 添加行注释 ⌘K ⌘U 删除行注释 ⌘/ 切换行注释 ⇧⌥A 切换块注释 ⌥Z 切换文字换行 4. 多光标和选择 Mac 快捷键 介绍 Alt+Click 插入光标 ⌥⌘↑ 在上面插入光标 ⌥⌘↓ 在下面插入光标 ⌘U 撤消上一个光标操作 ⇧⌥I 在所选每行的末尾插入光标 ⌘I 选择当前行 ⇧⌘L 选择当前选择的所有事件 ⌘F2 选择当前单词的所有出现 ⌃⇧⌘→ 展开选择 ⌃⇧⌘← 收缩选择 Shift+Alt + drag mouse（拖动鼠标） 列（框）选择 ⇧⌥⌘↑ 向上列（框）选择 ⇧⌥⌘↓ 向下列（框）选择 ⇧⌥⌘← 向左列（框）选择 ⇧⌥⌘→ 向右列（框）选择 ⇧⌥⌘PgUp 列（框）选择 向上一页 ⇧⌥⌘PgDown 列（框）选择 向下一页 5. 搜索和替换 Mac 快捷键 介绍 ⌘F 查找 ⌥⌘F 替换 ⌘G / ⇧⌘G 查找下一个/上一个 ⌥Enter 选择查找匹配的所有匹配项 ⌘D 将选择添加到下一个查找匹配 ⌘K ⌘D 将最后一个选择移至下一个查找匹配项 6. 丰富的语言编辑 Mac 快捷键 介绍 ⌃Space 触发建议 ⇧⌘Space 触发参数提示 Tab Emmet扩展缩写 ⇧⌥F 格式化文档 ⌘K ⌘F 格式选择 F12 转到定义 ⌥F12 Peek定义 ⌘K F12 打开定义到一边 ⌘. 快速修复 ⇧F12 显示引用 F2 重命名符号 ⇧⌘. / ⇧⌘, 替换为下一个/上一个值 ⌘K ⌘X 修剪尾随空格 ⌘K M 更改文件语言 7. 导航 Mac 快捷键 介绍 ⌘T 显示所有符号 ⌃G 转到行… ⌘P 转到文件… ⇧⌘O 转到符号… ⇧⌘M 显示问题“面板” F8 / ⇧F8 转到下一个/上一个错误或警告 ⌃⇧Tab 浏览编辑器组历史记录 ⌃- / ⌃⇧- 后退/前进 ⌃⇧M 切换选项卡移动焦点 8. 编辑器管理 Mac 快捷键 介绍 ⌘W 关闭编辑窗口 ⌘K F 关闭文件 ⌘\\ 拆分编辑窗口 ⌘1 / ⌘2 / ⌘3 聚焦到第1，第2，第3编辑器组中 ⌘K ⌘← / ⌘K ⌘→ 聚焦到上一个/下一个编辑器组 ⌘K ⇧⌘← / ⌘K ⇧⌘→ 向左/向右移动编辑器 ⌘K ← / ⌘K → 移动活动编辑器组 9. 文件管理 Mac 快捷键 介绍 ⌘N 新建文件 ⌘O 打开文件 ⌘S 保存 ⇧⌘S 保存为… ⌥⌘S 保存所有 ⌘W 关闭 ⌘K ⌘W 关闭所有 ⇧⌘T 重新打开已关闭的编辑器 ⌘K 输入保持打开 ⌃Tab / ⌃⇧ 选项卡打开下一个/上一个 ⌘K P 复制活动文件的路径 ⌘K R 在资源管理器中显示活动文件 ⌘K O 在新窗口/实例中显示活动文件 10. 显示 Mac 快捷键 介绍 ⌃⌘F 切换全屏 ⌥⌘1 切换编辑器布局 ⌘= / ⇧⌘- 放大/缩小 ⌘B 切换侧栏可见性 ⇧⌘E 显示资源管理器/切换焦点 ⇧⌘F 显示搜索 ⌃⇧G 显示Git ⇧⌘D 显示Debug ⇧⌘X 显示扩展名 ⇧⌘H 在文件中替换 ⇧⌘J 切换搜索详细信息 ⇧⌘C 打开新命令提示符/终端 ⇧⌘U 显示输出面板 ⇧⌘V 切换Markdown预览 ⌘K V 打开Markdown预览到一边 11. 调试 Mac 快捷键 介绍 F9 切换断点 F5 开始/继续 F11 / ⇧F11 跳进/出 F10 跳过 ⇧F5 暂停 ⌘K ⌘I 显示悬停 12. 集成终端 Mac 快捷键 介绍 ⌃` 显示集成终端 ⌃⇧` 创建新终端 unassigned（末分配） 复制选择 unassigned（末分配） 粘贴到活动终端 ⌘↑ 向上滑动 ⌘↓ 下身滑动 PgUp 向上滚动页面 PgDown 向下滚动页面 ⌘Home 滚动到顶部 ⌘End 滚动到尾部 参考资料 VScode官网 快捷键 Mac 版 Visual Studio Code 快捷键 Mac 版 CSDN https://code.visualstudio.com/docs/getstarted/keybindings powered by Gitbook文件最后修改时间： 2021-01-14 21:12:51 "},"doc/mac/009-Mac-Office2016使用设置.html":{"url":"doc/mac/009-Mac-Office2016使用设置.html","title":"Mac-Office2016使用设置","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. 阅读视图 2. 找出标尺工具 [TOC] 1. 阅读视图 视图->侧栏->导航 就可以了 https://www.zhihu.com/question/35087715 2. 找出标尺工具 视图 -> 标尺view -> ruler powered by Gitbook文件最后修改时间： 2021-03-11 14:28:31 "},"doc/mac/010-Mac下Nginx的安装运行.html":{"url":"doc/mac/010-Mac下Nginx的安装运行.html","title":"Mac下Nginx的安装运行","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 一. 安装Nginx 二. 配置Nginx配置文件 三. Nginx的一些命令 1. Nginx自己的命令 2. 使用brew services 命令 四. Nginx一些常见错误 参考链接 [TOC] 一. 安装Nginx 打开终端 ~ brew install nginx 安装好后，默认HTML文件存放路径： /usr/local/var/www 这个路径重定向到了: /usr/local/Cellar/nginx/1.12.1/html nginx的安装路径： /usr/local/Cellar/nginx/1.12.1 二. 配置Nginx配置文件 根据安装的提示，配置文件的路径：/usr/local/etc/nginx/nginx.conf打开文件编辑里面的内容： user nginx; worker_processes 1; #error_log /var/log/nginx/error.log warn; #pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; #access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; server { listen 8080; #服务的端口号 server_name localhost; location / { root /www/cloudlink; #访问的项目目录 index index.html index.htm; #访问的文件名 } location ^~ /cloudlink/v1/ { proxy_pass http://192.168.100.92:8050/; #项目需要的代理地址 } location ^~ /cloudlink/zipkin/ { proxy_pass http://192.168.100.90:9411/; #项目需要的代理地址 } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } 保存后从新加载配置文件： nginx -s reload 三. Nginx的一些命令 1. Nginx自己的命令 # 打开终端运行命令 ~ nginx # 启动Nginx # 执行该命令之后，nginx 会在 /usr/local/var/run/ 路径下创建一个名为nginx.pid 的文件 ~ nginx -s reload # 重新加载配置 # 执行该命令之后，nginx会重新启动，但前提是/usr/local/var/run/ 路径下必须存在 nginx.pid 文件 ~ nginx -s reopen # 重启 ~ nginx -s stop # 停止 # 执行该命令之后，nginx 会将 /usr/local/var/run/ 路径下名为nginx.pid 的文件删除掉。但前提是/usr/local/var/run/ 路径下必须存在 nginx.pid 文件 ~ nginx -s quit # 退出 nginx ~ nginx -V # 查看版本，以及配置文件地址 ~ nginx -v # 查看版本 ~ nginx -c filename # 指定配置文件 ~ nginx -h # 帮助 ~ nginx -t # 测试配置是否有语法错误 2. 使用brew services 命令 # brew services [-v|--verbose] [list | run | start | stop | restart | cleanup] [...] ~ brew services start nginx # 启动Nginx服务 ~ brew services stop nginx # 停止Nginx服务 ~ brew services restart nginx # 重启Nginx服务 四. Nginx一些常见错误 1、重启nginx 报错 ~ sudo nginx -s reload nginx: [error] open() \"/usr/local/var/run/nginx.pid\" failed (2: No such file or directory) 出现该问题的原因是没有nginx.pid 这个文件, 解决方法：重启一下Nginx就好了。 2、启动nginx报错 ~ nginx nginx: [emerg] bind() to 0.0.0.0:80 failed (48: Address already in use) nginx: [emerg] bind() to 0.0.0.0:80 failed (48: Address already in use) nginx: [emerg] bind() to 0.0.0.0:80 failed (48: Address already in use) nginx: [emerg] bind() to 0.0.0.0:80 failed (48: Address already in use) nginx: [emerg] bind() to 0.0.0.0:80 failed (48: Address already in use) nginx: [emerg] still could not bind() 出现该问题的原因是/usr/local/var/run/nginx.pid 文件已经存在，也就是说nginx已经启动了，再次执行启动nginx，就会出现这种问题了，接口被占用了 解决方法：重启nginx，而不是启动nginx 参考链接 http://www.jianshu.com/p/918eb337a206 http://blog.csdn.net/dracotianlong/article/details/21817097 powered by Gitbook文件最后修改时间： 2021-05-19 17:26:12 "},"doc/mac/011-Mac下sublime编辑器设置.html":{"url":"doc/mac/011-Mac下sublime编辑器设置.html","title":"Mac下sublime编辑器设置","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1、安装Package Control 2、sublime 使用Package Control安装插件 3、删除插件、更新插件 4、查看已经安装了哪些插件 5、一些包插件 Vue Syntax Highlight : VUE语法高亮，并且智能提示 Terminal：直接在sublime里面打开终端插件 6、sublime快捷键 7、修改sublime默认快捷键 8、编辑中一些快捷操作 9、sublime设置可以执行JS文件 [TOC] 1、安装Package Control 在安装之前需要自导sublime的版本，打开finder，按快捷键shift + command + .显示隐藏文件，选择用户下的资源库，选择Application Support 文件夹，在里面找到sublime Text 3 文件夹，看名字就只到是哪个版本的了。 安装Package Control参考链接： https://packagecontrol.io/installation 打开sublime，按ctrl+`` 快捷键，或者在菜单栏：View -> Show Console`打开控制台。 复制下面代码回车 import urllib.request,os,hashlib; h = '6f4c264a24d933ce70df5dedcf1dcaee' + 'ebe013ee18cced0ef93d5f746d80ef60'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) 检查是否安装成功：Sublime Text -> Preferences -> Package Control 点击Preferences。如果安装成功了，Package Settings 、Package Control会出现在菜单里了。安装参考链接：https://jingyan.baidu.com/article/455a99508b7ccda1662778e0.html 2、sublime 使用Package Control安装插件 使用快捷键shift + command + p或 Sublime Text -> Preferences -> Package Control打开Package Control 输入Install Package，选择安装包。 输入需要安装的包名，在出来的选项中找到包，点击后，会自动安装，安装进度看sublime左下角的进度提示 包的安装路径:/Users/dragon/Library/Application Support/Sublime Text 3/Installed Packages 3、删除插件、更新插件 使用快捷键shift + command + p或 Sublime Text -> Preferences -> Package Control打开Package Control 删除插件 在Package Control 中 输入Remove Package选择Package Cont:Remove Package 在里面选择需要的删除插件名字，点击即可删除 更新插件 在Package Control 中 输入upgrade packages选择Package Cont:Upgrade/Overwrite All Packages 4、查看已经安装了哪些插件 使用快捷键shift + command + p打开Package Control 输入package，选择list packages 在显示的列表中就是已经安装的package了 在Mac中sublime插件的存放位置： # 第一个 /Users/[用户名]/Library/Application Support/Sublime Text 3/Installed Packages # 第二个 /Users/[用户名]/Library/Application Support/Sublime Text 3/Packages # 如：里面的插件 Terminal /Users/[用户名]/Library/Application Support/Sublime Text 3/Packages/Terminal 5、一些包插件 Typescript Syntax: typescript语法 SublimeLinter：代码校验插件，支持 HTML、CSS、JS、PHP、Java、C++ 等16种语言； Alignment：代码对齐插件； Git：整合 Git 功能的插件； BracketHighlighter： 括号高亮匹配 emmet: HTML 中使用CSS样式语法，然后使用 tab键直接生成对应html元素 Vue Syntax Highlight : VUE语法高亮，并且智能提示 Terminal：直接在sublime里面打开终端插件 安装好插件后， 在sublime上选择一个文件，右键 -> Open Terminal Here，即可在终端打开这个文件。 Mac系统中，该命令的快捷键：shift+command+t. 6、sublime快捷键 cmd + K cmd + B //显示隐藏侧边栏 (文件目录) // View -> layout -> option + cmd + 1 // 编辑器与单屏显示编辑 option + cmd + 2 // 分2屏显示编辑 option + shift + cmd + 2 // 分2个水平屏编辑 7、修改sublime默认快捷键 参考链接： https://blog.csdn.net/xuchao2015/article/details/52556927 打开sublime，左上角：sublime Text -> Preferences -> Key Bindings, 打开修改快捷键文件。 文件左边内容类似于： [ { \"keys\": [\"super+shift+n\"], \"command\": \"new_window\" }, { \"keys\": [\"super+shift+w\"], \"command\": \"close_window\" }, { \"keys\": [\"super+o\"], \"command\": \"prompt_open\" }, { \"keys\": [\"super+shift+t\"], \"command\": \"reopen_last_file\" }, ] keys里面是快捷键，command里面是快捷键说明。 up down right left insert home end pageup pagedown backspace delete tab enter shift ctrl alt super (这个就是win键, mac上是commond键) 找到需要修改的快捷键，然后在右边修改： [ // { \"keys\": [\"super+shift+d\"], \"command\": \"duplicate_line\" }, { \"keys\": [\"super+d\"], \"command\": \"duplicate_line\" }, // 复制一行 { \"keys\": [\"ctrl+alt+l\"], \"command\": \"reindent\" }, // 格式化代码 ] 8、编辑中一些快捷操作 从编辑器中打开finder， 编辑器打开一个文件，在编辑区右键 -> Reveal in Finder,即可在finder中显示这个文件。 9、sublime设置可以执行JS文件 需要安装JS运行环境nodejs 如果没有安装nodejs，需要安装nodejs nodejs中文网 在sublime中一次打开：Tools > Build System > New Build System...或者中文工具>编译系统>新编译系统 ，粘贴下面代码： { \"cmd\": [\"node\", \"$file\"], \"selector\": \"source.js\" } 保存文件名为：Node.sublime-build, # 该文件在Mac下的路径 /Users/用户名/Library/Application Support/Sublime Text 3/Packages/User # 如果需要修改，可再次打开这个文件修改。 cd ~/Library/Application\\ Support/Sublime\\ Text\\ 3/Packages/User 新建js文件，直接ctrl+b，就可以在控制台输出结果了，停止运行使用ctrl + c 参考资料： Sublime Text内运行javascript(ES6) 在sublime text3里面直接运行js CSDN powered by Gitbook文件最后修改时间： 2021-05-19 17:30:08 "},"doc/mac/012-Mac下移动硬盘分区用做TimeMachine的备份.html":{"url":"doc/mac/012-Mac下移动硬盘分区用做TimeMachine的备份.html","title":"Mac下移动硬盘分区用做TimeMachine的备份","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. 说明 2. 格式化移动硬盘 3. 分区 3.1 分 Mac格式的区 3.2 分 win下格式的区 4. TimeMachine 5. 关于硬盘的文件格式 [TOC] 1. 说明 新买了一块移动硬盘打算做存储和苹果系统的备份用，苹果系统的备份需要苹果系统的专用格式，如果单独买一块用于苹果系统备份不划算，所以买了一块容量2TB的移动硬盘分区成2块，一块用存储，一块用备份，完美。之前在Windows电脑上先分区，然后在Mac下把其中一个区格式化成苹果格式，但是这种方法imeMachine不识别。在网络上找了一些资料，看见了下面的介绍：http://www.jianshu.com/p/5f8b4d9a8922 原来在window下面把移动硬盘分区后，在Mac下TimeMachine备份磁盘中是找不到的，只有在Mac下把硬盘格式化后在分区，TimeMachine才能识别出分区的2块盘，上面链接的教程现在操作有点改变，现在记录一下（Mac系统： macOS High Sierra 10.13.2）： 2. 格式化移动硬盘 打开commmand+空格打开你的Spotlight，搜索disk Utility.app,也就是苹果的磁盘工具， 点击左上角的显示，选择显示所有设备(Show All Devices)。 在左边外置中选择移动硬盘， 右键抹掉(Erase)，在出现的弹窗中： 名称可以忽略 格式选择`Mac OS 扩展（日志式）` 方案选择`GUID 分区图` 然后点击抹掉，等一会就完成了格式化。 ​ 3. 分区 3.1 分 Mac格式的区 右键移动硬盘，选择分区(Partition device)： 名称： Mac格式磁盘 格式：Mac OS 扩展（日志式） 大小： 填写合适的大小 然后点一下左边饼图下面的 加号，然后点击应用等一会就可以了。 3.2 分 win下格式的区 步骤与上面的一样， 但是在格式里面选择Windows NT 文件系统(Tuxera NTFS) 其它的一样。等一会就可以了 经过上面的操作后，就能在Mac电脑里TimeMachine里识别出分区的2块盘了 4. TimeMachine 打开系统偏好设置，点击TimeMachine，选择那个你刚刚分区成功容量为300GB格式为MAC OS X的硬盘，经过蛮久的等待，就备份成功喽， ​ 5. 关于硬盘的文件格式 exfat格式：mac、windows、android 都能够读取的格式，这个格式的硬盘，每个系统都是可以直接读取，不会影响硬盘读取速度。 NTFS格式：window系统专用格式， 如果固态硬盘使用了这个格式，由于mac电脑不支持这种格式，使用第三方软件支持读写(tuxerantfs)，那么会影响固态硬盘的读写速度，比如固态硬盘正常读(1000MB/s)、写(1000MB/s), 修改硬盘为NTFS格式后，读(192MB/s)、写(386MB/s)，原因是，这个格式读写要经过第三方软件转化，使得速度变慢了，而在window系统里面则不会影响速度。 所以如果是固态硬盘，那么建议文件格式写成EXFAT格式，以免影响文件读写速度。机械硬盘不受影响(机械硬盘速度慢)。 powered by Gitbook文件最后修改时间： 2023-05-17 15:34:36 "},"doc/mac/013-Mac下angular开发环境安装.html":{"url":"doc/mac/013-Mac下angular开发环境安装.html","title":"Mac下angular开发环境安装","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. install node 2. 编辑器安装 VScode免费 [TOC] 1. install node # 需要事先安装好 brew ~ brew install node ~ npm -v ~ node -v # 使用brew安装的node版本太高了，告知angular2 里面`.sass`文件`node-sass`包不兼容 # 卸载node最新版本 brew uninstall node # node官网： https://nodejs.org/en/download/ 打开网站选择 LTS 版本的。下载mac版本的，然后店家安装 2. 编辑器安装 VScode免费 下载地址： https://code.visualstudio.com/选择一个Mac版本的，下载后，解压，把程序拖到 应用程序目录中. 一些angularJS开发需要安装的插件：Add Angular2 Files : https://marketplace.visualstudio.com/items?itemName=sebastianbaar.vscode-add-angular2-filesAngular 2, 4 and upcoming latest TypeScript HTML Snippets : https://marketplace.visualstudio.com/items?itemName=UVBrain.Angular2Angular ES6 snips : https://marketplace.visualstudio.com/items?itemName=kasperkeso.es6-angular-snipsAngular Files : https://marketplace.visualstudio.com/items?itemName=alexiv.vscode-angular2-filesAngular v4 TypeScript Snippets : https://marketplace.visualstudio.com/items?itemName=johnpapa.Angular2angular2-useful-dev-extensions : https://marketplace.visualstudio.com/items?itemName=boastr.angular2-useful-dev-extensionsAtom One Dark Theme: https://marketplace.visualstudio.com/items?itemName=freebroccolo.theme-atom-one-darkAuto Import : https://marketplace.visualstudio.com/items?itemName=steoates.autoimportAutolinting for Javascript : https://marketplace.visualstudio.com/items?itemName=t-sauer.autolinting-for-javascriptbackground : https://marketplace.visualstudio.com/items?itemName=shalldie.backgroundClass autocomplete for HTML : https://marketplace.visualstudio.com/items?itemName=AESSoft.aessoft-class-autocompleteCSS Auto Prefix : https://marketplace.visualstudio.com/items?itemName=sporiley.css-auto-prefixCSS Peek : https://marketplace.visualstudio.com/items?itemName=pranaygp.vscode-css-peekDark+ Material : https://marketplace.visualstudio.com/items?itemName=vangware.dark-plus-materialEmber JS (ES6) and Handlebars code snippets : https://marketplace.visualstudio.com/items?itemName=phanitejakomaravolu.EmberES6SnippetsExtension Manifest Editor : https://marketplace.visualstudio.com/items?itemName=ms-devlabs.extension-manifest-editorFile Peek : https://marketplace.visualstudio.com/items?itemName=abierbaum.vscode-file-peekFlatland_Dark Theme : https://marketplace.visualstudio.com/items?itemName=gerane.Theme-FlatlandDarkHTML CSS Class Completion : https://marketplace.visualstudio.com/items?itemName=Zignd.html-css-class-completionHTML CSS Support : https://marketplace.visualstudio.com/items?itemName=ecmel.vscode-html-cssHTML SCSS Support : https://marketplace.visualstudio.com/items?itemName=P-de-Jong.vscode-html-scssHTML Snippets : https://marketplace.visualstudio.com/items?itemName=abusaidm.html-snippetsJavaScript (ES6) code snippets : https://marketplace.visualstudio.com/items?itemName=xabikos.JavaScriptSnippetsJavaScript snippets for Dynamics 365/CRM 2011/2013/2015/2016 : https://marketplace.visualstudio.com/items?itemName=JLattimer.dynamics-crm-jsJS-CSS-HTML Formatter : https://marketplace.visualstudio.com/items?itemName=lonefy.vscode-JS-CSS-HTML-formatterJSFiddle Like Syntax Theme : https://marketplace.visualstudio.com/items?itemName=davidmart.theme-jsfiddle-like-syntax-vscode powered by Gitbook文件最后修改时间： 2021-05-19 17:16:11 "},"doc/mac/014-Mac-install-RVM,ruby,pqadmin3,rubymine2016.html":{"url":"doc/mac/014-Mac-install-RVM,ruby,pqadmin3,rubymine2016.html","title":"Mac-install-RVM,ruby,pqadmin3,rubymine2016","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. install RVM 2. rubymine 2017安装 3. Mac install pgadmin3 [TOC] 1. install RVM 1.未装homebrew先装homebrew，否则报错： $ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 如果有安装homebrew，但是在后面的ruby安装过程中出现如下错误,有可能是你更新mac系统造成的，我是通过卸载重装homebrew来解决这个问题的. $ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\" $ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 2.安装rvm $ curl -L https://get.rvm.io | bash -s stable # 启用RVM $ source ~/.rvm/scripts/rvm # 检查一下是否安装正确命令 $ rvm -v # 如果出现邦本则说明安装成功 2. rubymine 2017安装 在官网下载最新安装包： https://www.jetbrains.com/ruby/download/#section=mac 下载完成安装包后，安装程序（双击打开，将左侧拖拽至右侧应用程序，默认安装）。 打开软件，在注册中选择‘License server’， 在 ‘License server address’ 中输入：http://xidea.online,然后点击Activate即可 3. Mac install pgadmin3 # 终端，已经安装了brew ，cask ~ brew search pgadmin3 Caskroom/versions/pgadmin3 ~ brew install Caskroom/versions/pgadmin3 修改数据库配置文件，允许连接 ~ vi /usr/local/var/postgres/pg_hba.conf 找到下面的内容： # IPv4 local connections: host all all 127.0.0.1/32 ident # IPv6 local connections: host all all ::1/128 ident 把ident修改为 trust 并在下面添加一行： host all all 192.168.0.0/24 trust 保存后重起数据库： # 没试过， ~ pg_ctl start -D /usr/local/var/postgres/data -l /usr/local/var/log/postgres/log.log # 停止的话把后面的start换成stop即可。 如果不想每次都指定数据目录，可以创建保存该地址的环境变量PGDATA # export PGDATA=/usr/local/var/postgres/data 查看数据库的运行： # 亲测有效 $ lsof -i:5432 powered by Gitbook文件最后修改时间： 2021-05-19 17:31:18 "},"doc/linux/001-linux下常用的终端命令.html":{"url":"doc/linux/001-linux下常用的终端命令.html","title":"linux下常用的终端命令","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. MV移动文件、重命名文件 1.1 移动文件：mv [选项] 源文件或目录 目标文件或目录 1.2 文件重命名 2. 查找：文件，内容，统计文件 2.1 find查找文件 2.2 Linux查找文件内容 3. 查看当前用户 4. linux修改文件所属用户和组 5. 复制文件：cp scp 6. centos添加用户跟组 7. centos7开机自动关闭网络,开启网络，有线设置 8. 查看文件文件夹大小* 9. linux 压缩、解压 9.1 zip压缩、解压 10. 查看当前系统版本 11. wget/curl [TOC] 1. MV移动文件、重命名文件 1.1 移动文件：mv [选项] 源文件或目录 目标文件或目录 参考链接：https://www.cnblogs.com/piaozhe116/p/6084214.html 1.2 文件重命名 linux下重命名文件或文件夹的命令mv既可以重命名，又可以移动文件或文件夹. 例子：将目录A重命名为B mv A B 例子：将/a目录移动到/b下，并重命名为c mv /a /b/c 其实在文本模式中要重命名文件或目录的话也是很简单的，我们只需要使用mv命令就可以了，比如说我们要将一个名为abc的文件重命名为1234就可以这样来写：mv abc 1234，但是要注意的是，如果当前目录下也有个1234的文件的话，我们的这个文件是会将它覆盖的 2. 查找：文件，内容，统计文件 2.1 find查找文件 $ find / -name 文件名 $ find / -name 'azure-armrest*' # 部分名字匹配 例如azure-armrest-0.3.9 # find ver1.d ver2.d -name '*.c' -print 查找ver1.d,ver2.d *.c文件并打印 # find . -type d -print 从当前目录查找，仅查找目录，找到后，打印路径名。可用于打印目录结构。 更多详细点这里 2.2 Linux查找文件内容 $ grep \"被查找的字符串\" 文件名 # 从文件内容查找匹配指定字符串的行： $ find / -type f -name \"*.log\" | xargs grep \"ERROR\" # 从根目录开始查找所有扩展名为.log的文本文件，并找出包含”ERROR”的行 更多详细点这里 3. 查看当前用户 whoami 4. linux修改文件所属用户和组 使用chown命令可以修改文件或目录所属的用户： 命令：chown 用户 目录或文件名 例如：chown qq /home/qq (把home目录下的qq目录的拥有者改为qq用户) 使用chgrp命令可以修改文件或目录所属的组： 命令：chgrp 组 目录或文件名 例如：chgrp qq /home/qq (把home目录下的qq目录的所属组改为qq组) 如果需要修改目录及子目录的权限则需要加 -R sudo chown yulilong -R local 5. 复制文件：cp scp http://www.jb51.net/LINUXjishu/70474.html Linux为我们提供了两个用于文件copy的命令，一个是cp，一个是scp，但是他们略有不同。 cp --- 主要是用于在同一台电脑上，在不同的目录之间来回copy文件 scp --- 主要是在不同的Linux系统之间来回copy文件 将档案 aaa 复制(已存在)，并命名为 bbb： cp aaa bbb 从 本地 复制到 远程 cp [options] source1 source2 source3 …. directory 上面第一条命令为单个文件或目录拷贝，下一个为多个文件拷贝到最后的目录。 options选项包括： - a 保留链接和文件属性，递归拷贝目录，相当于下面的d、p、r三个选项组合。 - d 拷贝时保留链接。 - f 删除已经存在目标文件而不提示。 - i 覆盖目标文件前将给出确认提示，属交互式拷贝。 - p 复制源文件内容后，还将把其修改时间和访问权限也复制到新文件中。 - r 若源文件是一目录文件，此时cp将递归复制该目录下所有的子目录和文件。当然，目标文件必须为一个目录名。 - l 不作拷贝，只是链接文件。 -s 复制成符号连结文件 (symbolic link)，亦即『快捷方式』档案； -u 若 destination 比 source 旧才更新 destination。 cp命令使用范例： 1、将文档 file1复制成file2，复制后名称被改file2 cp file1 file2 2、将文档 file1复制到dir1目录下，复制后名称仍未file1 cp file1 dir1 3、将目录dir1复制到dir2目录下，复制结果目录被改名为dir2 cp -r dir1 dir2 # 将web92_dev目录下的node_modules目录所有文件(包括隐藏文件) 复制到 当前目录下的 node_modules 文件夹中 cp -a /Users/dragon/web92_dev/node_modules/ ./node_modules 4、将目录dir1下所有文件包括文件夹，都复制到dir2目录下 cp -r dir1/*.* dir2 常见错误： 1、提示cp: omitting directory错误 复制目录时，使用-r选项即可递归拷贝，如下： cp -r dir1 dir2 # 从 本地 复制到 远程: 把本地的full.tar.gz 复制到远程的 /home/root目录下 scp /home/daisy/full.tar.gz root@172.19.2.75:/home/root # 从 远程 复制到 本地: scp root@172.19.2.75:/home/root/full.tar.gz /home/daisy #（然后会提示你输入另外那台172.19.2.75主机的root用户的登录密码，接着就开始copy了） # 复制目录加参数 -r 即可 # 远程/var/www/miq/vmdb 复制到当前目录下 scp -r root@192.168.100.110:/var/www/miq/vmdb ./ 6. centos添加用户跟组 http://zhidao.baidu.com/link?url=YWnbBbR1fLGrWwQ9bKROr_2A_7fotpIgs2IJA0yh7-MfDDBKf3GSsB8Hab1pn0-Q8xpBnW0rSUUOhY1jIngKlX_O3-O9q2G0uIQCsANK80e 7. centos7开机自动关闭网络,开启网络，有线设置 http://jingyan.baidu.com/article/6dad5075f3d766a123e36eaa.html $ cd /etc/sysconfig/network-scirpts $ ls $sudo vi ifcfg-eth0 修改： ONBOOT=yes 关闭 ONBOOT=no 8. 查看文件文件夹大小* [root@bsso yayu]# du -h --max-depth=1 work/testing 27M work/testing/logs 35M work/testing [root@bsso yayu]# du -h --max-depth=1 work/testing/* 8.0K work/testing/func.php 27M work/testing/logs # 查看磁盘各分区大小、已用空间等信息 $ df -h # 查看foo目录的大小： $ du -sh foo # 查看当前目录以下搜索文件和子目录大小: $ du -sh * 9. linux 压缩、解压 http://www.blogjava.net/jiangjf/archive/2007/07/29/133122.htmlhttp://blog.csdn.net/liangzhao_jay/article/details/48052913 .tar # tar命令可以用来压缩打包单文件、多个文件、单个目录、多个目录。 多个文件压缩打包 tar czvf my.tar.gz file1 file2 ...（file*）（也可以给file*文件mv 目录在压缩） 单个目录压缩打包 tar czvf my.tar.gz dir1 多个目录压缩打包 tar czvf my.tar.gz dir1 dir2 解包至当前目录： tar xzvf my.tar.gz --------------------------------------------- .rar 　　解压：rar a FileName.rar 　　压缩：r ar e FileName.rar 9.1 zip压缩、解压 将一个文件夹所有文件打包成一个压缩文件： # 显示压缩过程 zip -r -o dist.zip dist/ # 不显示压缩过程 zip -r -o -q dist.zip dist/ # 创建加密zip包，此命令需要在终端输入2次密码 zip -r -e -o password.zip dist/ # 让压缩包在window系统上也能用 zip -r -o -q -l dist.zip dist/ 上面的命令会将dist文件夹所有文件都打包到dist.zip中，其中指令参数： -r：递归处理，将指定目录下的所有文件和子目录一并处理 -o：以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同 -q：不显示压缩过程 -e：使用加密压缩，需要输入2次密码 -l：压缩文件时，把LF字符置换成LF+CR字符。 LF(Linux 中的换行), CR+LF(Carriage-Return+Line-Feed：windows 上的回车加换行) -ll：压缩文件时，把LF+CR字符置换成LF字符。 解压使用如下命令： # 默认会显示解压内容 unzip dist.zip # 不显示解压过程 unzip -q dist.zip # -d 参数将文件解压到特定文件夹中 unzip -q dist.zip -d portal 10. 查看当前系统版本 $ lsb_release -a $ cat /etc/issue 11. wget/curl http://www.cnblogs.com/dingn/p/5658442.html # Linux系统中wget是一个下载文件的工具，它用在命令行下。对于Linux用户是必不可少的工具，我们经常要下载一些软件或从远程服务器恢复备份到本地服务器。 $ wget http://place.your.url/here http://www.linuxdiyf.com/linux/2800.html # 在Linux中curl是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。 $ curl www.baidu.com # 会把百度网页元素语言显示出来 powered by Gitbook文件最后修改时间： 2021-05-20 14:43:29 "},"doc/linux/002-linux下常用软件.html":{"url":"doc/linux/002-linux下常用软件.html","title":"linux下常用软件","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. GIMP图片编辑工具，用于处理文档图片 2. 星火字典stardict [TOC] 1. GIMP图片编辑工具，用于处理文档图片 install在linux应用商店里搜索GIMP 就能出来 语言设置辑—首选项—界面—语言，在下拉列表中选择[汉语_zh-CN]，对应的英文菜单式这样的Edit-Preferences-Interface-Language-[Chinese_zh-CN] 工具选项gimp 2.0到2.4版本 工具箱菜单 文件(File)→对话框(Dialogs)→工具选项(ToolOption)gimp 2.6 用图像窗口菜单 窗口→可停靠对话框→工具选项 滤镜里面-》绘制-》几何图形，就搞定了哦 2. 星火字典stardict installhttp://bckong.blog.51cto.com/5092126/1575904/http://www.centoscn.com/image-text/install/2015/0624/5734.html sudo yum install http://puias.math.ias.edu/data/puias/6/x86_64/os/Addons/stardict-3.0.1-22.puias6.x86_64.rpm 词典的离线字典下載网站字典下载： http://download.huzheng.org/zh_CN/离线字典下载地址： http://download.csdn.net/download/love254443233/7864659下载下来解压以后，有很多的.tar.bz2的包，把包全部解压，然后把包里面的东西，记住一定要是包里面的东西，不是把包， 全部移动到 /usr/share/stardict/dic 这个文件中sudo cp stardict-lazyworm-ec-2.4.2/* /usr/share/stardict/dic/ powered by Gitbook文件最后修改时间： 2021-05-19 17:34:58 "},"doc/linux/003-Linux查找文件内容.html":{"url":"doc/linux/003-Linux查找文件内容.html","title":"Linux查找文件内容","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 shell命令搞定某个文件夹下java代码行数的统计 从文件内容查找匹配指定字符串的行： $ grep \"被查找的字符串\" 文件名 例子：在当前目录里第一级文件夹中寻找包含指定字符串的.in文件 $ grep \"thermcontact\" */*.in 从文件内容查找与正则表达式匹配的行： $ grep –e “正则表达式” 文件名 查找时不区分大小写： $ grep –i \"被查找的字符串\" 文件名 查找匹配的行数： $ grep -c \"被查找的字符串\" 文件名 从文件内容查找不匹配指定字符串的行： $ grep –v \"被查找的字符串\" 文件名 从根目录开始查找所有扩展名为.log的文本文件，并找出包含”ERROR”的行 find / -type f -name \"*.log\" | xargs grep \"ERROR\" 例子：从当前目录开始查找所有扩展名为.in的文本文件，并找出包含”thermcontact”的行 find . -name \"*.in\" | xargs grep \"thermcontact\" http://blog.chinaunix.net/uid-25266990-id-199887.html shell命令搞定某个文件夹下java代码行数的统计 find . -name \"*.java\"|xargs wc -l|grep \"total\"|awk '{print $1}' find . -name \"*.java\"|xargs cat|wc -l #Output:37634 上面的两句效果一样，只不过第二种是先利用cat将多个java文件的内容合并输出了。然后再统计。 不过两个都有共同的毛病——连文件里面的空行都给统计进去算作一行了。 去除空行版: find . -name \"*.java\"|xargs cat|grep -v ^$|wc -l 去除注释版: # exclude the lines begin with // find . -name \"*.java\"|xargs cat|grep -v -e ^$ -e ^\\s*\\/\\/.*$|wc -l 参考链接：https://blog.csdn.net/yhhwatl/article/details/52623879 powered by Gitbook文件最后修改时间： 2021-05-19 17:36:40 "},"doc/linux/003-find命令详解.html":{"url":"doc/linux/003-find命令详解.html","title":"find命令详解","keywords":"","body":"find命令查找文件路径。http://www.server110.com/linux/201309/1457.htmlhttp://www.cnblogs.com/bigbean/p/3669739.html 1. 基本用法： $ find / -name 文件名 $ find / -name 'azure-armrest*' # 部分名字匹配 例如azure-armrest-0.3.9 # find ver1.d ver2.d -name '*.c' -print 查找ver1.d,ver2.d *.c文件并打印 # find . -type d -print 从当前目录查找，仅查找目录，找到后，打印路径名。可用于打印目录结构。 2. 无错误查找： find / -name access_log 2 >/dev/null 3. 按尺寸查找： $ find / -size 1500c #（查找1,500字节大小的文件，c表示字节） $ find / -size +1500c #（查找大于1,500字节大小的文件，+表示大于） $ find / -size +1500c #（查找小于1,500字节大小的文件，-表示小于） 4. 按时间： $ find / -amin n # 最后n分钟 $ find / -atime n # 最后n天 $ find / -cmin n # 最后n分钟改变状态 $ find / -ctime n # 最后n天改变状态 5. 其它： $ find / -empty # 空白文件、空白文件夹、没有子目录的文件夹 $ find / -false # 查找系统中总是错误的文件 $ find / -fstype type # 找存在于指定文件系统的文件，如type为ext2 $ find / -gid n # 组id为n的文件 $ find / -group gname # 组名为gname的文件 $ find / -depth n # 在某层指定目录中优先查找文件内容 $ find / -maxdepth levels # 在某个层次目录中按递减方式查找 一、Linux中find常见用法示例 find path -option [ -print ] [ -exec -ok command ] {} ; #-print 将查找到的文件输出到标准输出 #-exec command {} ; -----将查到的文件执行command操作,{} 和 ;之间有空格 #-ok 和-exec相同，只不过在操作前要询用户 ==================================================== -name filename #查找名为filename的文件 -perm #按执行权限来查找 -user username #按文件属主来查找 -group groupname #按组来查找 -mtime -n +n #按文件更改时间来查找文件，-n指n天以内，+n指n天以前 -atime -n +n #按文件访问时间来查GIN: 0px\"> -perm #按执行权限来查找 -user username #按文件属主来查找 -group groupname #按组来查找 -mtime -n +n #按文件更改时间来查找文件，-n指n天以内，+n指n天以前 -atime -n +n #按文件访问时间来查找文件，-n指n天以内，+n指n天以前 -ctime -n +n #按文件创建时间来查找文件，-n指n天以内，+n指n天以前 -nogroup #查无有效属组的文件，即文件的属组在/etc/groups中不存在 -nouser #查无有效属主的文件，即文件的属主在/etc/passwd中不存 -newer f1 !f2 找文件，-n指n天以内，+n指n天以前 -ctime -n +n #按文件创建时间来查找文件，-n指n天以内，+n指n天以前 -nogroup #查无有效属组的文件，即文件的属组在/etc/groups中不存在 -nouser #查无有效属主的文件，即文件的属主在/etc/passwd中不存 -newer f1 !f2 #查更改时间比f1新但比f2旧的文件 -type b/d/c/p/l/f #查是块设备、目录、字符设备、管道、符号链接、普通文件 -size n[c] #查长度为n块[或n字节]的文件 -depth #使查找在进入子目录前先行查找完本目录 -fstype #查更改时间比f1新但比f2旧的文件 -mount #查文件时不跨越文件系统mount点 -follow #如果遇到符号链接文件，就跟踪链接所指的文件 -cpio #对匹配的文件使用cpio命令，将他们备份到磁带设备中 -prune #忽略某个目录 ==================================================== $find ~ -name \"*.txt\" -print #在$HOME中查.txt文件并显示 $find . -name \"*.txt\" -print $find . -name \"[A-Z]*\" -pri26nbsp; #对匹配的文件使用cpio命令，将他们备份到磁带设备中 -prune #忽略某个目录 $find . -name \"[A-Z]*\" -print #查以大写字母开头的文件 $find /etc -name \"host*\" -print #查以host开头的文件 $find . -name \"[a-z][a-z][0--9][0--9].txt\" -print #查以两个小写字母和两个数字开头的txt文件 $find . -perm 755 -print $find . -perm -007 -exec ls -l {} ; #查所有用户都可读写执行的文件同-perm 777 $find . -type d -print 打印目录结构 $find . ! -type d -print 打印非目录文件 find /usr/include -name '*.h' -exec grep AF_INEF6 {} ; 因grep无法递归搜索子目录，故可以和find相结合使用。 在/usr/include 所有子目录中的.h文件中找字串AF_INEF6 $find . -type l -print $find . -size +1000000c -print #查长度大于1Mb的文件 $find . -size 100c -print # 查长度为100c的文件 $find . -size +10 -print #查长度超过期作废10块的文件（1块=512字节） $cd / $find etc home apps -depth -print | cpio -ivcdC65536 -o /dev/rmt0 $find /etc -name \"passwd*\" -exec grep \"cnscn\" {} ; #看是否存在cnscn用户 $find . -name \"yao*\" | xargs file $find . -name \"yao*\" | xargs echo \"\" > /tmp/core.log $find . -name \"yao*\" | xargs chmod o-w ====================================================== find -name april* 在当前目录下查找以april开始的文件 find -name april* fprint file 在当前目录下查找以april开始的文件，并把结果输出到file中 find -name ap* -o -name may* 查找以ap或may开头的文件 find /mnt -name tom.txt -ftype vfat 在/mnt下查找名称为tom.txt且文件系统类型为vfat的文件 find /mnt -name t.txt ! -ftype vfat 在/mnt下查找名称为tom.txt且文件系统类型不为vfat的文件 find /tmp -name wa* -type l 在/tmp下查找名为wa开头且类型为符号链接的文件 find /home -mtime -2 在/home下查最近两天内改动过的文件 find /home -atime -1 查1天之内被存取过的文件 find /home -mmin +60 在/home下查60分钟前改动过的文件 find /home -amin +30 查最近30分钟前被存取过的文件 find /home -newer tmp.txt 在/home下查更新时间比tmp.txt近的文件或目录 find /home -anewer tmp.txt 在/home下查存取时间比tmp.txt近的文件或目录 find /home -used -2 列出文件或目录被改动过之后，在2日内被存取过的文件或目录 find /home -user cnscn 列出/home目录内属于用户cnscn的文件或目录 find /home -uid +501 列出/home目录内用户的识别码大于501的文件或目录 find /home -group cnscn 列出/home内组为cnscn的文件或目录 find /home -gid 501 列出/home内组id为501的文件或目录 find /home -nouser 列出/home内不属于本地用户的文件或目录 find /home -nogroup 列出/home内不属于本地组的文件或目录 find /home -name tmp.txt -maxdepth 4 列出/home内的tmp.txt 查时深度最多为3层 find /home -name tmp.txt -mindepth 3 从第2层开始查 find /home -empty 查找大小为0的文件或空目录 find /home -size +512k 查大于512k的文件 find /home -size -512k 查小于512k的文件 find /home -links +2 查硬连接数大于2的文件或目录 find /home -perm 0700 查权限为700的文件或目录 find /tmp -name tmp.txt -exec cat {} ; find /tmp -name tmp.txt -ok rm {} ; find / -amin -10 # 查找在系统中最后10分钟访问的文件 find / -atime -2 # 查找在系统中最后48小时访问的文件 find / -empty # 查找在系统中为空的文件或者文件夹 find / -group cat # 查找在系统中属于 groupcat的文件 find / -mmin -5 # 查找在系统中最后5分钟里修改过的文件 find / -mtime -1 #查找在系统中最后24小时里修改过的文件 find / -nouser #查找在系统中属于作废用户的文件 find / -user fred #查找在系统中属于FRED这个用户的文件 查当前目录下的所有普通文件 -------------------------------------------------------------------------------- # find . -type f -exec ls -l {} ; -rw-r--r-- 1 root root 34928 2003-02-25 ./conf/httpd.conf -rw-r--r-- 1 root root 12959 2003-02-25 ./conf/magic -rw-r--r-- 1 root root 180 2003-02-25 ./conf.d/README 查当前目录下的所有普通文件，并在- e x e c选项中使用ls -l命令将它们列出 ================================================= 在/ l o g s目录中查找更改时间在5日以前的文件并删除它们： $ find logs -type f -mtime +5 -exec -ok rm {} ; ================================================= 查询当天修改过的文件 [root@book class]# find ./ -mtime -1 -type f -exec ls -l {} ; ================================================= 查询文件并询问是否要显示 [root@book class]# find ./ -mtime -1 -type f -ok ls -l {} ; ? y -rw-r--r-- 1 cnscn cnscn 13709 1月 12 12:22 ./classDB.inc.php [root@book class]# find ./ -mtime -1 -type f -ok ls -l {} ; ? n [root@book class]# ================================================= 查询并交给awk去处理 [root@book class]# who | awk '{print $1\"t\"$2}' cnscn pts/0 ================================================= awk---grep---sed [root@book class]# df -k | awk '{print $1}' | grep -v 'none' | sed s\"//dev///g\" 文件系统 sda2 sda1 [root@book class]# df -k | awk '{print $1}' | grep -v 'none' 文件系统 /dev/sda2 /dev/sda1 1)在/tmp中查找所有的*.h，并在这些文件中查找“SYSCALL_VECTOR\"，最后打印出所有包含\"SYSCALL_VECTOR\"的文件名 A) find /tmp -name \"*.h\" | xargs -n50 grep SYSCALL_VECTOR B) grep SYSCALL_VECTOR /tmp/*.h | cut -d':' -f1| uniq > filename C) find /tmp -name \"*.h\" -exec grep \"SYSCALL_VECTOR\" {} ; -print 2)find / -name filename -exec rm -rf {} ; find / -name filename -ok rm -rf {} ; 3)比如要查找磁盘中大于3M的文件： find . -size +3000k -exec ls -ld {} ; 4)将find出来的东西拷到另一个地方 find *.c -exec cp '{}' /tmp ';' 如果有特殊文件，可以用cpio，也可以用这样的语法： find dir -name filename -print | cpio -pdv newdir 6)查找2004-11-30 16:36:37时更改过的文件 # A=`find ./ -name \"*php\"` | ls -l --full-time $A 2>/dev/null | grep \"2004-11-30 16:36:37 powered by Gitbook文件最后修改时间： 2021-05-19 17:35:30 "},"doc/linux/004-linux下Nginx安装配置.html":{"url":"doc/linux/004-linux下Nginx安装配置.html","title":"linux下Nginx安装配置","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. 安装 1.1 启动Nginx 1.2 开机自动启动nginx 服务 1.3 关闭开机自动启动nginx 服务 1.4 重启Nginx服务 1.5 查看Nginx服务 1.6 查看nginx配置是否正确 2. 配置 2.1 隐藏 Nginx 版本信息 2.2 禁止ip直接访问80端口 2.3 启动 web 服务 (vue 项目为例) 2.4 PC端和移动端使用不同的项目文件映射 2.5 一个web服务，配置多个项目 (location 匹配路由区别) 2.6 配置负载均衡 2.7 SSL 配置 HTTPS 3. 常见问题 3.1 阿里云配置nginx后不能访问，需要开通端口 3.1 部署到阿里云的不能正确解析mime.type [TOC] 1. 安装 通过命令 apt-get install 安装软件，通过安装 nginx 示例如下： $ apt-get install nginx 如果安装时遇到下面错误： E: Unable to locate package nginx 执行sudo apt-get update命令更新软件源后再安装即可。 软件安装完成后，通过通过 dpkg -L 列出软件包所在的目录，及该软件包中的所有文件： $ dpkg -L nginx /. /usr /usr/share /usr/share/doc /usr/share/doc/nginx /usr/share/doc/nginx/copyright /usr/share/doc/nginx/changelog.Debian.gz $ whereis nginx nginx: /usr/sbin/nginx /etc/nginx /usr/share/nginx 1.1 启动Nginx sudo systemctl start nginx 1.2 开机自动启动nginx 服务 sudo systemctl enable nginx 1.3 关闭开机自动启动nginx 服务 sudo systemctl disable nginx 1.4 重启Nginx服务 nginx -s reload 或者： sudo systemctl restart nginx 1.5 查看Nginx服务 ps -ef|grep nginx 1.6 查看nginx配置是否正确 nginx -t 2. 配置 配置目录：/etc/nginx/nginx.conf 终端打开配置文件： vi /etc/nginx/nginx.conf user www-data; worker_processes auto; pid /run/nginx.pid; events { worker_connections 768; # multi_accept on; } http { # include /etc/nginx/mime.types; # 有的需要这个配置返回正确文件类型 # default_type application/octet-stream; server { listen 80; #port server_name 47.104.24.148 www.dragon.com dragon.com; location / { root /website/dist; index index.html index.htm; } } } 配置主要是在http里面的 server，其中参数： listen：监听的端口 server_name：监听的服务名字，以空格间隔 location：访问服务的路径 保存后终端域名命令nginx -s reload重启Nginx来生效命令 2.1 隐藏 Nginx 版本信息 http { server_tokens off; } 2.2 禁止ip直接访问80端口 server { listen 80 default; server_name _; return 500; } 2.3 启动 web 服务 (vue 项目为例) server { # 项目启动端口 listen 80; # 域名（localhost） server_name _; # 禁止 iframe 嵌套 add_header X-Frame-Options SAMEORIGIN; # 访问地址 根路径配置 location / { # 项目目录 root html; # 默认读取文件 index index.html; # 配置 history 模式的刷新空白 try_files $uri $uri/ /index.html; } # 后缀匹配，解决静态资源找不到问题 location ~* \\.(gif|jpg|jpeg|png|css|js|ico)$ { root html/static/; } # 图片防盗链 location ~/static/.*\\.(jpg|jpeg|png|gif|webp)$ { root html; valid_referers *.deeruby.com; if ($invalid_referer) { return 403; } } # 访问限制 location /static { root html; # allow 允许 allow 39.xxx.xxx.xxx; # deny 拒绝 deny all; } } 2.4 PC端和移动端使用不同的项目文件映射 server { ...... location / { root /home/static/pc; if ($http_user_agent ~* '(mobile|android|iphone|ipad|phone)') { root /home/static/mobile; } index index.html; } } 2.5 一个web服务，配置多个项目 (location 匹配路由区别) server { listen 80; server_name _; # 主应用 location / { root html/main; index index.html; try_files $uri $uri/ /index.html; } # 子应用一 location ^~ /store/ { proxy_pass http://localhost:8001; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } # 子应用二 location ^~ /school/ { proxy_pass http://localhost:8002; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } # 静态资源读取不到问题处理 rewrite ^/api/profile/(.*)$ /(替换成正确路径的文件的上一层目录)/$1 last; } # 子应用一服务 server { listen 8001; server_name _; location / { root html/store; index index.html; try_files $uri $uri/ /index.html; } location ^~ /store/ { alias html/store/; index index.html index.htm; try_files $uri /store/index.html; } # 接口代理 location /api { proxy_pass http://localhost:8089; } } # 子应用二服务 server { listen 8002; server_name _; location / { root html/school; index index.html; try_files $uri $uri/ /index.html; } location ^~ /school/ { alias html/school/; index index.html index.htm; try_files $uri /school/index.html; } # 接口代理 location /api { proxy_pass http://localhost:10010; } } 2.6 配置负载均衡 upstream my_upstream { server http://localhost:9001; server http://localhost:9002; server http://localhost:9003; } server { listen 9000; server_name test.com; location / { proxy_pass my_upstream; proxy_set_header Host $proxy_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } 2.7 SSL 配置 HTTPS server { listen 80; server_name www.xxx.com; # 将 http 重定向转移到 https return 301 https://$server_name$request_uri; } server { listen 443 ssl; server_name www.xxx.com; ssl_certificate /etc/nginx/ssl/www.xxx.com.pem; ssl_certificate_key /etc/nginx/ssl/www.xxx.com.key; ssl_session_timeout 10m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { root /project/xxx; index index.html index.htm index.md; try_files $uri $uri/ /index.html; } } 3. 常见问题 3.1 阿里云配置nginx后不能访问，需要开通端口 以前在阿里云配置好nginx后，就可以直接访问网站，现在阿里云虚拟机多了一个安全组，默认所有端口都被禁止了，需要去安全组中配置打开网站的80端口才能访问网站。 https://help.aliyun.com/document_detail/25471.html?spm=5176.11065259.1996646101.searchclickresult.5bc177d5lWlHLD 3.1 部署到阿里云的不能正确解析mime.type 在阿里云服务器虚拟机上配置nginx后，网站的JS、CSS不能正确处理，经过查看，返回的JS、CSS资源类型错误： 导致网站显示不正确。经过查找资料，需要配置nginx的mime.types参数： http { include /etc/nginx/mime.types; default_type application/octet-stream; server { listen 80; # 监听端口 server_name 101.200.230.90 www.yulilong.cn yulilong.cn; location / { root /website/front-end-doc; index index.html; } } } 一般在nginx文件加下会有mime.types文件，直接引用这个文件即可。 配置好后，重启nginx服务：nginx -s reload. 注意，浏览器会有缓存，清除缓存后，即可查看效果。 关于mime.types介绍： https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types 两种主要的 MIME 类型在默认类型中扮演了重要的角色： text/plain 表示文本文件的默认值。一个文本文件应当是人类可读的，并且不包含二进制数据。 application/octet-stream 表示所有其他情况的默认值。一种未知的文件类型应当使用此类型。浏览器在处理这些文件时会特别小心, 试图防止、避免用户的危险行为. powered by Gitbook文件最后修改时间： 2023-03-17 17:29:28 "},"doc/linux/005-centos7下习惯设置.html":{"url":"doc/linux/005-centos7下习惯设置.html","title":"centos7下习惯设置","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 return home return home 设置文件默认打开的程序 右键文件选择 属性（properties） -》 open with -> 这里找一个希望的程序， -》 set as default powered by Gitbook文件最后修改时间： 2021-03-11 10:41:03 "},"doc/linux/006-centos7搭建samba方法.html":{"url":"doc/linux/006-centos7搭建samba方法.html","title":"centos7搭建samba方法","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. centos 部署samba 2. centos7 连接服务器 [TOC] 1. centos 部署samba 1.安装Samba # yum -y install samba samba-client samba-common 2.selinux 设为警告模式 # setenforce 0 3.创建共享目录 # mkdir -p /home/smb/share_folder 4.(可不用)配置内核参数 # ulimit -n 16384 # vi /etc/security/limits.conf #在最后加入以下内容 * - nofile 16384 注：这主要是避免在启动samba出现1024警告信息 5.进入samba目录下备份配置文件 # cd /etc/samba # cp smb.conf smb.conf.bak 6.编辑smb.conf,删除原所有内容添加以下内容： [global] workgroup = SDYTKFQDD netbios name = YTKFQDJJ server string = Samba Server #security = share sercurity = user map to guest = Bad User [smb] path = /home/smb/myself public = no writable = yes write list = @myself 7.创建用户并分配权限 //创建操作系统用户 useradd myself //创建samba用户 smbpasswd -a myself //修改目录权限 chgrp myself /home/smb/myself/ chmod 774 /home/smb/myself/ //查看权限是否生效 ll -d /home/smb/myself/ //重启samba服务并加到开机自启动 systemctl restart smb systemctl enable smb //查看samba运行状态 systemctl status smb //将samba服务添加到防火墙，否则其他电脑无法访问，并重启防火墙 firewall-cmd --permanent --zone=public --add-service=samba firewall-cmd --reload //设置好win7的ip与centos7在同一网段内，开始--运行--输入\\\\服务器IP 即可看到共享文件了 2. centos7 连接服务器 1.查看samba服务器有那些文件夹 $ smbclient -L 192.168.1.44 -U myself 192.168.1.44:服务器的地址，改为你自己服务器的地址 myself： samba的用户 2.连接samba $ smbclient //192.168.1.44/smb -U myself 192.168.1.44:服务器的地址，改为你自己服务器的地址 smb：文件夹 myself： samba的用户 2.连接后文件上传与下载 连接后是ftp形式的，ftp命令： 1．FTP服务器的登陆 匿名用户：FTP 口令：FTP 用户：ANONYMOUS 口令：任何电子邮件 2．显示文件信息：DIR/LS 3．下载文件：GET 文件名（下载到当前目录） 4．上传文件：PUT 文件名 5．多文件下载：MGET 6．多文件上传：MPUT 7．退出：BYE 8．帮助：HELP ls 列出远程机的当前目录 cd 在远程机上改变工作目录 lcd 在本地机上改变工作目录 ascii 设置文件传输方式为ASCII模式 binary 设置文件传输方式为二进制模式 close 终止当前的ftp会话 hash 每次传输完数据缓冲区中的数据后就显示一个#号 get（mget） 从远程机传送指定文件到本地机 put（mput） 从本地机传送指定文件到远程机 open 连接远程ftp站点 断开与远程机的连接并退出ftp ? 显示本地帮助信息 ! 转到Shell中 powered by Gitbook文件最后修改时间： 2021-03-11 10:40:13 "},"doc/linux/007-centos7错误处理.html":{"url":"doc/linux/007-centos7错误处理.html","title":"centos7错误处理","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. SSH 1.1 SSH不能连接并提示REMOTE HOST IDENTIFICATION HAS CHANGED解决 1.2 ssh: connect to host 192.168.123.123 port 22: Connection refused 1.dnf -y install memcached Failed to open: 2. tar uncompress xxx.tar.xz 3. sudo dnf -y install nodejs ,error :no package matched: nodejs 4. sudo dnf -y install npm 如果安装失败 5. sudo yum update 6. 在安装好manageiq 跟rvm后 重起后输入密码后重新输入错误 7. centos gnome 桌面崩溃 [TOC] 1. SSH 1.1 SSH不能连接并提示REMOTE HOST IDENTIFICATION HAS CHANGED解决 错误信息： @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HASCHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ ..... .... Add correcthost key in /root/.ssh/known_hosts to get rid of this message. Offending keyin /root/.ssh/known_hosts:15 #主要看这里，这里是存放ssh主机信任的地方，找到，然后删除这儿ssh地址就好了 RSA host keyfor 192.168.0.252 has changed and you have requested strict checking. Host keyverification failed. rsync:connection unexpectedly closed (0 bytes received so far) [sender] rsync error:error in rsync protocol data stream (code 12) at io.c(359) 的解决办法：vi /root/.ssh/known_hosts找到要连接的主机的ip，把它的那行所有信息删除（就是一行）http://www.linuxidc.com/Linux/2012-07/64941.htm 1.2 ssh: connect to host 192.168.123.123 port 22: Connection refused 1.linux中打开终端 $ netstat -ntlp # 查看所有端口，如果里面没有22端口则尝试重启ssh # 重启ssh $ sudo systemctl restart sshd # 一般来说到这里就可以，如果不行请查找别的方法， 1.dnf -y install memcached Failed to open: http://stackoverflow.com/questions/32541196/i-attempted-to-enable-the-epel-repo-on-my-fedora-22-machine-and-i-broke-it-now This is what appears to have worked for me. Remove the epel repo rm -rf /etc/yum.repos.d/epel* then try install epel via dnf dnf clean all dnf install epel-release 注： 如果删除了/etc/yum.repos.d/epel* ，那么一旦dnf命令安装失败，然后用yum安装，那么就要恢复删除的这些选项。 可先给yum.repos.d 文件夹做一个备份，如果dnf安装失败，则用yum安装，这个时候恢复这个文件夹。 2. tar uncompress xxx.tar.xz tar xf archive.tar.xz tar xf archive.tar.gz tar xf archive.tar .tar.gz 格式解压为 tar -zxvf xx.tar.gz .tar.bz2 格式解压为 tar -jxvf xx.tar.bz2 uncompress xxx.rar http://blog.csdn.net/alpha_xiao/article/details/52238962$ wget http://www.rarsoft.com/rar/rarlinux-3.9.3.tar.gz $ tar -xvf rarlinux-3.9.3.tar.gz $ cd rar $ sudo make 看见下面这些信息就是安装成功了 mkdir -p /usr/local/bin mkdir -p /usr/local/lib cp rar unrar /usr/local/bin cp rarfiles.lst /etc cp default.sfx /usr/local/lib 运行命令rar时,出现下面这个问题 rar: /lib/i686/nosegneg/libc.so.6: version `GLIBC_2.7' not found (required byrar) 解决办法： $ cp rar_static /usr/local/bin/rar 解壓： $ rar x vpsyou.rar //解压 vpsyou.rar 到当前目录 $ rar vpsyou.rar ./vpsyou.com/ //将 vpsyou.com 目录打包为vpsyou.rar 3. sudo dnf -y install nodejs ,error :no package matched: nodejs 1. 去官网下载安装 https://nodejs.org/ 2.如果官网的没有办法安装， https://www.unixmen.com/install-node-js-centos-7/ 参考这个例子，但可以去github源码网站clone下载 https://github.com/nodejs/node git clone git checkout v4.6.1 然后切换到官网的版本。 sudo yum install gcc gcc-c++ ./configure make sudo make install node --version 如果出现了版本号，则说明安装成功了。 4. sudo dnf -y install npm 如果安装失败 尝试是使用yum安装， $ sudo yum -y install npm 如果yum也提示没有，那么更新yum源 5. sudo yum update error info: 警告：/var/cache/yum/x86_64/7/elrepo-kernel/packages/python-perf-4.8.4-1.el7.elrepo.x86_64.rpm: 头V4 DSA/SHA1 Signature, 密钥 ID baadae52: NOKEY 从 file:///etc/pki/rpm-gpg/RPM-GPG-KEY-elrepo.org 检索密钥 获取 GPG 密钥失败：[Errno 14] curl#37 - \"Couldn't open file /etc/pki/rpm-gpg/RPM-GPG-KEY-elrepo.org\" process result http://elrepo.org/tiki/tiki-index.php $ rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org 1.如果导入失败，则手动下载，然后把文件复制到 /etc/pki/rpm-gpg/ 6. 在安装好manageiq 跟rvm后 重起后输入密码后重新输入错误 bashrc 脚本被清除了 原本： ```.bashrc Source global definitions if [ -f /etc/bashrc ]; then . /etc/bashrc fi Uncomment the following line if you don't like systemctl's auto-paging feature: export SYSTEMD_PAGER= User specific aliases and functions 如果没有这一段，那么首先用root用户登陆，然后进入用户目录把这段加上。 * $HOME/.bash_profile 里面缺少下面这段代码： .bash_profile Get the aliases and functions if [ -f ~/.bashrc ]; then . ~/.bashrc fi User specific environment and startup programs PATH=$PATH:$HOME/.local/bin:$HOME/bin export PATH 如果缺少这段代码，那么复制这段代码到里面。 * 导致这个问题的原因： http://manageiq.org/docs/guides/developer_setup/postgresql_software_collection 里面的这段话： source /opt/rh/rh-postgresql94/enable It is good idea to add this to your personal .bash_profile: $ cat > $HOME/.bash_profile 7. centos gnome 桌面崩溃 键盘按 control + alt + F2 root登陆后，切换到个人用户 $ systemctl restart gdm.service 4.切回桌面： control + alt + F1 powered by Gitbook文件最后修改时间： 2021-05-19 17:38:50 "},"doc/linux/008-centos7_VNC_install.html":{"url":"doc/linux/008-centos7_VNC_install.html","title":"centos7_VNC_install","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. overview 2, 开始安装 3. VNC调试参考 4. 常见错误 [TOC] 1. overview 　　VNC，全称为Virtual Network Computing，它是一个桌面共享系统。它的功能，类似于windows中的远程桌面功能。VNC使用了RFB(Remote FrameBuffer，远程帧缓冲）协议来实现远程控制另外一台计算机。它把键盘、鼠标动作发送到远程计算机，并把远程计算机的屏幕发回到本地。 　　VNC技术与平台无关，VNC Viewer可以和VNC Server在不同的操作系统上。VNC几乎支持所有的操作系统，也支持Java，甚至可以通过支持Java的浏览器来访问VNC Server。多个VNC客户端可以同时连接到一个VNC Server上。 参考链接 CentOs 7安装配置VNC Server---[亲测]http://www.jianshu.com/p/35640fc5672b 用VNC实现远程桌面共享的方法:http://www.educity.cn/linux/1442864.html CentOS安装VNC Server远程桌面：http://www.metsky.com/archives/818.html 2, 开始安装 安装VNCServer # 试试服务器装了 VNC 没 $ rpm -q tigervnc tigervnc-server # 如出现not installed说明没有安装 #install VNC $ yum install tigervnc tigervnc-server # 用YUM删除软件包命令：yum remove ~ 配置NVC # 将/lib/systemd/system/vncserver@.service文件复制一份 $ cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service # 编辑刚刚我们复制得新文件，将文件中得修改成 VNC Client连接的账号 $ sudo vi /etc/systemd/system/vncserver@:1.service 设置VNCServer开机自启动 # 切换到root账号，开启VNCServer并设置开机自启 $ systemctl start vncserver@:1.service $ systemctl enable vncserver@:1.service 设置防火墙 最后，需要配置一下防火墙，允许VNC客户端连接VNC server。VNC server监听的端口从5900开始，display :1的监听5901，display :2监听5902，以此类推。CentOs的防火墙缺省是不允许连接这些端口的，所以需要使用下面的步骤打开防火墙（需要root权限)： # centos 默认使用的防火墙 $ firewall-cmd --permanent --add-service=\"vnc-server\" --zone=\"public\" $ firewall-cmd --reload 开启VNCServer $ vncserver Mac苹果系统链接centos 1.使用Jump Desktop软件。 3. VNC调试参考 # 查看所有端口，5900 5901 5902 是vnc所用的 $ netstat -ntlp 1.查看VNC进程情况（如果有VNC启动窗口，列表中可看到）： $ ps -ef|grep -i vnc 2.启动一个窗口 $ vncserver :1 3.杀死一个桌面(注意kill后面有个空格) $ vncserver -kill :1 $ rm -f /tmp/.X1-lock 如果是其它桌面号，需要对应修改ID号。 4.修改VNC登录密码 $ vncpasswd 4. 常见错误 1、命令启动VNCServer报错 $ systemctl start vncserver@:1.service 报告如下错误：Job for vncserver@:1.service failed. See ‘systemctl status vncserver@:1.service’ and ‘journ alctl -xn’ for details. 解决方法(2中方法，我第二种成功了，)： 1.删除/tmp/.X11-unix/ 目录，再启用一次即可 2.修改配置文件 vncserver@:1.service 中 Type 为 simple 修改完成后执行：$ systemctl daemon-reload$ systemctl start vncserver:1.service powered by Gitbook文件最后修改时间： 2021-05-19 17:39:37 "},"doc/linux/009-centos7ruby相关软件安装.html":{"url":"doc/linux/009-centos7ruby相关软件安装.html","title":"centos7ruby相关软件安装l","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. rvm isntall 2. 安装 pqadmin3 3. install rubymine [TOC] 注意：要按照顺序安装 1. rvm isntall https://www.digitalocean.com/community/tutorials/how-to-install-ruby-on-rails-on-centos-6-with-rvm rvm install:$ sudo yum update $ sudo yum install curl $ curl -L get.rvm.io | bash -s stable 如果提示缺少密钥，那么按照提示安装密钥 # If you ran the installer as root, run: $ source /usr/local/rvm/rvm.sh # If you installed it through a user with access to sudo: $ source ~/.rvm/rvm.sh $ source ~/.profile $ rvm -v 如果出现版本，那么说明安装成功。 ruby install: $ rvm list known 选一个版本 $ rvm install 2.3.0 $ rvm use 2.3.0 --default $ echo '[[ -s \"$HOME/.rvm/scripts/rvm\" ]] && . \"$HOME/.rvm/scripts/rvm\"' >>~/.bashrc $ source ~/.bashrc $ ruby -v 如果出现版本，那么说明安装成功。 ps: /etc/profile:此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置. /etc/bashrc:为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取. ~/.bash_profile:每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件. ~/.bashrc:该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时该文件被读取. ~/.bash_logout:当每次退出系统(退出bash shell)时,执行该文件. Install RubyGems: $ rvm rubygems current $ gem -v # 如果出现版本，那么说明安装成功。 Install Rails$ gem install rails $ rails -v # 如果出现版本，那么说明安装成功。 2. 安装 pqadmin3 这里首先需要系统中已经安装了postgres，如果没有安装请先安装。 查看linux中postgres 版本$ psql --version PostgreSQL是以加州大学伯克利分校计算机系开发的 POSTGRES，现在已经更名为PostgreSQL，版本 4.2为基础的对象关系型数据库管理系统（ORDBMS）。PostgreSQL支持大部分 SQL标准并且提供了许多其他现代特性：复杂查询、外键、触发器、视图、事务完整性、MVCC。同样，PostgreSQL 可以用许多方法扩展，比如， 通过增加新的数据类型、函数、操作符、聚集函数、索引。免费使用、修改、和分发 PostgreSQL，不管是私用、商用、还是学术研究使用。$ su postgres bash-4.2$ psql postgres=# \\du $ sudo find / -name postgresql.conf 注： 1.如果postgres 没有设置密码则用如下命令设置： $ sudo passwd postgres 2.如果psql notfound ，则 scl enable rh-postgresql94 bash，这个由于postgres升级导致的，http://manageiq.org/docs/guides/developer_setup/postgresql_software_collection centos7.2安装 pgadmin3https://yum.postgresql.org/http://www.voidcn.com/blog/houzhizhen/article/p-4388378.html $ wget http://ftp.riken.jp/Linux/fedora/epel/6/x86_64/epel-release-6-8.noarch.rpm $ sudo rpm -ivh epel-release-6-8.noarch.rpm $ sudo yum install pgadmin3 修改数据库配置文件，允许连接 $ sudo vi /var/opt/rh/rh-postgresql94/lib/pgsql/data/pg_hba.conf 找到下面的内容： # IPv4 local connections: host all all 127.0.0.1/32 ident # IPv6 local connections: host all all ::1/128 ident 把ident修改为 trust 并在下面添加一行： host all all 192.168.0.0/24 trust 保存后重起数据库： $ sudo systemctl restart rh-postgresql94-postgresql 查看数据库的运行：$ lsof -i:5432 3. install rubymine 注意 ：如果公司对版权有要求，请公司购买激活码，这时候请安装最新版。官网地址：https://www.jetbrains.com/ruby/ 1、rubymine 最好是7.1.4版本的，这个网络上有激活码，此方法不建议。 2、个人网盘下载：链接: https://pan.baidu.com/s/1o8PgQ50 密码: mk2q 3、下载后解压，进入bin目录，运行里面的rubymine.sh 即可安装。 4、rubymine安装后找不到ruby解释器位置： http://stackoverflow.com/questions/17950288/rubymine-cant-find-sdk-where-is-it * Windows - d:\\dev\\Ruby19\\bin\\ruby.exe * Mac Brew - /usr/local/Cellar/ruby/2.0.0-p247/bin/ruby * Ruby Version Manager - /Users//.rvm/rubies/ruby-1.9.3-p327/bin/ruby * Linux/Mac Default - /usr/bin/ruby powered by Gitbook文件最后修改时间： 2021-05-19 17:40:50 "},"doc/linux/010-Terminal终端快捷键.html":{"url":"doc/linux/010-Terminal终端快捷键.html","title":"Terminal终端快捷键","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 快捷键 功能 上面的命令在 Mac上的终端也适用 # 快捷键 功能 Tab # 自动补全 Ctrl+a # 光标移动到开始位置 Ctrl+e # 光标移动到最末尾 Ctrl+k # 删除此处至末尾的所有内容 Ctrl+u # 删除此处至开始的所有内容 Ctrl+w # 删除此处到左边的单词 Ctrl+c # 终止进程/命令 Ctrl+l # 相当于clear，即清屏 # 上面的命令在 Mac上的终端也适用 ----------------------- Ctrl+d # 删除当前字符 Ctrl+h # 删除当前字符前一个字符 Ctrl+y # 粘贴由Ctrl+u， Ctrl+d， Ctrl+w删除的单词 Ctrl+r # 查找历史命令 Ctrl+b # 向回移动光标 Ctrl+f # 向前移动光标 Ctrl+t # 将光标位置的字符和前一个字符进行位置交换 Ctrl+& # 恢复 ctrl+h 或者 ctrl+d 或者 ctrl+w 删除的内容 Ctrl+S # 暂停屏幕输出 Ctrl+Q # 继续屏幕输出 Ctrl+Left-Arrow # 光标移动到上一个单词的词首 Ctrl+Right-Arrow # 光标移动到下一个单词的词尾 Ctrl+p # 向上显示缓存命令 Ctrl+n # 向下显示缓存命令 Ctrl+d # 关闭终端 Ctrl+xx # 在EOL和当前光标位置移动 Ctrl+x@ # 显示可能hostname补全 Shift+上或下 # 终端上下滚动 Shift+PgUp/PgDn # 终端上下翻页滚动 Ctrl+Shift+n # 新终端 alt+F2 # 输入gnome-terminal打开终端 Shift+Ctrl+T # 打开新的标签页 Shift+Ctrl+W # 关闭标签页 Shift+Ctrl+C # 复制 Shift+Ctrl+V # 粘贴 Alt+数字 # 切换至对应的标签页 Shift+Ctrl+N # 打开新的终端窗口 Shift+Ctrl+Q # 管壁终端窗口 Shift+Ctrl+PgUp/PgDn # 左移右移标签页 Ctrl+PgUp/PgDn # 切换标签页 F1 # 打开帮助指南 F10 # 激活菜单栏 F11 # 全屏切换 Alt+F 打开 “文件” 菜单（file） Alt+E 打开 “编辑” 菜单（edit） Alt+V 打开 “查看” 菜单（view） Alt+S 打开 “搜索” 菜单（search） Alt+T 打开 “终端” 菜单（terminal） Alt+H 打开 “帮助” 菜单（help） powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/linux/011-VIM编辑器常用命令与用法总结.html":{"url":"doc/linux/011-VIM编辑器常用命令与用法总结.html","title":"VIM编辑器常用命令与用法总结","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. vi/vim是什么？ 2. 为什么要学习vi/vim？ 3. vi的三种模式及各个模式之间的转换关系 4. 一般模式常用操作 5. 一般模式切换到编辑模式的操作 6. 一般模式切换到命令行模式 7. vim配置文件 参考链接 [TOC] 1. vi/vim是什么？ Linux世界几乎所有的配置文件都是以纯文本形式存在的，而在所有的Linux发行版系统上都有vi编辑器，因此利用简单的文字编辑软件就能够轻松地修改系统的各种配置了，非常方便。vi就是一种功能强大的文本编辑器，而vim则是高级版的vi，不但可以用不同颜色显示文字内容，还能进行诸如shell脚本、C语言程序编辑等功能，可以作为程序编辑器。 2. 为什么要学习vi/vim？ 首先所有的Linux发行版系统上都会默认内置vi编辑器，而不一定带有其他文本编辑器，非常通用；其次，很多软件的编辑接口都会默认调用vi；第三，vi具有程序编辑的能力；最后，vi程序简单，编辑速度相当快速。 3. vi的三种模式及各个模式之间的转换关系 +----------------------+ i,o,a(插 入 ),R(替 换 )+------------------------+ | +--------------------------> 【 编 辑 模 式 】 | | 【 一 般 模 式 】 | | | | 【 命 令 行 模 式 ] | | | | 读 取 /保 存 文 件 | | 4. 一般模式常用操作 【h(或向左方向键)】 光标左移一个字符【j(或向下方向键)】 光标下移一个字符【k(或向上方向键)】 光标上移一个字符【l(或向右方向键)】 光标右移一个字符 【[Ctrl] + f】 屏幕向下移动一页（相当于Page Down键）【[Ctrl] + b】 屏幕向上移动一页（相当于Page Up键） 【[0]或[Home]】 光标移动到当前行的最前面【[$]或[End]】 光标移动到当前行的末尾 【G】 光标移动到文件的最后一行（第一个字符处）【nG】 n为数字（下同），移动到当前文件中第n行【gg】 移动到文件的第一行，相当于\"1G\"【n[Enter]】 光标向下移动n行 【/word】 在文件中查找内容为word的字符串（向下查找）【?word】 在文件中查找内容为word的字符串（向上查找）【[n]】 表示重复查找动作，即查找下一个【[N]】 反向查找下一个【:n1,n2s/word1/word2/g】 n1、n2为数字，在第n1行到第n2行之间查找word1字符串，并将其替换成word2【:1,$s/word1/word2/g】 从第一行（第n行同理）到最后一行查找word1注册，并将其替换成word2【:1,$s/word1/word2/gc】 功能同上，只不过每次替换时都会让用户确认 【x,X】 x为向后删除一个字符，相当于[Delete]，X为向前删除一个字符，相当于[Backspace]【dd】 删除光标所在的一整行【ndd】 删除光标所在的向下n行 【yy】 复制光标所在的那一行【nyy】 复制光标所在的向下n行【p,P】 p为将已经复制的数据在光标下一行粘贴；P为将已经复制的数据在光标上一行粘贴 【u】 撤消上一个操作【[Ctrl] + r】 多次撤消【.】 这是小数点键，重复上一个操作 5. 一般模式切换到编辑模式的操作 进入插入模式（６个命令） 【i】 从目前光标所在处插入【I】 从目前光标【a】 从当前光标所在的下一个字符处开始插入【A】 从光标所在行的最后一个字符处开始插入【o】 英文小写字母o，在目前光标所在行的下一行处插入新的一行并开始插入【O】 英文大写字母O，在目前光标所在行的上一行处插入新的一行并开始插入 进入替换模式（2个命令） 【r】 只会替换光标所在的那一个字符一次【R】 会一直替换光标所在字符，直到按下[ESC]键为止【[ESC]】 退出编辑模式回到一般模式 6. 一般模式切换到命令行模式 【:w】 保存文件【:w!】 若文件为只读，强制保存文件【:q】 离开vi【:q!】 不保存强制离开vi【:wq】 保存后离开【:wq!】 强制保存后离开【:! command】 暂时离开vi到命令行下执行一个命令后的显示结果【:set nu】 显示行号【:set nonu】 取消显示行号【:w newfile】 另存为 7. vim配置文件 vim的配置文件为/etc/vimrc，但一般不建议直接修改这个文件，而是在用户根目录下创建一个新的隐藏文件： $ vim ~/.vimrc # 然后编辑这个文件，常用的配置如下： \"双引号后面的内容为注释 set ts=4 \" 设置tab为4个空格 set expandtab \" TAB替换为空格 %retab! \" 加!是用于处理非空白字符之后的TAB，即所有的TAB，若不加!，则只处理行首的TAB。 set nu \"显示行号 set hlsearch \"查找的字符串反白显示 set backspace=2 \"可随时用退格键进行删除 set autoindent \"自动缩排 set ruler \"在最下方一行显示状态 set showmode \"在左下角显示模式 set bg=dark \"显示不同的底色，还可以为light syntax on \"语法检验，颜色显示 --------------------------------- set nocompatible \" 关闭 vi 兼容模式 syntax on \" 自动语法高亮 colorscheme molokai \" 设定配色方案 set number \" 显示行号 set cursorline \" 突出显示当前行 set ruler \" 打开状态栏标尺 set shiftwidth=4 \" 设定 > 命令移动时的宽度为 4 set softtabstop=4 \" 使得按退格键时可以一次删掉 4 个空格 set tabstop=4 \" 设定 tab 长度为 4 set nobackup \" 覆盖文件时不备份 set autochdir \" 自动切换当前目录为当前文件所在的目录 filetype plugin indent on \" 开启插件 set backupcopy=yes \" 设置备份时的行为为覆盖 set ignorecase smartcase \" 搜索时忽略大小写，但在有一个或以上大写字母时仍保持对大小写敏感 set nowrapscan \" 禁止在搜索到文件两端时重新搜索 set incsearch \" 输入搜索内容时就显示搜索结果 set hlsearch \" 搜索时高亮显示被找到的文本 set noerrorbells \" 关闭错误信息响铃 set novisualbell \" 关闭使用可视响铃代替呼叫 set t_vb= \" 置空错误铃声的终端代码 \" set showmatch \" 插入括号时，短暂地跳转到匹配的对应括号 \" set matchtime=2 \" 短暂跳转到匹配括号的时间 set magic \" 设置魔术 set hidden \" 允许在有未保存的修改时切换缓冲区，此时的修改由 vim 负责保存 set guioptions-=T \" 隐藏工具栏 set guioptions-=m \" 隐藏菜单栏 set smartindent \" 开启新行时使用智能自动缩进 set backspace=indent,eol,start \" 不设定在插入状态无法用退格键和 Delete 键删除回车符 set cmdheight=1 \" 设定命令行的行数为 1 set laststatus=2 \" 显示状态栏 (默认值为 1, 无法显示状态栏) set statusline=\\ % @=((foldclosed(line('.')) \" 用空格键来开关折叠 参考链接 http://www.cnblogs.com/jiayongji/p/5771444.htmlhttp://www.cnblogs.com/wangj08/archive/2013/03/13/2957309.html 编写 https://blog.csdn.net/qq_38597315/article/details/80627439 https://lzw.me/a/vim-shortcut.html https://blog.csdn.net/ljx_5489464/article/details/50896080 https://blog.csdn.net/xyw_blog/article/details/15550149 powered by Gitbook文件最后修改时间： 2021-03-11 10:31:50 "},"doc/linux/012-virtualbox虚拟机、centos7安装增强工具.html":{"url":"doc/linux/012-virtualbox虚拟机、centos7安装增强工具.html","title":"virtualbox虚拟机、centos7安装增强工具","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. virtualBox语言设置 2. 设置终端启动快捷键 3. 添加virtualbox 增强工具 4. 设置共享文件夹 [TOC] 1. virtualBox语言设置 virtualbox -> file -> perferences -> language ->选择对应的语言 -> OKvirtualbox -> 管理 -> 全局设定 -> 语言 -> 选择相应的语言 -> OK 2. 设置终端启动快捷键 http://www.centoscn.com/CentOS/config/2015/0330/5044.html 1. 首先打开Applications,选择System Tools 2. 选择Setting进入下面界面 3. 选择Keyboard，进入下面界面，点击Shortcuts 4. 再点击+号，弹出对话框 5. Name： Run a Terminal Command: /usr/bin/gnome-terminal (Terminal 程序的路径） 点击apply 6. 一开始是禁用（disabled）的,点击disabled出现下面情形,此时按下你喜欢的快捷键比如Ctrl+Alt+T, 在virtualbox虚拟机中，如果鼠标指针出不来， 按键盘上右边的 alt+ctrl。 3. 添加virtualbox 增强工具 http://www.tuicool.com/articles/VRbq2em $ sudo yum update $ sudo yum install gcc kernel-devel kernel-headers dkms make bzip2 $ reboot 1.点击虚拟机左上角的 Devices ,选择：insert guest addition CD image 2.进入到虚拟机中运行这个镜像自动安装。 4. 设置共享文件夹 http://www.cnblogs.com/zqifa/p/linux-virtualbox-1.html http://www.cnblogs.com/jenry/archive/2013/09/06/3305062.html 1.在VirtualBox的菜单点击\"设备(Devices)\" -> 分配数据空间(Shared Folders)菜单，添加一个共享文件夹，选项固定和临时是指该文件夹是否是持久的。尽量使用英文名称。我这里用winshare. 2. 重新进入虚拟CentOs5.5，在命令行终端下输入： #sudo mkdir /mnt/share #sudo mount -t vboxsf winshare /mnt/share 如果提示 /sbin/mount.vboxsf: mounting failed with the error: No such device 可能是没有载入内核模块 vboxfs ，先查看下： #lsmod | grep vboxsf 如果没有结果返回，说明 vboxsf没有载入，执行 #sudo modprobe vboxsf 正常的话mount -t vboxsf winshare /mnt/share共享文件夹应该可以访问了 #cd /mnt/share #ls -al 假如您不想每一次都手动挂载，可以在/etc/fstab中添加一项 share /mnt/share vboxsf rw,gid=100,uid=1000,auto 0 0 这样就能够自动挂载了。 ssh,IP地址可以访问虚拟机设置 1.VirtualBox Version 5.1.82.virtualbox -> file -> perferences -> network -> Host-only Network -> add new host only network http://blog.csdn.net/astrotycoon/article/details/8143146 http://blog.csdn.net/ixidof/article/details/12685549 虚拟机磁盘扩容 http://blog.csdn.net/ganshuyu/article/details/17954733 $ VBoxManage list hdds # 在列出的信息中找到需要的虚拟机，复制UUID $ VBoxManage modifyhd a0f06f66-f696-41dc-827a-e79bee50f65b --resize 51200 # 操作成功后该虚拟的硬盘即增加了50G，但要注意了，此50G空间还没有分配. powered by Gitbook文件最后修改时间： 2021-03-11 10:29:10 "},"doc/linux/013-linux下ssh配置.html":{"url":"doc/linux/013-linux下ssh配置.html","title":"linux下ssh配置","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 linux下ssh配置 1. 在支持SSH命令的环境中使用密钥对（通过命令配置） 2. 在支持SSH命令的环境中使用密钥对（通过config文件配置） [TOC] linux下ssh配置 1. 在支持SSH命令的环境中使用密钥对（通过命令配置） 1、获取.pem私钥文件 比如从阿里云ECS 创建生成的秘钥文件：https://help.aliyun.com/document_detail/51793.html?spm=5176.10695662.1996646101.searchclickresult.1e0711bbFycE9l 2、获取到问秘钥文件放到本机存储： 如：~/.ssh/ecs.pem，此处路径和文件名称仅为示例，请根据实际情况修改。 3、运行以下命令修改私钥文件的属性 chmod 400 [.pem私钥文件在本地机上的存储路径]，例如： chmod 400 ~/.ssh/ecs.pem 4、运行以下命令连接至实例 ssh -i [.pem私钥文件在本地机上的存储路径] root@[公网IP地址]，例如： ssh -i ~/.ssh/ecs.pem root@10.10.xx.xxx 2. 在支持SSH命令的环境中使用密钥对（通过config文件配置） 在Linux和其他支持SSH命令的环境中通过config配置所需信息，并通过SSH命令连接Linux实例。 进入用户主目录下的.ssh目录，按照如下方式修改config文件。 ~/.ssh/ecs.pem为私钥文件在本地机上的存储路径。 Host ecs // 输入ECS实例的名称 HostName 192.*.*.* // 输入ECS实例的公网IP地址 Port 22 // 输入端口号，默认为22 User root // 输入登录账号 IdentityFile ~/.ssh/ecs.pem // 输入.pem私钥文件在本机的地址 保存config文件。 重启SSH。 运行命令连接至实例。 ssh [ECS实例的名称] 示例如下： ssh ecs powered by Gitbook文件最后修改时间： 2021-03-11 10:43:16 "},"doc/npm-yarn-node/001-NPM使用介绍.html":{"url":"doc/npm-yarn-node/001-NPM使用介绍.html","title":"NPM使用介绍","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 npm使用介绍 1. 常用命令 2. npm一些命令介绍 2.1 npm install 安装原理 2.2 npm update 2.3 registry 2.4 npm 的缓存目录 2.5 清除npm缓存 2.6 其他与缓存相关的命令 2.7 模块的安装过程 2.8 --cache-min 参数 3. 更换npm的源地址:npm config set registry 4. npm的其他配置:关闭进度条，显示每个请求 4.1 显示npm发的每一个请求 4.2 关闭npm安装包时显示的进度条 5. npm安装本地包离线包 5.1 从npm仓库获取离线包 5.2 从本地已经安装的包中提取离线包 5.3 安装离线npm包 cnpm 介绍 参考链接 [TOC] npm使用介绍 1. 常用命令 npm 终端命令官方文档地址：https://docs.npmjs.com/cli/v10/commands，在这个文档里面可以选择不同的版本来查看npm命令 npm install express # 安装express到项目中，安装的是最新版本 npm install express@3.0.6 # 安装express的3.0.6版本， 安装特定版本 npm install -g # 将包安装到全局环境中 npm install lodash --save # save 在package.json文件的dependencies字段添加该package的名称和版本号 npm install lodash --save-dev # 在package.json文件的devDependencies字段添加该package的名称和版本号 npm i -g # 将包安装到全局环境中 i 是 install 的缩写，如果用i失败，则用install试试 npm init # 会引导你创建一个package.json文件，包括名称、版本、作者这些信息等 npm remove # 移除 npm uninstall lodash # 卸载lodash npm uninstall --save lodash # save 卸载的同时想把这个package包的信息从package.json文件的dependencies字段中也一并删除 npm update # 更新 npm root # 查看当前包的安装路径 npm ls # 列出当前安装的了所有包 npm root # 查看当前包的安装路径 npm help # 帮助，如果要单独查看install命令的帮助，可以使用的npm help install which npm # 确认我们现在用的npm是来自哪个目录 npm --version # 查看版本 npm list # 列出自己项目已经安装过的模块 npm list --depth 1 # 列出已安装的包，深度1 npm list -g --depth 0 # 全局包 npm search mkdir # 搜索mkdir是否存在 npm info express # 查看包的信息 npm 命令参数： -g：全局安装。 --save：将保存配置信息至package.json（package.json是nodejs项目配置文件）； -dev：保存至package.json的devDependencies节点，不指定-dev将保存至dependencies节点； -D：保存至package.json的devDependencies节点下。 2. npm一些命令介绍 2.1 npm install 安装原理 npm install 命令用来安装模块到node_modules目录。安装之前，npm install会先检查，node_modules目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此。如果你希望，一个模块不管是否安装过，npm 都要强制重新安装，可以使用-f或--force参数。 npm install --force 2.2 npm update 如果想更新已安装模块，就要用到npm update命令。 npm update 它会先到远程仓库查询最新版本，然后查询本地版本。如果本地版本不存在，或者远程版本较新，就会安装。 2.3 registry npm update命令怎么知道每个模块的最新版本呢？答案是 npm 模块仓库提供了一个查询服务，叫做 registry 。以 npmjs.org 为例，它的查询服务网址是 :https://registry.npmjs.org/这个网址后面跟上模块名，就会得到一个 JSON 对象，里面是该模块所有版本的信息。比如，访问https://registry.npmjs.org/react ，就会看到 react 模块所有版本的信息。它跟下面命令的效果是一样的。 $ npm view react # npm view 的别名 $ npm info react $ npm show react $ npm v react registry 网址的模块名后面，还可以跟上版本号或者标签，用来查询某个具体版本的信息。比如， 访问 https://registry.npmjs.org/react/v0.14.6 ，就可以看到 React 的 0.14.6 版。返回的 JSON 对象里面，有一个dist.tarball属性，是该版本压缩包的网址。 dist: { shasum: '2a57c2cf8747b483759ad8de0fa47fb0c5cf5c6a', tarball: 'http://registry.npmjs.org/react/-/react-0.14.6.tgz' }, 到这个网址下载压缩包，在本地解压，就得到了模块的源码。npm install和npm update命令，都是通过这种方式安装模块的。 2.4 npm 的缓存目录 npm install或npm update命令，从 registry 下载压缩包之后，都存放在本地的缓存目录。这个缓存目录，在 Linux 或 Mac 默认是用户主目录下的.npm目录，在 Windows 默认是%AppData%/npm-cache。通过配置命令，可以查看这个目录的具体位置。 $ npm config get cache ~/.npm # 浏览这个目录 $ ls ~/.npm # 或者 $ npm cache ls 你会看到里面存放着大量的模块，储存结构是{cache}/{name}/{version}。 $ npm cache ls react ~/.npm/react/react/0.14.6/ ~/.npm/react/react/0.14.6/package.tgz ~/.npm/react/react/0.14.6/package/ ~/.npm/react/react/0.14.6/package/package.json 每个模块的每个版本，都有一个自己的子目录，里面是代码的压缩包package.tgz文件，以及一个描述文件package/package.json。除此之外，还会生成一个{cache}/{hostname}/{path}/.cache.json文件。比如，从 npm 官方仓库下载 react 模块的时候，就会生成registry.npmjs.org/react/.cache.json文件。这个文件保存的是，所有版本的信息，以及该模块最近修改的时间和最新一次请求时服务器返回的 ETag 。 { \"time\":{ \"modified\":\"2016-01-06T23:52:45.571Z\", // ... }, \"_etag\":\"\\\"7S37I0775YLURCFIO8N85FO0F\\\"\" } 对于一些不是很关键的操作（比如npm search或npm view），npm会先查看.cache.json里面的模块最近更新时间，跟当前时间的差距，是不是在可接受的范围之内。如果是的，就不再向远程仓库发出请求，而是直接返回.cache.json的数据。 2.5 清除npm缓存 需要清理缓存的情况：1、缓存占用磁盘空间比较大2、由于网络原因npm包下载终端，再次安装失败报错，可以尝试清理缓存 清除缓存命令： # 注意：--force 参数是必需的，因为npm默认不允许你清除缓存，以防止不必要的网络流量和安装时间的增加。 ~ npm cache clean --force 验证缓存是否已经被清除(或者从文件夹中查看cache是否已经删除)： # 如果这个命令从远程仓库下载了包而不是从本地缓存中获取，那么说明缓存已经被成功清除。 npm install 或者使用终端命令直接删除文件(实际中没尝试过，慎用)： ~ rm -rf ~/.npm/* 请注意，清除npm缓存可能会导致你在下次安装相同的包时需要重新从远程仓库下载，这可能会增加安装时间。因此，只有在确实需要清除缓存时才应该执行这个操作。 另外，如果你使用的是npm的较新版本（如npm 7及以上），npm已经对缓存管理进行了优化，因此你可能不需要经常手动清除缓存。在大多数情况下，npm会自动处理缓存的更新和清理工作。 2.6 其他与缓存相关的命令 查看缓存的状态：npm cache verify 设置缓存的最大存储时间（以秒为单位）：npm config set cache-max= 设置缓存的存储路径：npm config set cache= 2.7 模块的安装过程 Node模块的安装过程是这样的: 1. 发出npm install命令 2. npm 向 registry 查询模块压缩包的网址 3. 下载压缩包，存放在~/.npm目录 4. 解压压缩包到当前项目的node_modules目录 注意，一个模块安装以后，本地其实保存了两份。一份是~/.npm目录下的压缩包，另一份是node_modules目录下解压后的代码。但是，运行npm install的时候，只会检查node_modules目录，而不会检查~/.npm目录。也就是说，如果一个模块在～/.npm下有压缩包，但是没有安装在node_modules目录中，npm 依然会从远程仓库下载一次新的压缩包。这种行为固然可以保证总是取得最新的代码，但有时并不是我们想要的。最大的问题是，它会极大地影响安装速度。即使某个模块的压缩包就在缓存目录中，也要去远程仓库下载，这怎么可能不慢呢？另外，有些场合没有网络（比如飞机上），但是你想安装的模块，明明就在缓存目录之中，这时也无法安装。 2.8 --cache-min 参数 为了解决这些问题，npm 提供了一个--cache-min参数，用于从缓存目录安装模块。--cache-min参数指定一个时间（单位为分钟），只有超过这个时间的模块，才会从 registry 下载。 $ npm install --cache-min 9999999 上面命令指定，只有超过999999分钟的模块，才从 registry 下载。实际上就是指定，所有模块都从缓存安装，这样就大大加快了下载速度。它还有另一种写法: $ npm install --cache-min Infinity 但是，这并不等于离线模式，这时仍然需要网络连接。因为现在的--cache-min实现有一些问题。 （1）如果指定模块不在缓存目录，那么 npm 会连接 registry，下载最新版本。这没有问题，但是如果指定模块在缓存目录之中，npm 也会连接 registry，发出指定模块的 etag ，服务器返回状态码304，表示不需要重新下载压缩包。 （2）如果某个模块已经在缓存之中，但是版本低于要求，npm会直接报错，而不是去 registry 下载最新版本。 npm 团队知道存在这些问题，正在重写 cache。并且，将来会提供一个--offline参数，使得 npm 可以在离线情况下使用。不过，这些改进没有日程表。所以，当前使用--cache-min改进安装速度，是有问题的。 3. 更换npm的源地址:npm config set registry 查看npm包的源地址（包下载地址）： npm config get registry https://registry.npmjs.org/ 更换npm的源地址: // 淘宝源 npm config set registry https://registry.npm.taobao.org // 自己本来的源 npm config set registry https://registry.npmjs.org/ 参考链接：http://blog.csdn.net/v2810769/article/details/52585662 4. npm的其他配置:关闭进度条，显示每个请求 4.1 显示npm发的每一个请求 npm config set loglevel http 执行这个命令后，终端不会有任何显示。 4.2 关闭npm安装包时显示的进度条 npm config set progress false 执行这个命令后，终端不会有任何显示。 5. npm安装本地包离线包 5.1 从npm仓库获取离线包 注意：这个方式获取的包在安装的时候，这个包依赖的其他的包还是会需要从网络中的npm仓库冲拉取的。 在已经安装了包的项目里面，使用npm info packageName来获取包信息： ~ npm info http-server # 也是可以查看特定版本的：npm info http-server@0.11.1 npm http fetch GET 200 https://registry.npm.taobao.org/http-server 343ms http-server@0.12.3 | MIT | deps: 10 | versions: 40 A simple zero-configuration command-line http server https://github.com/http-party/http-server#readme bin: http-server, hs dist .tarball: https://registry.npm.taobao.org/http-server/download/http-server-0.12.3.tgz .shasum: ba0471d0ecc425886616cb35c4faf279140a0d37 dependencies: basic-auth: ^1.0.3 minimist: ^1.2.5 colors: ^1.4.0 opener: ^1.5.1 其中.tarball: https://registry.npm.taobao.org/http-server/download/http-server-0.12.3.tgz，这行中的链接就是这个包的下载链接，在浏览器中打开这个链接下载包。 5.2 从本地已经安装的包中提取离线包 注意：这种方式把包和包的依赖包都打包了，做到了真正的离线安装这个包。 1、安装打包离线工具npm-pack-all： ~ npm install npm-pack-all -g 2、全局安装需要打包的包，并进入到这个包的全局安装路径中，注意：只有安装在全局中，才能把这个包的依赖放到自己的文件夹中，这样打包就能全部打包了。 ~ npm i http-server -g 然后打开npm全局安装的文件夹，终端中使用npm root -g 来查看npm全局的安装路径： ~ npm root -g # Mac电脑的路径 /usr/local/lib/node_modules # window电脑一般：C:\\Users\\用户名\\AppData\\Roaming\\npm\\node_modules 在全局安装路径中找到包后进入包中然后终端运行命令打包： ~ cd /usr/local/lib/node_modules/http-server ~ npm-pack-all npm notice integrity: sha512-G0A/WdHj+kDOe[...]DXKdS6OL6bKcw== npm notice total files: 306 npm notice http-server-0.11.1.tgz Restoring original package.json and lock files 命令执行结束后，会在文件夹中生成一个http-server-0.11.1.tgz这个文件就是最终的离线包。把这个包拿出来即可。 5.3 安装离线npm包 把下载的包解压放到要安装的项目中，然后终端使用如下命令： ~ npm install http-server-0.11.1.tgz + http-server@0.11.1 added 1 package from 1 contributor in 0.879s 3 packages are looking for funding run `npm fund` for details cnpm 介绍 说明：因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事。来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。” 这就是cnpm. 官方网址：http://npm.taobao.org 安装：命令提示符执行npm install cnpm -g --registry=https://registry.npm.taobao.org或npm i -g cnpm 安装完后最好查看其版本号cnpm -v或关闭命令提示符重新打开，安装完直接使用有可能会出现错误 cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm。 参考链接 http://blog.csdn.net/haidaochen/article/details/8546796/http://www.nodeclass.com/articles/810142http://www.cnblogs.com/jiuyi/p/5353676.html powered by Gitbook文件最后修改时间： 2025-01-21 09:44:03 "},"doc/npm-yarn-node/002-NPM常见问题.html":{"url":"doc/npm-yarn-node/002-NPM常见问题.html","title":"NPM常见问题","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 NPM常见问题 1. 使用淘宝源安装包出错 2. listen EADDRINUSE 服务端口被占用报错 3. npm start 启动后过一会崩溃结束：内存溢出 4. npm install的时候使用特定的源安装 5. npm安装指定版本、最新版本 6. npm ERR! cb() never called! 解决 7. Unable to authenticate：认证失败 8. 查看项目中是否安装了特定包 9. TypeError: compilation. templatesPlugin is not a function 10. npm install 报错：npm :this is an error with npm itself. 11. Error: Cannot find module 'webpack' 问题解决办法 12. request to https://registry.npm.taobao.org/antd failed, reason: certificate has expired 13. npm install遇到sha1认证失败问题 14. npm start报错：Error: ENOTDIR......DS_Store/stamp [TOC] NPM常见问题 1. 使用淘宝源安装包出错 使用npm安装webpack包的时候，发生了错误 npm install webpack --save-dev // 发生如下错误 events.js:160░░░░░░⸩ ⠸ extract:repeat-string: sill extract remove-trailing-sepa throw er; // Unhandled 'error' event ^ Error: write after end at writeAfterEnd (_stream_writable.js:193:12) at PassThrough.Writable.write (_stream_writable.js:240:5) at PassThrough.Writable.end (_stream_writable.js:477:10) 后来查看安装源是淘宝的，换源可以解决这个问题： 设置npmjs的源(可能需要VPN)，如果https不行就换成http的。 // 查看安装源 npm config get registry // 设置npm自己的源 npm config set registry https://registry.npmjs.org/ npm config set registry http://registry.npmjs.org/ // 设置为淘宝源 npm config set registry https://registry.npm.taobao.org/ npm config set registry http://registry.npm.taobao.org/ 这个问题有的时候会发生，有时没问题，看人品了。 还有一种情况，使用淘宝源： 使用公司网络安装失败，但是使用自己网络则安装成功。 2. listen EADDRINUSE 服务端口被占用报错 npm start > webpack-dev-server --config ./config/webpack.config.dev.js events.js:160 throw er; // Unhandled 'error' event ^ Error: listen EADDRINUSE 127.0.0.1:8080 at Object.exports._errnoException (util.js:1018:11) at exports._exceptionWithHostPort (util.js:1041:20) at Server._listen2 (net.js:1258:14) at listen (net.js:1294:10) 当使用npm start启动一个web开发服务时，显示上面错误，经查找是端口(8080)被占用了。 解决方法： 换一个端口，重新运行即可。 找到被占用的端口，关掉占用的端口，重新运行即可。 // 查看是哪个进程占用的端口 ~ sudo lsof -n -P | grep :8080 node 6534 dragon 14u IPv4 0x3cf6bb332552824d 0t0 TCP 127.0.0.1:8080 (LISTEN) // 关闭这个服务 kill -9 6534 3. npm start 启动后过一会崩溃结束：内存溢出 当使用npm start启动服务后，由于修改代码，导致服务频繁编译，由此导致内存溢出错误： ==== JS stack trace ========================================= Security context: 0x15d948ca5879 0: builtin exit frame: stringify(this=0x15d948c890a9 ,0x15d93d0022d1 ,0x15d93d0022d1 ,0x15d9bb6172e9 ) 1: arguments adaptor frame: 1->3 2: /* anonymous */(aka /* anonymous */) [/Users/dragon/work/owl-changshachaonao/node_modules/webpack/lib/EvalSourceMapDevToolModuleTemplatePlugin.js:103] [bytecode=0x15d9f3... FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory 1: node::Abort() [/usr/local/bin/node] 2: node::FatalException(v8::Isolate*, v8::Local, v8::Local) [/usr/local/bin/node] 解决办法： 1、node v8.0以上版本支持在环境变量中设置最大内存： export NODE_OPTIONS=--max_old_space_size=4096 如果是mac电脑，可在终端环境脚本中添加上面命令，然后重启终端： vi .zshrc export NODE_OPTIONS=--max_old_space_size=5120 # 或者运行命令立即生效：source .zshrc 2、安装increase-memory-limitnpm包，使用该包增加运行内存： # 全局安装increase-memory-limit npm install -g increase-memory-limit # 进入工程目录，执行： increase-memory-limit 注意：increase-memory-limit命令会操作node_modules里面对应文件，可能会导致git提交命令冲突，解决方法是删除node_modules文件夹，重新安装一个就好。 Window 系统如果运行npm start命令报错： \"'node --max-old-space-size=10240\"' 不是内部或外部命令,也不是可运行的程序 在 \\node_modules.bin 下的 *.cmd 文件中，在 ENDLOCAL 语句的上边一句，修改【\"%_prog%\"】 为 【%_prog%】，即去掉双引号。 4. npm install的时候使用特定的源安装 有的时候，使用npm config set registry https://registry.npm.taobao.org/设置一个源后， 有个别的npm包不是这个源里面的，如果在设置一下修改源，然后安装后，在改回来有点麻烦，可以在npm i的时候指定安装源，这样就不需要设置更换源了 使用方法： npm i --registry=https://registry.npm.taobao.org/ 在--registry=后面放入npm包的源即可 5. npm安装指定版本、最新版本 安装指定版本： npm install npm@6.8.0 安装最新版本： npm install package_name # 执行上面命令后会安装最新版本npm包，等同于 npm install package_name@latest 安装未来版本 npm install package_name@next 这个是beta版本，还未正式发布，所以会有风险 6. npm ERR! cb() never called! 解决 当运行npm install的时候，终端出现如下报错： npm ERR! cb() never called! npm ERR! This is an error with npm itself. Please report this error at: npm ERR! npm ERR! A complete log of this run can be found in: npm ERR! /Users/lenno/.npm/_logs/2021-04-04T08_14_08_150Z-debug.log 解决办法： 1、清除npm缓存： sudo npm cache clean -f 一般来说已经解决问题了。 7. Unable to authenticate：认证失败 当运行npm install的时候，终端报错： npm ERR! code E401 npm ERR! Unable to authenticate, need: BASIC realm=\"Sonatype Nexus Repository Manager\" 大致的意思是认证失败，之前使用 npm login登陆过，现在需要从新登陆。 解决办法： 1、如果记得账号密码，那么使用npm login命令然后重新输入账号密码即可 2、如果忘记密码了，那么可以找到.npmrc配置文件删除登陆信息： .npmrc存放路径： // windows电脑 C:\\Users\\user-name // mac电脑 /Users/user-name 打开.npmrc文件后里面内容类似如下： registry=https://registry.npm.taobao.org/ //registry.npm.taobao.org/:_authToken=NpmToken.7d2371ad-2e98-3d43-bd93-463f2d2cb2bb loglevel=http progress=false 把文件中的第二行内容删除(最终内容为如下)： registry=https://registry.npm.taobao.org/ loglevel=http progress=false 保存后，在运行npm install就可以正常安装包了。 8. 查看项目中是否安装了特定包 终端进入到项目中，然后使用npm ls packageName命令来查看思否安装了某个包： 项目中没有安装包： ~ npm ls react basic-common@0.1.0 /Users/user/work/certificate └── (empty) 项目中安装了包： ~ npm ls eslint basic-common@0.1.0 /Users/user/work/certificate └── eslint@6.8.0 9. TypeError: compilation. templatesPlugin is not a function 在一个vue 前端项目中，当安装好依赖包，启动服务后，发现报如下错误： 经过网上查找，发现是webpack版本问题，可以尝试如下几个方案 解决方案一： # 最新版本的 webpack 包 npm add webpack@latest 解决方案二： 在方案一的基础上，删除node_modules文件夹后，重新安装依赖包npm install。 解决方案三(实测解决了)： 在方案一的基础上，安装html-webpack-plugin包 npm i --save-dev html-webpack-plugin # 或者如下命令 npm i --save-dev html-webpack-plugin@next 10. npm install 报错：npm :this is an error with npm itself. 当使用npm i 命令安装依赖包的时候，报如下错误： npm :this is an error with npm itself. Please report this error at: 解决方案： # 清除npm缓存 npm cache clean --force npm WARN using --force I sure hope you know what you are doing. 如果有package-lock.json文件，删除，然后从新npm install。 经实测这个方案可以解决。 11. Error: Cannot find module 'webpack' 问题解决办法 当启动本地前端服务的时候，发现终端报如下错误： 看报错是没有找到webpack模块，所以在项目中安装一下webpack： npm install --save-dev webpack npm WARN ttt No README data npm WARN ttt No license field. + webpack@5.69.1 added 71 packages from 121 contributors in 9.761s 8 packages are looking for funding run `npm fund` for details 再次运行后就会解决问题，如果还不行，查看安装的webpack的版本： npm info webpack 可尝试更换webpack版本：webpack@5.69.1 或者 webpack@4.22.0 安装上面的包后，如果报如下错误： Syntax Error: Error: Cannot find module ‘cache-loader‘ 解决方法： 进入项目目录，删除node_modules文件和package-lock.json文件，然后从新安装包npm install，然后重启项目就可以了。 12. request to https://registry.npm.taobao.org/antd failed, reason: certificate has expired 详情见：https://blog.csdn.net/maoge_666/article/details/136038003 在使用npm i 命令安装依赖包的时候，发现终端报错： ~ npm i npm ERR! code CERT_HAS_EXPIRED npm ERR! errno CERT_HAS_EXPIRED npm ERR! request to https://registry.npm.taobao.org/antd failed, reason: certificate has expired npm ERR! A complete log of this run can be found in: npm ERR! /Users/dragon/.npm/_logs/2024-10-31T07_22_08_061Z-debug.log 进过查找，使用的安装源是淘宝的egistry.npm.taobao.org。 早在 2021 年，淘宝就发文称，npm 淘宝镜像已经从 registry.npm.taobao.org 切换到了 registry.npmmirror.com。旧域名也将于 2022 年 5 月 31 日停止服务（不过，直到今天 HTTPS 证书到期才真正不能用了） 解决方案： 1、查看当前的npm镜像设置：npm config list ~ npm config list ; cli configs metrics-registry = \"https://registry.npm.taobao.org/\" scope = \"\" user-agent = \"npm/6.4.1 node/v8.16.0 darwin x64\" ; project config /Users/dragon/work/awakens-frontend/.npmrc scripts-prepend-node-path = true 2、清空缓存：npm cache clean --force 3、然后修改包下载地址： # 淘宝源新地址，建议使用这个 npm config set registry https://registry.npmmirror.com # npm官方地址 npm config set registry https://registry.npmjs.org/ 5、再次运行： npm config list，查看 registry 已经被更改为默认的 npm 公共镜像地址 13. npm install遇到sha1认证失败问题 在执行npm i命令的时候，报如下错误： verbose node v8.16.0 verbose npm v6.14.18 error code EINTEGRITY error sha1-iHs7qdhDk+h6CgufTLdWGYtTVIo= integrity checksum failed when using sha1: wanted sha1-iHs7qdhDk+h6CgufTLdWGYtTVIo= but got sha512-xIp7/apCFJuUHdDLWe8O1HIkb0kQrOMb/0u6FXQjemHn/ii5LrIzU6bdECnsiTF/GjZkMEKg1xdiZwNqDYlZ6g== sha1-XcB1Osv4Uhyi4PE3tFeLkXsQzyQ=. (7610 bytes) verbose exit [ 1, true ] 解决方案步骤如下： 删除 node_modules 文件夹。终端命令： rm -rf node_modules/ 删除 package-lock.json 文件。 终端命令：rm package-lock.json 清除npm缓存。终端命令：npm cache verify 重新安装依赖包。终端命令：npm install 14. npm start报错：Error: ENOTDIR......DS_Store/stamp 当使用npm i命令启动服务的时候，发现终端报错： ｢wdm｣: Error: ENOTDIR: not a directory, stat '/Users/dragon/aaa/t-frontend/node_modules/.cache/hard-source/.DS_Store/stamp' 解决办法： 终端删除.DS_Store rm -rf /Users/dragon/aaa/t-frontend/node_modules/.cache/hard-source/.DS_Store 从新启动服务就没问题了。 参考资料：https://github.com/mzgoddard/hard-source-webpack-plugin/issues/456 上面的可能是临时的，有可能一段时间后还会出现问题。 如果可以的话，可以在webpack.config 配置文件里面，忽略.DS_Store文件： // 没有实际测试过不知道是否有用 plugins: [ new HardSourceWebpackPlugin(), new HardSourceWebpackPlugin.ExcludeModulePlugin([ { test: /.*\\.DS_Store/ } ]), new webpack.HotModuleReplacementPlugin(), ... ], powered by Gitbook文件最后修改时间： 2024-11-25 17:22:03 "},"doc/npm-yarn-node/003-package.json文件详解.html":{"url":"doc/npm-yarn-node/003-package.json文件详解.html","title":"package.json文件详解","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 package.json介绍 1. name 2. version 3. description 3. keywords 4. homepage 5. bugs 6. license 7. 和用户相关的属性: author, contributors 8. files 9. main 10. bin 11. man 12. directories 13. repository 14. scripts 15. config 16. dependencies 17. URLs as Dependencies 18. Git URLs as Dependencies 19. GitHub URLs 20. Local Paths 21. devDependencies 22. peerDependencies 23. bundledDependencies 24. optionalDependencies 25. engines 26. os 27. cpu 28. preferGlobal 29. private 30. publishConfig 31. DEFAULT VALUES 本文参考链接 [TOC] package.json介绍 package.json文件描述了一个NPM包的所有相关信息，包括作者、简介、包依赖、构建等信息。格式必须是严格的JSON格式。通常我们在创建一个NPM程序时，可以使用npm init命令，通过交互式的命令，自动生成一个package.json文件，里面包含了常用的一些字段信息，但远不止这么简单。通过完善package.json文件，我们可以让npm命令更好地为我们服务。在终端输入npm init会询问package.json的各种信息，从而确认。如果全部使用默认值，可以直接在终端输入npm init –y快速生成package.json。 1. name package.json中最重要的属性是name和version两个属性，这两个属性是必须要有的，否则模块就无法被安装，这两个属性一起形成了一个npm模块的唯一标识符。模块中内容变更的同时，模块版本也应该一起变化。 name属性就是你的模块名称，下面是一些命名规则: name必须小于等于214个字节，包括前缀名称在内（如 xxx/xxxmodule）。 name不能以\"_\"或\".\"开头 不能含有大写字母 name会成为url的一部分，不能含有url非法字符 下面是官网文档的一些建议： 不要使用和node核心模块一样的名称 name中不要含有\"js\"和\"node\"。 It's assumed that it's js, since you're writing a package.json file, and you can specify the engine using the \"engines\" field. (See below.) name属性会成为模块url、命令行中的一个参数或者一个文件夹名称，任何非url安全的字符在name中都不能使用，也不能以\"_\"或\".\"开头 name属性也许会被写在require()的参数中，所以最好取个简短而语义化的值。 创建一个模块前可以先到后边的网址查查name是否已经被占用. https://www.npmjs.com/ name属性可以有一些前缀如 e.g. @myorg/mypackage在npm-scope(7)的文档中可以看到详细说明 2. version version必须可以被npm依赖的一个node-semver模块解析。具体规则见下面的dependencies模块 3. description 一个描述，方便别人了解你的模块作用，搜索的时候也有用。包的描述信息，将会在npm search的返回结果中显示，以帮助用户选择合适的包。 3. keywords 一个字符串数组，方便别人搜索到本模块.包的关键词信息，是一个字符串数组，同上也将显示在npm search的结果中。 4. homepage 项目主页url注意: 这个项目主页url和url属性不同，如果你填写了url属性，npm注册工具会认为你把项目发布到其他地方了，获取模块的时候不会从npm官方仓库获取，而是会重定向到url属性配置的地址。 5. bugs 填写一个bug提交地址或者一个邮箱，被你的模块坑到的人可以通过这里吐槽，例如： bugs: { \"url\": \"http://github.com/ijse/project/issues\", \"email\": \"my@ijser.cn\" } url和email可以任意填或不填，如果只填一个，可以直接写成一个字符串而不是对象。如果填写了url，npm bugs命令会使用这个url。 6. license 你应该为你的模块制定一个协议，让用户知道他们有何权限来使用你的模块，以及使用该模块有哪些限制。最简单的，例如你用BSD-3-Clause 或 MIT之类的协议，如下：{ \"license\" : \"BSD-3-Clause\" }你可以在https://spdx.org/licenses/ 这个地址查阅协议列表 。 7. 和用户相关的属性: author, contributors \"author\"是一个码农， \"contributors\"是一个码农数组。 \"person\"是一个有一些描述属性的对象，如下 like this: author: { \"name\": \"ijse\", \"email\": \"my@ijse.cn\", \"url\": \"http://www.ijser.cn\" } 也可以按如下格式缩写，npm会帮着转换:\"author: Barney Rubble b@rubble.com (http://barnyrubble.tumblr.com/)\"email和url属性实际上都是可以省略的。描述用户信息的还有一个\"maintainers\"（维护者）属性。 8. files \"files\"属性的值是一个数组，内容是模块下文件名或者文件夹名，如果是文件夹名，则文件夹下所有的文件也会被包含进来（除非文件被另一些配置排除了）.你也可以在模块根目录下创建一个.npmignore文件（windows下无法直接创建以\".\"开头的文件，使用linux命令行工具创建如git bash），写在这个文件里边的文件即便被写在files属性里边也会被排除在外，这个文件的写法.gitignore类似。 9. main main属性指定了程序的主入口文件。意思是，如果你的模块被命名为foo，用户安装了这个模块并通过require(\"foo\")来使用这个模块，那么require返回的内容就是main属性指定的文件中 module.exports指向的对象。它应该指向模块根目录下的一个文件。对大对数模块而言，这个属性更多的是让模块有一个主入口文件，然而很多模块并不写这个属性。 10. bin 很多模块有一个或多个需要配置到PATH路径下的可执行模块，npm让这个工作变得十分简单（实际上npm本身也是通过bin属性安装为一个可执行命令的）,如果要用npm的这个功能，在package.json里边配置一个bin属性。bin属性是一个已命令名称为key，本地文件名称为value的map如下： { \"bin\" : { \"myapp\" : \"./cli.js\" } } 模块安装的时候，若是全局安装，则npm会为bin中配置的文件在bin目录下创建一个软连接（对于windows系统，默认会在C:\\Users\\username\\AppData\\Roaming\\npm目录下），若是局部安装，则会在项目内的./node_modules/.bin/目录下创建一个软链接。 因此，按上面的例子，当你安装myapp的时候，npm就会为cli.js在/usr/local/bin/myapp路径创建一个软链接。 如果你的模块只有一个可执行文件，并且它的命令名称和模块名称一样，你可以只写一个字符串来代替上面那种配置，例如： { \"name\": \"my-program\", \"version\": \"1.2.5\", \"bin\": \"./path/to/program\" } 作用和如下写法相同: { \"name\": \"my-program\", \"version\": \"1.2.5\", \"bin\" : { \"my-program\" : \"./path/to/program\" } } 11. man 制定一个或通过数组制定一些文件来让linux下的man命令查找文档地址。如果只有一个文件被指定的话，安装后直接使用man+模块名称，而不管man指定的文件的实际名称。例如: { \"name\" : \"foo\", \"version\" : \"1.2.3\", \"description\" : \"A packaged foo fooer for fooing foos\", \"main\" : \"foo.js\", \"man\" : \"./man/doc.1\", } 通过man foo命令会得到 ./man/doc.1 文件的内容。如果man文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置： { \"name\" : \"foo\", \"version\" : \"1.2.3\", \"description\" : \"A packaged foo fooer for fooing foos\", \"main\" : \"foo.js\", \"man\" : [ \"./man/foo.1\", \"./man/bar.1\" ], } 会创建一些文件来作为man foo和man foo-bar命令的结果。man文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。 { \"name\" : \"foo\", \"version\" : \"1.2.3\", \"description\" : \"A packaged foo fooer for fooing foos\", \"main\" : \"foo.js\", \"man\" : [ \"./man/foo.1\", \"./man/foo.2\" ], } 会创建 man foo 和 man 2 foo 两条命令。 12. directories CommonJs通过directories来制定一些方法来描述模块的结构，看看npm的package.json文件https://registry.npmjs.org/npm/latest ，可以发现里边有这个字段的内容。下级字段可以是：lib, bin, man, doc, example。 每个都是字符串directories.lib: 告诉用户模块中lib目录在哪，这个配置目前没有任何作用，但是对使用模块的人来说是一个很有用的信息。directories.bin: 如果你在这里指定了bin目录，这个配置下面的文件会被加入到bin路径下，如果你已经在package.json中配置了bin目录，那么这里的配置将不起任何作用。directories.man: 指定一个目录，目录里边都是man文件，这是一种配置man文件的语法糖。directories.doc: 在这个目录里边放一些markdown文件，可能最终有一天它们会被友好的展现出来（应该是在npm的网站上）directories.example: 放一些示例脚本，或许某一天会有用 - -！ 13. repository 指定一个代码存放地址，对想要为你的项目贡献代码的人有帮助。像这样： \"repository\" : { \"type\" : \"git\", \"url\" : \"https://github.com/npm/npm.git\", } \"repository\" : { \"type\" : \"svn\", \"url\" : \"https://v8.googlecode.com/svn/trunk/\", } 若你的模块放在GitHub, GitHub gist, Bitbucket, or GitLab的仓库里，npm install的时候可以使用缩写标记来完成： \"repository\": \"npm/npm\" \"repository\": \"gist:11081aaa281\" \"repository\": \"bitbucket:example/repo\" \"repository\": \"gitlab:another/repo\" 14. scripts scripts属性是一个对象，里边指定了项目的生命周期个各个环节需要执行的命令。key是生命周期中的事件，value是要执行的命令。 具体的内容有 install start stop 等，详见https://docs.npmjs.com/misc/scripts 15. config 用来设置一些项目不怎么变化的项目配置，例如port等。 用户用的时候可以使用如下用法：http.createServer(...).listen(process.env.npm_package_config_port)可以通过npm config set foo:port 80来修改config。详见 https://docs.npmjs.com/misc/config { \"name\" : \"foo\", \"config\" : { \"port\" : \"8080\" }, } 16. dependencies dependencies属性是一个对象，配置模块依赖的模块列表，key是模块名称，value是版本范围，版本范围是一个字符，可以被一个或多个空格分割。dependencies也可以被指定为一个git地址或者一个压缩包地址。不要把测试工具或transpilers写到dependencies中。 下面是一些写法，详见 https://docs.npmjs.com/misc/semver version 精确匹配版本 version 必须大于某个版本 =version 大于等于 ~version \"约等于\"，具体规则详见semver文档 ^version \"兼容版本\"具体规则详见semver文档 1.2.x 仅一点二点几的版本 http://... 见下面url作为denpendencies的说明 任何版本 \"\" 空字符，和*相同 version1 - version2 相当于 >=version1 range1 || range2 范围1和范围2满足任意一个都行 git... 见下面git url作为denpendencies的说明 user/repo See 见下面GitHub仓库的说明 tag 发布的一个特殊的标签，见npm-tag的文档 https://docs.npmjs.com/getting-started/using-tags path/path/path 见下面本地模块的说明 下面的写法都是可以的: { \"dependencies\" : { \"foo\" : \"1.0.0 - 2.9999.9999\", \"bar\" : \">=1.0.2 1.0.2 =2.3.1 =2.5.2 17. URLs as Dependencies 在版本范围的地方可以写一个url指向一个压缩包，模块安装的时候会把这个压缩包下载下来安装到模块本地。 18. Git URLs as Dependencies Git url可以像下面一样: git://github.com/user/project.git#commit-ish git+ssh://user@hostname:project.git#commit-ish git+ssh://user@hostname/project.git#commit-ish git+http://user@hostname/project/blah.git#commit-ish git+https://user@hostname/project/blah.git#commit-ish commit-ish 可以是任意标签，哈希值，或者可以检出的分支，默认是master分支。 19. GitHub URLs 支持github的 username/modulename 的写法，#后边可以加后缀写明分支hash或标签： { \"name\": \"foo\", \"version\": \"0.0.0\", \"dependencies\": { \"express\": \"visionmedia/express\", \"mocha\": \"visionmedia/mocha#4727d357ea\" } } 20. Local Paths npm2.0.0版本以上可以提供一个本地路径来安装一个本地的模块，通过npm install xxx --save 来安装，格式如下： ../foo/bar ~/foo/bar ./foo/bar /foo/bar package.json 生成的相对路径如下: { \"name\": \"baz\", \"dependencies\": { \"bar\": \"file:../foo/bar\" } } 这种属性在离线开发或者测试需要用npm install的情况，又不想自己搞一个npm server的时候有用，但是发布模块到公共仓库时不应该使用这种属性。 21. devDependencies 如果有人想要下载并使用你的模块，也许他们并不希望或需要下载一些你在开发过程中使用的额外的测试或者文档框架。在这种情况下，最好的方法是把这些依赖添加到devDependencies属性的对象中。这些模块会在npm link或者npm install的时候被安装，也可以像其他npm配置一样被管理，详见npm的config文档。对于一些跨平台的构建任务，例如把CoffeeScript编译成JavaScript，就可以通过在package.json的script属性里边配置prepublish脚本来完成这个任务，然后需要依赖的coffee-script模块就写在devDependencies属性种。例如: { \"name\": \"ethopia-waza\", \"description\": \"a delightfully fruity coffee varietal\", \"version\": \"1.2.3\", \"devDependencies\": { \"coffee-script\": \"~1.6.3\" }, \"scripts\": { \"prepublish\": \"coffee -o lib/ -c src/waza.coffee\" }, \"main\": \"lib/waza.js\" } prepublish脚本会在发布之前运行，因此用户在使用之前就不用再自己去完成编译的过程了。在开发模式下，运行npm install也会执行这个脚本（见npm script文档），因此可以很方便的调试。 22. peerDependencies 有时候做一些插件开发，比如grunt等工具的插件，它们往往是在grunt的某个版本的基础上开发的，而在他们的代码中并不会出现require(\"grunt\")这样的依赖，dependencies配置里边也不会写上grunt的依赖，为了说明此模块只能作为插件跑在宿主的某个版本范围下，可以配置peerDependencies： { \"name\": \"tea-latte\", \"version\": \"1.3.5\", \"peerDependencies\": { \"tea\": \"2.x\" } } 上面这个配置确保再npm install的时候tea-latte会和2.x版本的tea一起安装，而且它们两个的依赖关系是同级的：├── tea-latte@1.3.5└── tea@2.2.0这个配置的目的是让npm知道，如果要使用此插件模块，请确保安装了兼容版本的宿主模块。 23. bundledDependencies 上面的单词多个d，写成bundleDependencies也可以。指定发布的时候会被一起打包的模块。 24. optionalDependencies 如果一个依赖模块可以被使用， 同时你也希望在该模块找不到或无法获取时npm继续运行，你可以把这个模块依赖放到optionalDependencies配置中。这个配置的写法和dependencies的写法一样，不同的是这里边写的模块安装失败不会导致npm install失败。当然，这种模块就需要你自己在代码中处理模块确实的情况了，例如： try { var foo = require('foo') var fooVersion = require('foo/package.json').version } catch (er) { foo = null } if ( notGoodFooVersion(fooVersion) ) { foo = null } // .. then later in your program .. if (foo) { foo.doFooThings() } optionalDependencies 中的配置会覆盖dependencies中的配置，最好只在一个地方写。 25. engines 你可以指定项目运行的node版本范围，如下：{ \"engines\" : { \"node\" : \">=0.10.3 和dependencies一样，如果你不指定版本范围或者指定为*，任何版本的node都可以。也可以指定一些npm版本可以正确的安装你的模块，例如：{ \"engines\" : { \"npm\" : \"~1.0.20\" } }要注意的是，除非你设置了engine-strict属性，engines属性是仅供参考的。 26. os 可以指定你的模块只能在哪个操作系统上跑：\"os\" : [ \"darwin\", \"linux\" ]也可以指定黑名单而不是白名单：\"os\" : [ \"!win32\" ]服务的操作系统是由process.platform来判断的，这个属性允许黑白名单同时存在，虽然没啥必要这样搞... 27. cpu 限制模块只能在某某cpu架构下运行\"cpu\" : [ \"x64\", \"ia32\" ]同样可以设置黑名单:\"cpu\" : [ \"!arm\", \"!mips\" ]cpu架构通过 process.arch 判断 28. preferGlobal 如果您的软件包主要用于安装到全局的命令行应用程序，那么该值设置为true ，如果它被安装在本地，则提供一个警告。实际上该配置并没有阻止用户把模块安装到本地，只是防止该模块被错误的使用引起一些问题。 29. private 如果这个属性被设置为true，npm将拒绝发布它，这是为了防止一个私有模块被无意间发布出去。如果你只想让模块被发布到一个特定的npm仓库，如一个内部的仓库，可与在下面的publishConfig中配置仓库参数。 30. publishConfig 这个配置是会在模块发布时用到的一些值的集合。如果你不想模块被默认被标记为最新的，或者默认发布到公共仓库，可以在这里配置tag或仓库地址。 31. DEFAULT VALUES npm设置了一些默认参数，如：\"scripts\": {\"start\": \"node server.js\"}如果模块根目录下有一个server.js文件，那么npm start会默认运行这个文件。\"scripts\":{\"preinstall\": \"node-gyp rebuild\"}如果模块根目录下有binding.gyp, npm将默认用node-gyp来编译preinstall的脚本\"contributors\": [...]若模块根目录下有AUTHORS 文件，则npm会按Name (url)格式解析每一行的数据添加到contributors中，可以用#添加行注释 本文参考链接 http://www.cnblogs.com/tzyy/p/5193811.htmlhttp://ju.outofmemory.cn/entry/130809http://www.nodepeixun.com/a/nodejiaocheng/20170218/158.html powered by Gitbook文件最后修改时间： 2021-05-20 16:36:34 "},"doc/npm-yarn-node/004-NPM常用的包.html":{"url":"doc/npm-yarn-node/004-NPM常用的包.html","title":"NPM常用的包","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 npm常用的包 1. git-open:直接在终端打开git网站 2. http-server:启动本地服务 3. 多个CSS类名合并 [TOC] npm常用的包 1. git-open:直接在终端打开git网站 https://www.npmjs.com/package/git-open 可以直接在终端中使用命令打开项目在github上的网站 安装、使用命令： # 全局安装 npm i -g git-open # 使用 git open 2. http-server:启动本地服务 https://www.npmjs.com/package/http-server 可以在前端打包的项目中运行此命令后启动一个服务，然后在浏览器中查看打包的页面效果 安装、使用命令： # 安装 npm install http-server -g # 使用 http-server http-server [path] [options] 3. 多个CSS类名合并 https://www.npmjs.com/package/classnames 可以根据不同的条件拼接成不同的字符串，主要用于有多个样式类时，根据不同的类显示不同的样式类。 powered by Gitbook文件最后修改时间： 2021-05-20 16:37:25 "},"doc/npm-yarn-node/005-node环境常见问题.html":{"url":"doc/npm-yarn-node/005-node环境常见问题.html","title":"node环境常见问题","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 node运行环境常见问题 1. node环境不支持ES6的import解决 2. node版本太高，导致gitbook报错 [TOC] node运行环境常见问题 1. node环境不支持ES6的import解决 在我学习ES6的import语法的时候，在自己电脑的node环境下模拟运行import，发现node环境不支持import语法，报如下错误： (function (exports, require, module, __filename, __dirname) { import pp from './a' ^^^^^^ SyntaxError: Unexpected token import at createScript (vm.js:80:10) at Object.runInThisContext (vm.js:139:10) at Module._compile (module.js:617:28) at Object.Module._extensions..js (module.js:664:10) at Module.load (module.js:566:32) at tryModuleLoad (module.js:506:12) 我的node版本是v8.12.0, 在网络上查找资料发现：nodejs采用的是CommonJS的模块化规范，使用require引入模块；而import是ES6的模块化规范关键字。想要使用import，必须引入babel转义支持，通过babel进行编译，使其变成node的模块化代码。 由于我只是学习测试，不想这么麻烦，所以我发现了一个快捷的测试方法： 可以使用--experimental-modules实验模块标志来启用加载ECMAScript Modules的特性。 而且作为ES模块加载的文件名，必须以.mjs后缀结尾 node --experimental-modules my-app.mjs # 此种方法，在输出的时候会出现如下提示，表示是个实验模块，到时候可能会修改。 (node:16208) ExperimentalWarning: The ESM module loader is experimental. 经过我的测试，这个node --experimental-modules是可以的，只不过测试文件后缀名要修改成.mjs 参考资料: https://www.cnblogs.com/weiqinl/p/9152219.html 2. node版本太高，导致gitbook报错 2021-04-04 由于使用新电脑，初次安装node后，再安装好gitbook-cli工具后，再命令行中执行gitbook命令报错： gitbook build . /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) ^ TypeError: cb.apply is not a function at /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 at FSReqCallback.oncomplete (fs.js:184:5) 经过搜索，看到一个相关解决文档：https://blog.csdn.net/weixin_42349568/article/details/108414441 发现这个是由于node版本太高导致。 我的node版本： node -v v14.16.0 需要使用n工具来切换工具： npm install -g n sudo n v10.21.0 经过把node版本切换到v10.21.0后，在执行gitbook命令发现没有问题了，问题得到解决。 powered by Gitbook文件最后修改时间： 2021-05-20 16:38:07 "},"doc/npm-yarn-node/006-yarn说明.html":{"url":"doc/npm-yarn-node/006-yarn说明.html","title":"yarn说明","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 yarn 说明 参考 [TOC] yarn 说明 yarn官网：https://yarnpkg.com/ 中文官网：https://yarn.bootcss.com/ 参考 前端工程师应该知道的yarn知识 掘进 Yarn vs npm：你需要知道的一切 知乎 powered by Gitbook文件最后修改时间： 2021-03-08 15:47:40 "},"doc/windows/001-windows下前端开发环境安装.html":{"url":"doc/windows/001-windows下前端开发环境安装.html","title":"windows下前端开发环境安装","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 windows下前端开发环境安装 1. Cmder 终端使用 1.1 cmder进入指定目录 2. nodejs环境安装 3. vscode编辑器下载 3.1 vscode插件离线安装 [TOC] windows下前端开发环境安装 1. Cmder 终端使用 使用Cmder替换cmd，让开发更高效 https://cmder.net/ 打开网址后，选择Download Full版本点击，点击后会跳转到github网站中，选择cmder.zip下载。 下载好后，解压，把文件放到一个地方，然后把Cmder.exe发送一个桌面快捷方式，然后点击这个图表即可打开使用。 1.1 cmder进入指定目录 首先直接进入到指定磁盘,然后在进入到指定目录 2. nodejs环境安装 1、查看操作系统位数：我的电脑图标，右键选择属性，在出现的弹窗中，系统 -> 系统类型 查看是多少位操作系统。 2、打开 nodejs 官网下载地址, 选择 Windows Installer (.msi)中对应系统操作位数的包下载，下载以后点击安装。 3. vscode编辑器下载 https://code.visualstudio.com/ 打开网址后，选择 windows X64 中stable版本下载。下载后，双击安装即可。 3.1 vscode插件离线安装 获取离线插件包 在线搜索插件：https://marketplace.visualstudio.com/vscode，或者在vscode插件中，找到插件，然后点击插件名字会直接跳转到插件的网址。 在出现的插件页面中，点击Download Extension 按钮，下载离线包。 安装插件包 1、打开vscode编辑器，点击插件部分。 2、在搜索框右边的上面有三个点，点击。 3、在出现的弹窗中，选择Install from VSIX...选项。 4、在出现的弹窗中，选择插件离线包所在的目录，选择需要安装的插件，然后点击install按钮进行安装。 powered by Gitbook文件最后修改时间： 2022-02-21 15:38:35 "},"doc/windows/002-windows常见问题.html":{"url":"doc/windows/002-windows常见问题.html","title":"windows常见问题","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Windows下常见问题 1. 修改hosts文件 2. win10系统卸载edge浏览器 [TOC] Windows下常见问题 1. 修改hosts文件 hosts文件位置：C:\\Windows\\System32\\drivers\\etc\\hosts 随便打开一个文件夹，然后在地址栏中输入上面的路径，然后选择使用txt编辑器打开，编辑后保存即可。 2. win10系统卸载edge浏览器 1、找到windows powershell,右键以管理员身份运行。进入蓝色命令界面。 2、输入代码 get-appxpackage edge，查找edge包。 3、在edge包中找到 packagefullname，选中并复制。 4、接着输入命令 Remove-appxpackage 和 packagefullname包名，用来移除edge包。 5、按下回车后进入win10系统的microsoft edge中将其移除即可。 如果上面操作失败，可以根据提示在启用或关闭windows 功能中关闭。打开控制面板，选择程序，在程序和功能中，找到启用或关闭windows 功能，找到选线后，取消勾选，然后点确定，重启电脑就可以了。 powered by Gitbook文件最后修改时间： 2021-07-30 13:53:59 "},"doc/other/001-Chrome浏览器开发者工具使用.html":{"url":"doc/other/001-Chrome浏览器开发者工具使用.html","title":"Chrome浏览器开发者工具使用","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. 打开chrome的开发者工具 2. Console部分的使用 2.1 直接使用标签的ID名字即可调出该标签的dom 2.1 页面跳转后，输出的console记录保留 3. 利用开发者工具截取页面 3.1 截取整个页面：Capture full size screenshot 3.2 截取页面中的一些元素 [TOC] 1. 打开chrome的开发者工具 网页右键 -> 最下面的'检查'，就能调出开发者工具 直接按Option + Command + J（Mac）或者Ctrl + Shift + J（Windows / Linux）。 Chrome菜单-> View -> Developer - > Developer Tools, 或者Option + Command + I（Mac）以及Ctrl + Shift + I（Windows / Linux）。 http://javascript.ruanyifeng.com/introduction/intro.html#toc10 2. Console部分的使用 2.1 直接使用标签的ID名字即可调出该标签的dom 如123，可直接输入app即可查看该标签的dom 2.1 页面跳转后，输出的console记录保留 点击右边齿轮图标，然后选择preserve log 然后在切换页面后，所有输出的log记录都会保留。 3. 利用开发者工具截取页面 3.1 截取整个页面：Capture full size screenshot 打开 Chrome 浏览器，进入需要截图的网站页面 等待页面加载完毕后，通过下面方法打开开发者工具：在页面任何地方点击鼠标右键，在弹出菜单中选择“检查（Inspect）”选项。或者使用快捷键组合：Alt + Command + I (Mac) 或 Ctrl + Shift + I (Windows) 使用快捷键组合来打开命令行（command palette）：Command + Shift + P (Mac) 或 Ctrl + Shift + P (Windows) 在命令行中输入“Screen”，这时自动补齐功能会显示出一些包含 \"Screen\" 关键字的命令。移动方向键到“Capture full size screenshot”并回车（或直接用鼠标点击这个选项） 参考资料：https://weibo.com/ttarticle/p/show?id=2309404241869646237445 3.2 截取页面中的一些元素 进入需要截图的网站页面，打开开发者工具（方法和上面两步相同） 点击开发者工具左上角的“选取元素”按钮，在网页中点击要截图的元素 由于 HTML 父子元素的嵌套，可能选中的是需要截图元素的子元素。这时，需要在开发者工具中对所选取的元素进行调整：由于选取的是子元素，所以只需要在“选取元素”按钮，旁边的\"Elements Tab\"里边按照嵌套关系，找到合适的父元素就可以了。这时，点击选中该父元素。 打开命令行，进行截图命令（方法和上面第四步类似）。不过需要注意这时在包含 \"Screen\" 关键字的命令中选取“Capture node screenshot” powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/other/002-Chrome浏览器有用的插件.html":{"url":"doc/other/002-Chrome浏览器有用的插件.html","title":"Chrome浏览器有用的插件","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. github网站实现树状文件列表 octotree 2. Postman API接口测试插件 3. LastPass浏览器账号密码管理插件 4. Tampermonkey油猴插件 5. 恢复关闭的标签页 SimpleUndoClose 6. 多标签页管理TooManyTabs for Chrome 7.多标签页管理Tabs Outliner 8. 页面去除广告 9. Qlearly 空白页管理tab标签和书签 10. 截取整个网页 11. 删除 Reading List [TOC] 1. github网站实现树状文件列表 octotree Octotree这款插件就如同名字一样，在页面左端提供了一个树状的文件列表（类似Windows资源管理器的左栏），从而让所有文件的位置一目了然，并可以快速点击查看。 开源地址： https://github.com/buunguyen/octotree 在Google中搜索Octotree 就能找到， 同时还有一个码云版的GitCodeTree如果用码云可以安装这个。 github的其他插件： https://www.ithome.com/html/soft/310078.htm 2. Postman API接口测试插件 3. LastPass浏览器账号密码管理插件 LastPass: Free Password Manager 中文官网：https://www.lastpass.com/zh 插件安装好后，点击插件登陆，当第一次登陆网站输入账号密码结束后，插件会提示你是否保存账号，如果保存，那么下次在登录网站后就会自动田填充账号密码。 教程：https://blog.csdn.net/u012318074/article/details/77972074 4. Tampermonkey油猴插件 它既可以让你看各大视频网站的 VIP 付费视频，阻止浏览器的各种弹窗，也可以让你直接在浏览器就可以下载百度云盘的大号文件，不再需要跳往百度云盘客户端才能下载，最重要的是它可以让你百度云盘不再限速，也可以直接加速播放视频等等。...... 安装：chrome应用商店中搜索Tampermonkey， 点击安装。 Tampermonkey 使用方法， 进入相关网站后，插件就会自动运行，然后在网页中会有相应按钮。 插件网站：https://greasyfork.org/zh-CN 使用教程： https://zhuanlan.zhihu.com/p/34967781 http://www.pc6.com/infoview/Article_115189.html 5. 恢复关闭的标签页 SimpleUndoClose 安装：chrome应用商店中搜索SimpleUndoClose， 点击安装。 使用：点击插件图标，就会显示关闭的标签页列表，选择要恢复的页面即可。 6. 多标签页管理TooManyTabs for Chrome 安装：chrome应用商店中搜索TooManyTabs for Chrome， 点击安装。 使用：点击图标，选择对应的标签页可。 点击每个图标右上角的黄色箭头，可以把这个标签放在缓存中，暂时关闭，在点击一下即可恢复。 使用教程：http://www.cnplugins.com/office/toomanytabs-for-chrome/ 缺点：只会显示当前窗口中的标签页 7.多标签页管理Tabs Outliner 安装：chrome应用商店中搜索Tabs Outliner， 点击安装。 使用：点击图标，会弹出一个新窗口，里面会显示浏览器打开的所有tabs。 8. 页面去除广告 安装：chrome应用商店中搜索广告终结者， 点击安装。 广告终结者 其他去广告的插件：https://www.jianshu.com/p/ecfd133ee48e AdGuard 广告拦截器 9. Qlearly 空白页管理tab标签和书签 Qlearly - Tab and Bookmark Manager 方便的管理当前打开的tab标签页面，可以一键保存打开的tab页面，还可以管理特殊的标签。 10. 截取整个网页 Chrome浏览器自带截取整个页面的工具： 打开开发者工具(Mac：cmd + option + I，Windows：F12) 打开命令面板： Mac：shift + cmd + P, windows:Ctrl + Shift + P 输入截图命令：输入capture,会看到三个命令， capture full size screenshot:截图整个网页图片 capture node screenshot：截取当前节点的图片 capture area screenshot: 截取鼠标选择的区域 但是自带的工具有的页面不能截取全部页面。 Full Page Screen Capture Full Page Screen Capture插件可以解决截取全部页面图片的问题。安装好后，只需要点击就可截取网页全部内容，然后选择保存图片或者保存文PDF格式。 11. 删除 Reading List chrome 95 版本更新以来你会发现阅读清单关不掉了，经过网络查找： 1、打开 chrome://flags/ 2、搜索 m93 ，打开 m93 版本 enabled，重启浏览器 3、搜索 m94 ，打开 m94 版本 enabled，重启浏览器 4、搜索以前的 Reading List 选项，disabled 掉即可，重启浏览器 powered by Gitbook文件最后修改时间： 2021-11-16 17:21:27 "},"doc/other/003-gitbook入门教程.html":{"url":"doc/other/003-gitbook入门教程.html","title":"gitbook入门教程","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 gitbook使用教程 1. 说明 2. 在gitbook网站上创建一本文档书籍 2.1 登陆gitbook网站 2.2 创建一本书 2.2.1 点击新建一本书按钮 2.2.2 在创建书籍中选择github 2.3 创建书籍目录文件 3. 使用gitbook工具开发 3.1 安装gitbook-cli工具 3.2 初始化一本书 3.3 启动服务查看效果 3.4 打包生成网站书籍 3.5 生成其他格式的书籍 3.6 项目部署到GitHub Pages 3.6.1 在github上创建一个仓库 3.6.2 本地项目提交到github仓库 3.6.3 生成项目并上传到github仓库的gh-pages分支 3.6.4 配置GitHub Pages显示网站 3.7 一些部署到GitHub Pages的例子 4. gitbook的配置文件讲解 4.1 book.json中一些主要参数说明 4.2 配置默认主题 5. gitbook的一些实用插件 6. 开发遇到的问题 6.1 prismjs插件报错 6.2 gitbook 命令失败：TypeError: cb.apply is not a function [TOC] gitbook使用教程 1. 说明 gitbook网站是一个简单的个人在线书籍网站，在这里可以把自己的文档整理成书籍发布出来，便于阅读。 gitbook网站：https://legacy.gitbook.com/ 本文主要讲解在gitbook网站上发布一个书籍文档和使用gitbook提供的工具在本地开发一个书籍文档部署到自己的服务上 在此之前你需要会如下准备： 账号： github有账号，gitbook使用github账号注册 git：代码管理工具 Markdown：gitbook主要使用MD语法来编写书籍的 gitbook工具：如果你在本地开发需要安装此插件，下面有介绍 nodejs环境：gitbook插件需要的运行环境 一款Markdown编辑器：方便本地开发，推荐Typora或gitbook自己的编辑器gitbook editor 2. 在gitbook网站上创建一本文档书籍 此种方式是使用github网站加gitbook网站的方式来创建书籍的。 首先你要有一个github账号，然后在github网站中创建了一个repo仓库，用于存放书籍内容的仓库。 注意：gitbook网站有时需要使用代理才能打开。 2.1 登陆gitbook网站 gitbook网站支持直接使用github账号登陆的，推荐直接使用github账号登陆。 打开gitbook网站：https://legacy.gitbook.com/ 点击右上角的Sign In登陆，然后选择Sign in with GitHub选择使用github账号进行登陆。 第一次登陆gitbook网站时，需要github网站的认证，还需要到注册github网站的邮箱中点击确认。 2.2 创建一本书 2.2.1 点击新建一本书按钮 登陆网站后，点击右上角的用户图标，然后选择Your Profile。然后就会在右上角看见+ new按钮，点击此按钮就是创建一本书。 或者打开此链接，直接进入创建书籍页面：https://legacy.gitbook.com/new 2.2.2 在创建书籍中选择github 进入新建页面后，在左边找到GITHUB选项。 第一次需要点击右边的install github integration。 此时会跳转到github页面去安装这个插件，可以选择所有仓库或者某个仓库，然后点击install安装,输入github密码后完成安装。 此时回到gitbook新建页面刷新，选择github后，会在右边会出现如下选项： title ： 书籍的标题 description：对这本书的描述 Select a Repository: 选择github中的仓库等 Public or Private: 这本书是公开(Public)还是私有(Private)的 选项填好后，然后点击create book按钮。 注意：标题一定要是英文的，因为这要作为这本书籍的链接（创建成功后可修改名称）。 点击create book按钮后，会出现这本书籍页面，然后刷新页面，然后点击ABOUT。 然后点击右边的Read按钮即可阅读。 进入阅读后如下效果： 此时一本书籍已经在gitbook上创建完毕了。 2.3 创建书籍目录文件 经过上面的步骤后，只是创建了一本书籍，但是此时还不完整，因为缺少了书籍的目录。 首先需要在项目的根目录创建一个SUMMARY.md文件，此文件就是gitbook的目录，内容格式如下： * [说明](README.md) * HTML - [测试连接1](/doc/a.md) * JAVASCRIPT - [b文件](/javascript/b.md) 此时项目目录结构： . ├── README.md ├── SUMMARY.md ├── doc │ └── a.md └── javascript └── b.md 保存SUMMARY.md后，提交内容到github网站仓库中，需要等待一会才能在gitbook网站上看见更新内容，有时需要等很久才能更新，最终效果如下图所示： 3. 使用gitbook工具开发 上面说的在gitbook网站发布一本书虽然方便，但是有如下缺点： 1、gitbook网站经常打不开，需要使用代理才能访问 2、修改提交后有时需要很久才能显示更新 还好，gitbook还提供了基于Node.js的命令行工具，可使用 Github/Git 和 Markdown 来制作精美的电子书,然后部署到自己的网站上(或在github托管)。 gitbook命令行工具首先需要本地电脑有nodejs和终端。 一般linux系统和Mac系统自带nodejs和终端，Windows系统需要安装nodejs和终端。 windows系统推荐cmder终端,安装和介绍请自行查找。 可使用如下命令在终端查看系统是否有nodejs： node -v v8.12.0 如果出现版本号，那么说明已经安装了，如果没找到这个命令，那么进入node官网：http://nodejs.cn/，选择下载，选择对应的操作系统后下载安装即可。 gitbook命令行工具推荐nodejs版本要v4.0.0以上，如果版本过低，可看如下教程将版本升级到v4.0.0以上： https://segmentfault.com/a/11... 3.1 安装gitbook-cli工具 gitbook-cli是一个在同一系统上安装和使用多个版本的GitBook的实用程序。它将自动安装所需版本的GitBook来构建一本书。 打开终端输入npm install gitbook-cli -g命令进行全局安装： npm install gitbook-cli -g npm http fetch GET 304 https://registry.npm.taobao.org/os-tmpdir 100ms (from cache) npm http fetch GET 304 https://registry.npm.taobao.org/os-homedir 113ms (from cache) /usr/local/bin/gitbook -> /usr/local/lib/node_modules/gitbook-cli/bin/gitbook.js + gitbook-cli@2.3.2 added 578 packages from 672 contributors in 17.806s 安装成功后可使用gitbook --version来查看是否安装成功： gitbook --version CLI version: 2.3.2 GitBook version: 3.2.3 注意：终端第一次运行gitbook命令，可能会自动安装gitbook，因为刚才安装的是CLI，此时CLI会自动安装gitbook。 如果想卸载CLI，可使用npm uninstall gitbook-cli -g来删除。 3.2 初始化一本书 初始化一本书的命令是gitbook init, 首先在终端创建一个项目目录，并进入这个目录： mkdir book cd book 然后使用gitbook init来初始化一本书： ~ gitbook init warn: no summary file in this book info: create README.md info: create SUMMARY.md info: initialization is finished gitbook init会在空项目中创建README.md和SUMMARY.md两个文件： README.md文件是项目的介绍文件。 SUMMARY.md是gitbook书籍的目录。 如果SUMMARY.md文件里面有如下内容： * [项目介绍](README.md) * http * [http说明](doc/http/http解析.md) * [tcp说明](doc/http/tcp/tcp说明.md) * [udp说明](doc/http/tcp/udp/udp说明.md) * HTML * [HTML5-特性说明](doc/html/HTML5-特性说明.md) 那么在使用gitbook init时，如果目录里面的文件不存在，则会创建目录中的文件： ~ gitbook init info: create doc/http/http解析.md info: create doc/http/tcp/tcp说明.md info: create doc/http/tcp/udp/udp说明.md info: create doc/html/HTML5-特性说明.md info: create SUMMARY.md info: initialization is finished 3.3 启动服务查看效果 终端打开项目目录，使用gitbook serve启动服务： ~ gitbook serve Live reload server started on port: 35729 Press CTRL+C to quit ... info: 7 plugins are installed info: loading plugin \"livereload\"... OK …… info: loading plugin \"theme-default\"... OK info: found 5 pages info: found 0 asset files info: >> generation finished with success in 2.1s ! Starting server ... Serving book on http://localhost:4000 然后根据终端的提示，在浏览器中打开http://localhost:4000查看书籍，效果如下图所示： 注意：\\gitbook serve命令会在项目中生成一个_book的文件夹,此文件夹就是最终生成的项目。 3.4 打包生成网站书籍 可使用gitbook build命令来生成最终的项目： ~ gitbook build info: 7 plugins are installed info: 6 explicitly listed info: loading plugin \"highlight\"... OK info: loading plugin \"search\"... OK info: loading plugin \"lunr\"... OK info: loading plugin \"sharing\"... OK info: loading plugin \"fontsettings\"... OK info: loading plugin \"theme-default\"... OK info: found 5 pages info: found 0 asset files info: >> generation finished with success in 1.0s ! 命令执行结束后，会在项目下生成_book的文件夹,此文件夹就是最终生成的项目。 在_book文件夹里有一个index.html文件，这个文件就是文档网站的HTM入口，把_book文件夹复制到服务器，然后把web服务的入口引向index.html即可完成文档网站的部署。 如果你想查看输出目录详细的记录，可使用gitbook build ./ --log=debug --debug来构建查看。 3.5 生成其他格式的书籍 这里本人试了，没有成功，你可以尝试一下 GitBook 可以生成一个网站，但也可以输出内容作为电子书（ePub，Mobi，PDF）。 # Generate a PDF file $ gitbook pdf ./ ./mybook.pdf # Generate an ePub file $ gitbook epub ./ ./mybook.epub # Generate a Mobi file $ gitbook mobi ./ ./mybook.mobi 我还在网上找了一个包：https://www.npmjs.com/package/gitbook-pdf ，可以试一下 3.6 项目部署到GitHub Pages 这部分需要使用git和github网站，如果你不会，请自行在网上搜索文档查看。 由于gitbook生成的项目跟文档的源码是两个部分，所以可以把文档放到master分支上，部署的网站放到gh-pages 分支。 3.6.1 在github上创建一个仓库 这个仓库用于存放你编写的项目，和部署项目，如何创建请自行查找。 3.6.2 本地项目提交到github仓库 在项目中创建一个.gitignore文件，内容如下： # 忽略gitbook生成的项目目录 _book 然后终端打开项目，输入如下命令,来提交文档项目到github上： ~ git init ~ git add . ~ git commit -m '初始化gitbook本地项目' ~ git remote add origin https://github.com/yulilong/book.git ~ git push -u origin master 上面命令执行结束后，就会把代码提交到github上的仓库。 注意仓库地址要替换成你自己的链接。\\ 3.6.3 生成项目并上传到github仓库的gh-pages分支 由于打包命令太多，为了简单化，现在写一个脚本命令来自动执行。当然你也可以终端自己执行这些命令。 为了部署方便，可以创建一个脚本文件deploy.sh,内容如下： #!/usr/bin/env sh echo '开始执行命令' # 生成静态文件 echo '执行命令：gitbook build .' gitbook build . # 进入生成的文件夹 echo \"执行命令：cd ./_book\\n\" cd ./_book # 初始化一个仓库，仅仅是做了一个初始化的操作，项目里的文件还没有被跟踪 echo \"执行命令：git init\\n\" git init # 保存所有的修改 echo \"执行命令：git add -A\" git add -A # 把修改的文件提交 echo \"执行命令：commit -m 'deploy'\" git commit -m 'deploy' # 如果发布到 https://.github.io/ echo \"执行命令：git push -f https://github.com/yulilong/book.git master:gh-pages\" git push -f https://github.com/yulilong/book.git master:gh-pages # 返回到上一次的工作目录 echo \"回到刚才工作目录\" cd - 注意脚本文件代码中仓库地址要替换成你自己的地址。 文件保存后，在终端执行如下命令，把生成的项目推送到github仓库上的gh-pages分支： bash deploy.sh 执行成功后，打开你的github仓库，然后选择branch分支，会发现多了一个gh-pages分支，打开这个分之后，里面会有一个index.html文件。说明部署的代码上传成功了。 注意：如果没有gh-pages分支说明没有部署成功请查看刚才执行的终端看哪里报错了，解决报错直到成功部署。 3.6.4 配置GitHub Pages显示网站 在github网站上的仓库里面点击Settings -> GitHub Pages选项中 -> Source里面选择gh-pages branch 然后点击Save按钮，然后在GitHub Pages下面就会看见一个网址，这个网址就是最终的网站。 最终效果如下图所示： 3.7 一些部署到GitHub Pages的例子 https://github.com/yodaos-project/yoda-book https://gitbook.zhangjikai.com/plugins.html 4. gitbook的配置文件讲解 如果你想对你的网站有更详细的个性化配置或使用插件，那么需要使用配置文件。 配置文件写完后，需要重启服务或者重新打包才能应用配置。 gitbook的配置文件名是book.json，首先在项目的根目录中创建book.json文件。 book.json主要内容： { \"title\": \"我的一本书\", \"author\" : \"yu\", \"description\" : \"我第一本书的描述，很好\", \"language\" : \"zh-hans\", \"structure\": { \"readme\": \"introduction.md\" }, \"plugins\": [ \"-lunr\", \"-search\", \"search-pro\", \"back-to-top-button\" ], \"pluginsConfig\": { \"anchor-navigation-ex\": { \"isShowTocTitleIcon\": true } }, \"links\" : { \"sidebar\" : { \"个性链接1\" : \"https://www.baidu.com\", \"个性链接2\" : \"https://www.baidu.com\" } }, \"styles\": { \"website\": \"styles/website.css\", \"ebook\": \"styles/ebook.css\", \"pdf\": \"styles/pdf.css\", \"mobi\": \"styles/mobi.css\", \"epub\": \"styles/epub.css\" } } 4.1 book.json中一些主要参数说明 title：标题 author：作者 description：描述，对应gitbook网站的description language：使用的语言，zh-hans是简体中文，会对应到页面的 structure：指定 Readme、Summary、Glossary 和 Languages 对应的文件名，下面是这几个文件对应变量以及默认值： | Variable | Description | | --------------------- | ---------------------------------------------- | | structure.readme | Readme file name (defaults to README.md) | | structure.summary | Summary file name (defaults to SUMMARY.md) | | structure.glossary | Glossary file name (defaults to GLOSSARY.md) | | structure.languages | Languages file name (defaults to LANGS.md) | 比如想把readme文件个名字，则可以使用如下配置 \"structure\": { \"readme\": \"introduction.md\" }, 使用这个配置后，gitbook服务就不会找readme文件，而去找introduction文件当项目说明，这样就可以把readme文件完全当成代码仓库说明文档了。 plugins：使用的插件列表，所有的插件都在这里写出来，然后使用gitbook install来安装。 pluginsConfig：插件的配置信息，如果插件需要配置参数，那么在这里填写。 links：目前可以给侧导航栏添加链接信息 \"links\" : { \"sidebar\" : { \"个性链接1\" : \"https://www.baidu.com\" } } styles：自定义页面样式，各种格式对应各自的css文件 \"styles\": { \"website\": \"styles/website.css\", \"ebook\": \"styles/ebook.css\", \"pdf\": \"styles/pdf.css\", \"mobi\": \"styles/mobi.css\", \"epub\": \"styles/epub.css\" } 4.2 配置默认主题 默认的主题可以通过配置来做一下效果。 比如侧边栏菜单显示标题数字，可以在配置文件的pluginsConfig参数中写入如下字段： { \"pluginsConfig\": { \"theme-default\": { \"showLevel\": true } } } 效果如下图： 5. gitbook的一些实用插件 gitbook插件可以解决一些网站不太方便的地方，如侧边栏导航不能收缩，自带搜索不支持中文等。 用了插件书籍网站会更灵活和美观。 由于插件很多，请参考我的另一篇文章：https://segmentfault.com/a/1190000019806829 6. 开发遇到的问题 6.1 prismjs插件报错 当启动本地服务的时候，会报错： Failed to load prism syntax: ttt Error: Cannot find module 'prismjs/components/prism-ttt.js' Require stack: - /Users/dragon/tmp/wiki/node_modules/gitbook-plugin-prism/index.js 产生问题原因：markdown文件中，代码块标记的语言prismjs插件找不到这种语言，无法进行高亮。 解决方法：markdown文件中代码块标记语言要写正确，复制过来的代码块要注意编辑器自动标记的语言是否存在、正确。 6.2 gitbook 命令失败：TypeError: cb.apply is not a function 当执行gitbook build .进行项目打包的时候报错： /usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) ^ TypeError: cb.apply is not a function 问题原因：node版本太高了，gitbook工具不支持这么高的node版本。 gitbook版本： ~ gitbook -V CLI version: 2.3.2 GitBook version: 3.2.3 解决方案： 1、降低node版本即可。可以的版本：8.16.0、8.12.0、6.11.1。网络上有的说10.X版本也没问题。可以使用node版本管理工具切换。 2、修改报错的文件，node版本不需要降级。 使用编辑器打开报错的文件，找到报错的地方cb.apply(this, arguments)，大约在287行 // 文件：/usr/local/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js function statFix (orig) { if (!orig) return orig // Older versions of Node erroneously returned signed integers for // uid + gid. return function (target, cb) { return orig.call(fs, target, function (er, stats) { if (!stats) return cb.apply(this, arguments) if (stats.uid 在这个文件的第62-64行调用了这个函数，把这三行代码注释掉就可以： fs.stat = statFix(fs.stat) fs.fstat = statFix(fs.fstat) fs.lstat = statFix(fs.lstat) 然后再次运行gitbook build . 就没问题了。 参考资料：https://mizeri.github.io/2021/04/24/gitbook-cbapply-not-a-function/ 参考链接 http://blog.csdn.net/hk2291976/article/details/51173850http://www.ituring.com.cn/article/127744https://www.jianshu.com/p/7476afdd9248 powered by Gitbook文件最后修改时间： 2024-11-23 22:26:43 "},"doc/other/004-常用正则表达式.html":{"url":"doc/other/004-常用正则表达式.html","title":"常用正则表达式","keywords":"","body":"验证帐号是否合法验证规则：字母、数字、下划线组成，字母开头，4-16位。 re = /^[a-zA-z]\\w{3,15}$/; 验证手机号码验证规则：11位数字，以1开头。re = /^1\\d{10}$/ 验证电话号码验证规则：区号+号码，区号以0开头，3位或4位,号码由7位或8位数字组成区号与号码之间可以无连接符，也可以“-”连接,如01088888888,010-88888888,0955-7777777re = /^0\\d{2,3}-?\\d{7,8}$/; 验证邮箱验证规则：姑且把邮箱地址分成“第一部分@第二部分”这样第一部分：由字母、数字、下划线、短线“-”、点号“.”组成，第二部分：为一个域名，域名由字母、数字、短线“-”、域名后缀组成，而域名后缀一般为.xxx或.xxx.xx，一区的域名后缀一般为2-4位，如cn,com,net，现在域名有的也会大于4位 re = /^(\\w-.)+@(\\w-?)+(.\\w{2,})+$/ 不能输入汉字：^\\u4e00-\\u9fa5{0,}$只能输入汉字：^[\\u4e00-\\u9fa5]{0,}$ 只有字母、数字和下划线且不能以下划线开头和结尾的正则表达式：^(?!)(?!.*?$)[a-zA-Z0-9]+$只有字母和数字的： ^[a-zA-Z0-9]+$至少一个汉字、数字、字母、下划线: \"[a-zA-Z0-9\\u4e00-\\u9fa5]+\"至少一个汉字的正则表达式：\"^[\\u4e00-\\u9fa5]\"最多10个汉字: ValidationExpression=\"^[\\u4e00-\\u9fa5]{0,10}\"只含有汉字、数字、字母、下划线不能以下划线开头和结尾：^(?!)(?!.?$)[a-zA-Z0-9\\u4e00-\\u9fa5]+$解释：^ 与字符串开始的地方匹配(?!)　　不能以开头(?!.?$)　　不能以结尾[a-zA-Z0-9_\\u4e00-\\u9fa5]+　　至少一个汉字、数字、字母、下划线$　　与字符串结束的地方匹配 email正则表达式：两种方式都可以(1) \\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)(2) ^[_A-Za-z0-9-]+(\\.[_A-Za-z0-9-]+)@[A-Za-z0-9-]+(\\.[A-Za-z0-9-]+)*((\\.[A-Za-z]{2,}){1}$) /内容/i 构成一个不区分大小写的正则表达式;^ 匹配开始$ 匹配结束表示0个或多个前面的字符.[a-z0-9] 匹配0个或多个英文字母或者数字[-_]? 匹配0个或1“-”，因为“-”不能连续出现[a-z0-9]+ 匹配1个或多个英文字母或者数字，因为“-”不能做为结尾[.] 将特殊字符(.)当成普通字符[a-z]{2,3} 匹配2个至3个英文字母，一般为com或者net等. powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/other/005-HTTP方法详解.html":{"url":"doc/other/005-HTTP方法详解.html","title":"HTTP方法详解","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 名词解释 1. OPTIONS 2. GET 3. HEAD 4. POST 5. PUT 6. DELETE 7. TRACE 按照RFC2616的排序，HTTP的方法包括：OPTIONS，GET，HEAD，POST，PUT，DELETE，TRACE。 名词解释 安全性：客户端可以发起请求，并知道它不会改变资源的状态。 幂等性：保证客户端重复发起某个请求的效果与一次请求的效果一致。 1. OPTIONS 使用该方法来获取资源支持的HTTP方法列表，或者ping服务器。显然，它就是一个纯粹的信息读取的操作，不改变资源的状态，同时保证幂等性。 请求：只有header没有body。 响应：默认只有header，但是也可以在body中添加内容，比如描述性文字 安全：是 幂等：是 2. GET 该方法用以获取资源的表述。简单的资源信息读取，不对资源状态造成影响，保证幂等性。 请求：只有header，没有body。 响应：对应请求URI的资源表述，通常带有body。响应header中的Content-Type，Content-Length，Content-Language，Last-Modified，ETag等应该和响应body的表述一致。 安全：是 幂等：是 3. HEAD 使用该方法可以获取与GET响应相同的header，但是响应中没有任何body。简单的资源信息读取，不对资源状态造成影响，保证幂等性。 请求：只有header，没有body。 响应：只有header，没有body。服务器不能添加body。 安全：是 幂等：是 4. POST 让资源在服务器上执行一系列操作，如创建新资源、更新资源、变更资源等。是一个资源写的操作，改变了资源的状态，同事HTTP标准设定POST方法为非幂等，也就是说不需要在实现服务端响应方法的时候，我们不需要保证幂等，这也就避免了很多冗余信息(我们会在DELETE中看到)。 请求：一个资源的表述。 响应：一个资源的表述，或是一个重定向指令。如果body中存在表述，则其URI和请求URI不一致，包含一个带有改资源URI的Content-Location头。 安全：否 幂等：否 5. PUT 完整地更新或替换一个现有资源，也可以用客户端制定的URI来创建一个新资源。和POST方法一样，PUT方法也改变了资源的状态，所以是非安全的。但是有一点和POST不同，它是幂等的，这是为什么呢？想想setter函数吧，重复调用，只要参数是一样的，表述就是不变的。 请求：一个资源的表述。请求的body可以与客户端后续收到的GET请求一样,当然，也可以不一样。在某些情况下，服务器也可要求客户端只提供资源的可变部分。 响应：更新的状态。可在响应中包含被更新资源的完整表述，但是客户端不能假设响应中包含完整状态，除非响应有一个Content-Location头。如果服务器没有包含这个头，客户端必须提交一个无条件GET请求来获取更新后的表述，带有Last-Modified和/或ETag头。 安全：否 幂等：是 6. DELETE 使用该方法来删除资源。对于客户端而言，资源在成功响应后，就不复存在了。和POST方法一样，DELETE方法也改变了资源的状态，所以是非安全的。但是有一点和POST不同，它是幂等的，也就是说，就算是服务器在前一个请求中已经删除了资源，它也必须返回200.这就意味着，我们在实现服务端的该方法是，需要跟踪已经删除的资源，否则就会返回404的。 请求：只有header，没有body。 响应：成功或失败。body中可以包含操作的状态。 安全：否 幂等：是 7. TRACE 回显服务器接收到的header。支持该方法的服务器可能存在XST安全隐患。 安全： 幂等： 请求：header与body。 响应：body中包含整个请求消息。 参考链接： http://www.tuicool.com/articles/3eaUJbu powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/other/006-Markdown常用语法.html":{"url":"doc/other/006-Markdown常用语法.html","title":"Markdown常用语法","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Markdown常用语法与编辑器支持情况 1. 脚注语法 2. 表格 3. html语法的支持 3.1 HTML的表格 4. 数学公式 [TOC] Markdown常用语法与编辑器支持情况 1. 脚注语法 需要脚注的地方： 这是一个注脚[^footnote]的样例。 这是第二个注脚[^footnote2]的样例。 md文档最下面写明脚注： [^footnote]: 这是一个 *注脚* 的 **文本**。 [^footnote2]: 这是另一个 *注脚* 的 **文本**。 支持的编辑器： bitbucket、www.zybuluo.com 不支持的网站：https://github.com ， 码云网站wiki不行。 2. 表格 语法： -------:为右对齐。 :------为左对齐。 :------:为居中对齐。 -------为使用默认居中对齐。 | 项目 | 价格 | 数量 | | -------- | -----: | :----: | | 计算机 | \\$1600 | 5 | | 手机 | \\$12 | 12 | | 管线 | \\$1 | 234 | 效果： 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 支持的情况：bitbucket、github、https://www.zybuluo.com、VSCODE、 3. html语法的支持 3.1 HTML的表格 值班人员 星期一 星期二 星期三 李强 张明 王平 支持的编辑器： github、码云、www.zybuluo.com 4. 数学公式 参考资料：https://www.jianshu.com/p/4460692eece4 $ J\\alpha(x) = \\sum{m=0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha} \\text {，行内公式示例} $ $ J_\\alpha(x) = \\sum_{m=0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha} \\text {，行内公式示例} $ $$ J\\alpha(x) = \\sum{m=0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha} \\text {，独立公式示例} $$ $$ J_\\alpha(x) = \\sum_{m=0}^\\infty \\frac{(-1)^m}{m! \\Gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha} \\text {，独立公式示例} $$ $$ x^{y^z}=(1+{\\rm e}^x)^{-2xy^w} $$ $$ x^{y^z}=(1+{\\rm e}^x)^{-2xy^w} $$ $$ \\sideset{^1_2}{^3_4}\\bigotimes $$ $$ \\sideset{^1_2}{^3_4}\\bigotimes $$ 输入分数: 通常使用 \\frac {分子} {分母} 命令产生一个分数，分数可嵌套。 便捷情况可直接输入 \\frac ab 来快速生成一个分数。 如果分式很复杂，亦可使用 分子 \\over 分母 命令，此时分数仅有一层。 $$\\frac{a-1}{b-1} \\quad and \\quad {a+1\\over b+1}$$ $$\\frac{a-1}{b-1} \\quad and \\quad {a+1\\over b+1}$$ 输入开方 $$\\sqrt{2} \\quad and \\quad \\sqrt[n]{3}$$ $$\\sqrt{2} \\quad and \\quad \\sqrt[n]{3}$$ 输入省略号： $$f(x1,x_2,\\underbrace{\\ldots}{\\rm ldots} ,xn) = x_1^2 + x_2^2 + \\underbrace{\\cdots}{\\rm cdots} + x_n^2$$ $$f(x1,x_2,\\underbrace{\\ldots}{\\rm ldots} ,xn) = x_1^2 + x_2^2 + \\underbrace{\\cdots}{\\rm cdots} + x_n^2$$ 输入矢量： $$\\vec{a} \\cdot \\vec{b}=0$$ $$\\vec{a} \\cdot \\vec{b}=0$$ $$\\overleftarrow{xy} \\quad and \\quad \\overleftrightarrow{xy} \\quad and \\quad \\overrightarrow{xy}$$ $$\\overleftarrow{xy} \\quad and \\quad \\overleftrightarrow{xy} \\quad and \\quad \\overrightarrow{xy}$$ 输入积分： $$\\int_0^1 {x^2} \\,{\\rm d}x$$ $$\\int_0^1 {x^2} \\,{\\rm d}x$$ powered by Gitbook文件最后修改时间： 2020-07-22 00:12:09 "},"doc/other/007-VS2010编译器设置.html":{"url":"doc/other/007-VS2010编译器设置.html","title":"VS2010编译器设置","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 字体设置 显示行号 vs2010 瘦身--ipch文件夹和sdf文件配置 字体设置 https://jingyan.baidu.com/article/4ae03de31cd98b3eff9e6bfd.html 工具 -> 选项 -> 环境 -> 字体和颜色 显示行号 https://jingyan.baidu.com/article/a378c96085a247b3282830e9.html 工具 -> 选项 -> 文本编辑器-> 所有语言 -> 显示：行号 vs2010 瘦身--ipch文件夹和sdf文件配置 http://blog.csdn.net/yizhou2010/article/details/52743578 将ipch文件夹和sdf文件放置在固定的目录下，定期清理。设置如下：工具（Tools）->选项（Options）->文本编辑器（Text Editor）-> C/C++ -> 高级（Advanced），在”回退位置（Fallback Location）”的属性组中，将”始终使用回退位置（Always Use Fallback Location）”设置为 true，将”回退位置已在使用时，不警告（Do Not Warn If Fallback Location Used）” 设置为 true ，然后删除解决方案目录下的 sdf 文件和 ipch 目录，再次打开解决方案，发现这些烦人的东西已经不见了。 那么那些文件放置到那里了呢？看 “回退位置（Fallback Location）” 属性说明：这是存储浏览信息数据库和 IntelliSense 文件的第二个位置，如果不指定则放置到临时目录中；到临时目录一看，里面有一个 VC++ 的目录，都在那个目录里面呢。可以在 “回退位置（Fallback Location）” 属性中，设置一个固定的路径来存储这些文件，比如D:\\VS2010Temp，这样也比较好管理这些庞大的臃肿的文件，可以定期清理掉它们，释放出硬盘空间！ powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/other/008-VS2010开发控制台程序遇到的问题.html":{"url":"doc/other/008-VS2010开发控制台程序遇到的问题.html","title":"VS2010开发控制台程序遇到的问题","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 fatal error C1010: 在查找预编译头时遇到意外的文件结尾。是否忘记了向源中添加“#include \"stdafx.h vs2012 error c4996: 'fopen': This function or variable may be unsafe [TOC] fatal error C1010: 在查找预编译头时遇到意外的文件结尾。是否忘记了向源中添加“#include \"stdafx.h 1) 在解决方案资源管理器中，右击相应的.cpp文件，点击“属性”2) 在左侧配置属性中，点开“C/C++”，单击“预编译头”3) 更改右侧第一行的“创建/使用预编译头”，把选项从“使用预编译头（/Yu）”改成“不使用预编译头”4) 注：每一个报错的.cpp都要如此更改 vs2012 error c4996: 'fopen': This function or variable may be unsafe 错误信息: 1>------ 已启动生成: 项目: 20130925, 配置: Debug Win32 ------ 1> stdafx.cpp 1>d:\\code\\20130925\\20130925\\stdafx.cpp(18): error C4996: 'fopen': This function or variable may be unsafe. Consider using fopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details. 1> d:\\vs2012\\vc\\include\\stdio.h(218) : 参见“fopen”的声明 1> 20130925.cpp 1> 正在生成代码... ========== 生成: 成功 0 个，失败 1 个，最新 0 个，跳过 0 个 ========== 解决方法：项目 =》属性 =》c/c++ =》预处理器=》点击预处理器定义，编辑，加入_CRT_SECURE_NO_WARNINGS，即可。 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/other/009-阻止定向广告.html":{"url":"doc/other/009-阻止定向广告.html","title":"阻止定向广告","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 使用Chrome浏览器并登陆账号了 百度搜索关闭定向广告 必应搜索引擎关闭定向广告 使用Chrome浏览器并登陆账号了 https://support.google.com/ads/answer/2662922?hl=zh-Hans 在这里页面里面 -> 如果你已经登陆自己的Google账户 -> 广告设置 -> 广告个性化 - 关闭 百度搜索关闭定向广告 打开百度 -> 最下面的 '使用百度前必读' -> 隐私保护声明 -> 大约中间位置'个性化配置' -> 选择停用 必应搜索引擎关闭定向广告 打开必应搜索 -> 页面最下面'隐私声明和Cookie' -> 在’如何访问和控制你的个人数据‘里面选择 '选择退出页面' -> 此浏览器中基于兴趣的广告 关闭 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/other/010-英文字母缩写的含义.html":{"url":"doc/other/010-英文字母缩写的含义.html","title":"英文字母缩写的含义","keywords":"","body":" ORM ORM（Object Relational Mapping）：对象关系映射ORM框架：对象-关系映射（Object/Relation Mapping，简称ORM），是随着面向对象的软件开发方法发展而产生的。面向对象的开发方法是当今企业级应用开发环境中的主流开发方法，关系数据库是企业级应用环境中永久存放数据的主流数据存储系统。对象和关系数据是业务实体的两种表现形式，业务实体在内存中表现为对象，在数据库中表现为关系数据。内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多关联和继承关系。因此，对象-关系映射(ORM)系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。ORM方法论基于三个核心原则： 简单性：以最基本的形式建模数据。 传达性：数据库结构被任何人都能理解的语言文档化。 精确性：基于数据模型创建正确标准化了的结构。 http://blog.csdn.net/titilover/article/details/6911756http://www.cnblogs.com/wisdo/p/4279091.html powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/work/中证/001-eslint配置和规范说明.html":{"url":"doc/work/中证/001-eslint配置和规范说明.html","title":"eslint配置和规范说明","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 项目代码规范 1. 为什么要有开发规范? 2. ESLint和一些常用规范介绍 2.1 ESLint工具介绍 2.1.1 ESLint配置文件 2.1.2 .eslintignore文件介绍 2.1.3 使用 2.2 airbnb 规范 3. vscode编辑器ESLint插件使用 4. 一些不符合规范的例子 4.1 声明了一个变量，但是没使用 4.1.1 import 一个库或方法，没有用的时候要删除或注释 4.2 代码要正确的缩进,包括JSX中标签 4.3 react组件的props属性、state状态的变量要解构赋值使用 4.4 取消一个无法修改的例子 4.5 禁止嵌套三元表达式 4.6 禁止使用==和!=要使用严格相等 4.7 禁止指定语法 4.8 类组件state、变量声明要放在构造函数中 4.9 if语句里面有return不需要在写else了 4.10 console语句不要提交到仓库中 4.11 render方法里面不要放大段的变量声明，不必要的逻辑移出去 4.12 禁止在代码中使用魔鬼数字 4.13 禁止在html中使用行内样式 4.14 html中类名使用\"ant-tabs\"不要使用style.antTabs 5. 其他的建议 5.1 文件扩展名 5.2 react版本升级后，旧的声明周期不建议使用 5.3 要有注释：文件头、方法说明 5.4 react 组件命名 5.5 项目目录安排问题 5.6 一个组件文件内容最好不要超过300行 5.7 JSX中引入图片问题 6. 一些可以关闭的eslint规则 6.1 func-names 6.2 react/jsx-filename-extension 7. 开发过程中遇到的其他问题 7.1 组件属性里面不能放结构this.props，不能放太多方法声明 [TOC] 项目代码规范 1. 为什么要有开发规范? 由于项目开发多成员协作问题，程序员开发习惯不同，项目的不断迭代会导致代码质量问题、代码维护问题、可读性问题的出现，所以好的校验工具可以确保一个项目遵循代码规范、避免一些常见的隐患出现~ 使 JavaScript 代码风格保持一致 使代码容易被理解和被维护。 编码规范能帮助我们降低编程中不必要的麻烦。 降低代码的调试成本和维护成本 2. ESLint和一些常用规范介绍 2.1 ESLint工具介绍 中文官网：http://eslint.cn/ ESLint 是一个开源的 JavaScript 和 JSX 检查工具，ESLint 的所有规则都被设计成可插入的。ESLint 的默认规则与其他的插件并没有什么区别，规则本身和测试可以依赖于同样的模式。为了便于人们使用，ESLint 内置了一些规则，当然，你可以在使用过程中自定义规则。 JavaScript 是一个动态的弱类型语言，在开发中比较容易出错。因为没有编译程序，为了寻找 JavaScript 代码错误通常需要在执行过程中不断调试。像 ESLint 这样的可以让程序员在编码的过程中发现问题而不是在执行的过程中。 2.1.1 ESLint配置文件 ESlint 被设计为完全可配置的，你可以关闭每一个规则而只运行基本语法验证，或混合和匹配 ESLint 默认绑定的规则和你的自定义规则，让 ESLint 更适合你的项目。有两种主要的方式来配置 ESLint： 配置注释：使用 JavaScript 注释把配置信息直接嵌入到一个代码源文件中 配置文件：使用 JavaScript、JSON 或者 YAML 文件为整个项目指定配置信息，配置文件名一般是.eslintrc.*文件，ESLint 会查找和自动读取它们 一个配置文件的主要配置信息： module.exports = { // 指定一个解析器， 默认是Espree， 需要安装babel-eslint包 parser: 'babel-eslint', // 使用的检查规则 extends:['airbnb', 'prettier', ], // 指定你想要支持的 JavaScript 语言选项 env: { // 浏览器环境中的全局变量 browser: true, // Node.js 全局变量和 Node.js 作用域。 node: true, // 启用除了 modules 以外的所有 ECMAScript 6 特性 es6: true, // 添加所有的 Mocha 测试全局变量 mocha: true, jest: true, jasmine: true, }, // 全局变量，当访问当前源文件内未定义的变量时，no-undef 规则将发出警告。配置这些全局变量，这样 ESLint 就不会发出警告了。 globals: { page: true, ANT_DESIGN_PRO_ONLY_DO_NOT_USE_IN_YOUR_PRODUCTION: true, }, // 自定义规则处，可以取消一个规则，也可以添加一个规则，key是具体规则，value是该规则的开关，值： // \"off\" 或 0：关闭规则， // \"warn\" 或 1：开启规则，使用警告级别的错误：warn (不会导致程序退出) // \"error\" 或 2：开启规则，使用错误级别的错误：error (当被触发的时候，程序会退出) rules: { 'react/jsx-filename-extension': [1, { extensions: ['.js'] }], 'react/jsx-wrap-multilines': 0, 'react/prop-types': 0, 'react/forbid-prop-types': 0, 'react/jsx-one-expression-per-line': 0, 'import/no-unresolved': [2, { ignore: ['^@/', '^umi/'] }], }, } 具体配置文件配置方法：http://eslint.cn/docs/user-guide/configuring eslint rules 的详细规则：http://eslint.cn/docs/rules/ vue的eslint rules规则：https://eslint.vuejs.org/rules/ 2.1.2 .eslintignore文件介绍 .eslintignore用来配置不需要检查规则的文件或文件夹，比如下载的第三方库文件、项目自动生成的文件等。 书写规则与.gitignore文件一样。 /lambda/ /scripts /config 2.1.3 使用 首先需要安装依赖包，在package.json的文件里面添加依赖包： \"scripts\": { \"start\": \"umi dev\", \"build\": \"umi build\", \"lint\": \"npm run lint:js && npm run lint:ts && npm run lint:style && npm run lint:prettier\", \"lint-staged\": \"lint-staged\", \"lint-staged:js\": \"eslint --ext .js\", \"lint-staged:ts\": \"tslint\", \"lint:fix\": \"eslint --fix --ext .js src tests && npm run lint:style && npm run tslint:fix\", \"lint:js\": \"eslint --ext .js src tests\", \"lint:prettier\": \"check-prettier lint\", \"lint:style\": \"stylelint --fix \\\"src/**/*.less\\\" --syntax less\", \"lint:ts\": \"tslint -p . -c tslint.yml\", }, \"devDependencies\":{ \"babel-eslint\": \"^10.0.1\", \"eslint\": \"^5.16.0\", \"eslint-config-airbnb\": \"^17.1.0\", \"eslint-config-prettier\": \"^4.3.0\", \"eslint-plugin-babel\": \"^5.3.0\", \"eslint-plugin-compat\": \"^3.1.1\", \"eslint-plugin-import\": \"^2.17.3\", \"eslint-plugin-jsx-a11y\": \"^6.2.1\", \"eslint-plugin-markdown\": \"^1.0.0\", \"eslint-plugin-react\": \"^7.13.0\", } 也可以在终端使用命令单独检查一个文件： ~ npx eslint src/pages/Info/StepForm/Step3.js 8:3 error 'Alert' is defined but never used 9:3 error 'Divider' is defined but never used ✖ 199 problems (196 errors, 3 warnings) 130 errors and 0 warnings potentially fixable with the `--fix` option. 2.2 airbnb 规范 airbnb规范规定了JS代码书写规范。 英文版：https://github.com/airbnb/javascript 中文版：https://github.com/lin-123/javascript 中文版的网站：https://lin-123.github.io/javascript/ react规范：https://github.com/lin-123/javascript/tree/cn/react 3. vscode编辑器ESLint插件使用 由于上面使用命令行形式很麻烦，一般都不用。 而vscode的插件ESLint可以很好的解决这个问题，这个插件会实时在代码里面标记出不规范的代码，并给出修改意见。 ESLint 如果想在保存文件时，自动修改代码为符合eslint规范，在配置文件中添加如下配置： \"editor.codeActionsOnSave\": { \"source.fixAll\": true, \"source.fixAll.eslint\": true }, 注意，这种配置会有隐藏bug，比如修改一个第三方库文件时候，会自动修改为高级语法(var 变成 let)，导致报错。 当安装好ESLint插件后，打开一个文件后，不符合规范的代码会有红线提示： 如果想知道为什么这个不合符合规范，可以点击提示信息后面的链接，链接打开的页面会详细说明不好原因，以及怎么写最好。 点击Quick Fix...按钮出现如下弹窗，选择对应选项解决一个或这个文件所有能解决的问题 4. 一些不符合规范的例子 4.1 声明了一个变量，但是没使用 说明：https://eslint.org/docs/rules/no-unused-vars 声明一个未使用的变量，这样的变量会占用代码中的空间，并可能导致读者感到困惑。 解决方法： 1、删除。 2、如果下次可能会用到，或者以后可能会用到，可以把这个变量注释掉。 4.1.1 import 一个库或方法，没有用的时候要删除或注释 经过对项目打包优化发现，如果import一个库有，即使没有在代码中使用，但是打包后，还是把import的库打包进了项目中，因此，为了优化考虑，也要把不用的删除或注释掉。 4.2 代码要正确的缩进,包括JSX中标签 const isZero = (value) => { if (value === 0 || value === '0') { return true; } else { return !!(value && value !== undefined && value !== \"\"); } }; const isZero = (value) => { if (value === 0 || value === '0') { return true; } return !!(value && value !== undefined && value !== \"\"); }; 4.3 react组件的props属性、state状态的变量要解构赋值使用 this.props、this.state对象的属性要解构赋值后在使用。 4.4 取消一个无法修改的例子 如上图所示，compat/compat规则是检查浏览器兼容性的规则。 这个规则提示了IE11浏览器不支持Headers，请查找资料，是否有替代方案，使用兼容性好的方法解决这个问题。 如果没有更好的方案，并且不需要管IE11浏览器，则可以点击Quick Fix...然后禁用这行的检查即可。 4.5 禁止嵌套三元表达式 嵌套三元表达式会使代码更难以理解。可以使用if else代替或者switch： 4.6 禁止使用==和!=要使用严格相等 不严格相等会有隐式转换，有时会产生未知的问题，比如[] == ![]、3 == \"03\" 都是相等的。 比如下面图片中record.fundScale.toString() 返回字符串， 但是value的类型是number。 4.7 禁止指定语法 由于有的语法有超出开发人员的本意，所以有的禁止使用，这个按照提示修改成替代语法即可。 4.8 类组件state、变量声明要放在构造函数中 类组件中，constructor(props)要放在类内最顶部，并且state、变量要在构造函数中声明。 4.9 if语句里面有return不需要在写else了 如上图所示，在if语句里面有return时，不需要在写else语句了，如果if语句没执行，下面也会正常执行的。 4.10 console语句不要提交到仓库中 console语句在开发时候可以存在，但是不要提交到代码仓库中，如果不小心提交了，下次要删除。 console语句会给不怀好意的人留下信息。比如下面的代码，如果this.props里面有用户敏感信息，那么就造成信息泄漏了。 4.11 render方法里面不要放大段的变量声明，不必要的逻辑移出去 由于render()方法会频繁执行，在这里声明的变量，每次执行后都会重新声明一次，会占用比较多内存，并影响性能，所以一些常量声明、方法移到render外面。render里面只放跟渲染有关的代码。 src/pages/User/RegisterLegalStepForm/Step1.js 4.12 禁止在代码中使用魔鬼数字 魔鬼数字的定义：在代码中没有具体含义的数字、字符串。 魔鬼数字主要影响了代码可读性，读者看到的数字无法理解其含义，从而难以理解程序的意图。当程序中出现的魔鬼数字过多时，代码的可维护性将会急剧下降，代码变得难以修改，并容易引入错误。 解决：定义一个对象，key是汉字英文，value是常量。 4.13 禁止在html中使用行内样式 1、保持代码简洁，既然有样式文件，就把样式写在样式文件中。 2、行内样式优先级较高，如果在样式文件也有对应样式声明，会导致文件中无效，从而产生隐藏bug。 4.14 html中类名使用\"ant-tabs\"不要使用style.antTabs 不建议使用如下形式： 暂无数据 src/pages/Dashboard/Workplace.js 如果为了避免命名冲突，可在组件中根HTML标签使用style.father形式，然后其他使用正常形式： .father { :global { .recent-visits { height: 50px; } } } 5. 其他的建议 5.1 文件扩展名 JSX文件扩展名使用.jsx，JavaScript文件的扩展名才用.js。 5.2 react版本升级后，旧的声明周期不建议使用 react新旧声明周期 由于react升级后，对react进行了大量的优化，解决react性能问题(如更新页面卡顿)，由于一些旧的生命周期影响性能，所以弃用了一些生命周期，新版本后不再推荐使用，并且浏览器也会报warning。 如上图的componentWillMount()不再推荐使用，可使用componentDidMount()替代 5.3 要有注释：文件头、方法说明 一个文件的顶部要有注释，用于说明文件的用处、作者、时间： /** * 功能: * 作者: * 日期: */ 一个方法也需要有注释，用于说明方法作用，参数作用： /** * 函数功能说明 * * @param {Object} data 选择的条件 * @return {*} 有返回值在写这个，没有不写return */ // 如果没有参数，就直接使用这种形式说明一下函数作用即可 5.4 react 组件命名 一个组件一个文件夹，子组件在自己的文件夹中，通用的组件放到公共文件夹，如下面图片的例子： 5.5 项目目录安排问题 正常来说，每个页面都会在对应page文件夹下有对应文件夹。 比如：http://localhost:8000/portal/customInfo/list 页面正常应该在page文件夹下，但是组件却在custom/routes/Neris/CustomInfo下面 在下图中： Dashboard文件夹下组件和文件夹名称不符。 Info文件夹下，要有一个index.jsx文件或Info.jsx文件。 User文件夹下组件有的没有放在文件夹下 5.6 一个组件文件内容最好不要超过300行 文件内容太多，那么里面处理的逻辑就多，时候查找，比较麻烦，可以适当的拆分成子组件。 5.7 JSX中引入图片问题 应用图片使用import是一种方式，还有一种更简洁的方法： 6. 一些可以关闭的eslint规则 6.1 func-names 此规则规定函数必须要有明细，不允许有匿名函数，但是有的地方不需要函数名，比如函数组件： import React from 'react'; // import { } from 'antd'; // import './index.less'; const RecentVisits = function ({ data, }) { console.log('data: ', data); return ( 具体内容 ) } export default RecentVisits; 6.2 react/jsx-filename-extension 'react/jsx-filename-extension': [1, { extensions: ['.js'] }] 此条规则规定了，在jsx文件中，不允许有jsx语法。这个是不合理的。jsx文件中就需要有jsx语法的。 7. 开发过程中遇到的其他问题 7.1 组件属性里面不能放结构this.props，不能放太多方法声明 在引入的组件里面，如下图所示： 1、属性是方法，方法要拿到外面声明去。 2、属性里面不可以直接结构this.props属性，首先，props里面属性很多，导致很多无用的属性也给了组件，导致在查看的时候，不知道哪个属性有用，其次，过多的无用属性印象性能，因为只要有一个属性发生变化，组件就有可能重新渲染 powered by Gitbook文件最后修改时间： 2021-07-01 09:40:14 "},"doc/work/中证/002-前端打包大小优化.html":{"url":"doc/work/中证/002-前端打包大小优化.html","title":"前端打包大小优化","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 前端打包大小优化 1. 优化之前的项目包大小 2. 优化分析 2.1 BizCharts.js的优化 [TOC] 前端打包大小优化 1. 优化之前的项目包大小 https://pro.ant.design/docs/build-cn 使用npm run analyze后查看： stat: 文件输入前的大小 parsed： 文件经过webpack打包后的大小，也是浏览器接收的文件大小。 gzip： 这是通过gzip压缩运行解析的包/模块的大小。 2. 优化分析 2.1 BizCharts.js的优化 由于查看，发现只有src/components/Charts文件夹下使用了bizcharts库，这个文件夹只有src/pages/Dashboard/Workplace.js组件使用了，可考虑更换为echarts图表并使用echarts的按需加载来减少包的大小。 使用echarts替换后，打包大小： 可以看到，misc.bf01f0e0.async.js文件比之前小了0.12MB p__Dashboard__Workplace.c7b08794.async.js文件比之前小了640KB。 项目共计小了：0.75MB。 powered by Gitbook文件最后修改时间： 2021-06-24 16:40:09 "},"doc/angular/001-angularJS资料.html":{"url":"doc/angular/001-angularJS资料.html","title":"angularJS资料","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 angular4 工作 angular2下arcgis开发 angular2相关资料 Bootstrap JavaScript JavaScript视频教程 TypeScript HTML CSS 菜鸟教程 http://www.runoob.com/ 手册网 http://www.shouce.ren/ w3school http://www.w3school.com.cn/ return home 目录结构 [TOC] angular4 angular-CLI中一些问题 网页编程中HTML,CSS中遇到的问题 工作 angularJS开发遇见的问题 web前端生产环境打包部署 Mac下angular开发环境安装 工作开发参考这个是工作中开发的参考文档 angular2开发知识点API 网关地址 配置，服务注册使用，模块组件注册使用，CSS样式条件绑定，阻止点击事件冒泡 angular2网页前端执行流程 html常用正则表达式 angular2中引入插件jQuery, easyui， ngx-img: 图片上传插件 TS_JS中一些知识点 jas前端样式规范 前端编程规范 码云前端文档 angular2下arcgis开发 arcgis开发记录 aangular下arcgis开发遇见的问题 angular2相关资料 NPM使用介绍 NPM安装包常见问题 package.json文件详解 angularJS官方文档https://angular.cn/https://angular.cn/docs/ts/latest/ 这个里面包含： 快速起步 开发指南 API 参考 (v2.4.5) 大漠穷秋angular2示例有视频教程 http://git.oschina.net/mumu-osc/NiceFish Angular2优质学习资源收集 https://my.oschina.net/mumu/blog/831790 编辑器： 下载地址： https://code.visualstudio.com帮助文档：https://code.visualstudio.com/docs AngularJS执行流程详解 http://www.cnblogs.com/shytong/p/5011411.html Webpack入门 http://www.cnblogs.com/kagol/archive/2016/01/23/5152734.html rxjs官方文档中文翻译(observable可观察对象) https://www.gitbook.com/book/buctwbzs/rxjs/details Promise 对象 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise Bootstrap http://www.bootcss.com/ 全局 CSS 样式：http://v3.bootcss.com/css/ JavaScript javascript一些问题立即执行函数 JavaScript语法 怎么轻松学习JavaScript this 的值到底是什么？ 什么是 JS 原型链？ JS 的 new 到底是干什么的？ JavaScript 教程(菜鸟教程)： http://www.runoob.com/js/js-tutorial.html JavaScript 教程(手册网)： http://www.shouce.ren/api/view/a/823 AngularJS教程、实例、参考手册(手册网) http://www.shouce.ren/api/view/a/3079 廖雪峰 JavaScript教程(手册网) http://www.shouce.ren/api/view/a/13858 JavaScript 语言参考(微软文档)： https://msdn.microsoft.com/zh-cn/library/d1et7k7c(v=vs.94).aspxJavaScript 语言参考， JavaScript 基础， 高级 JavaScript， JavaScript 参考， JavaScript 参考手册(w3school)：http://www.w3school.com.cn/jsref/index.asp AngularJS 参考手册(w3school)： http://www.w3cschool.cn/angularjs/angularjs-reference.html JavaScript： https://developer.mozilla.org/zh-CN/docs/learn/JavaScript JavaScript 指南： https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide本指南分为以下章节： 介绍， 语法与数据类型， 控制流与错误处理， 循环与迭代， 函数， 表达式和运算符， 数字和日期， 文本格式化索引集合， 键值集合， 处理对象， 对象模型的细节， 迭代器与生成器， 元 (meta) 编程 JavaScript视频教程 JavaScript深入浅出http://www.imooc.com/learn/277 JavaScript基础教程 http://www.jikexueyuan.com/course/179.html TypeScript入门http://www.imooc.com/learn/763 TypeScript TypeScript官方文档： https://www.tslang.cn/docs/tutorial.html ECMAScript 6 入门 http://es6.ruanyifeng.com/ REPL在线编译器，可以在线将 ES6 代码转为 ES5 代码http://babeljs.io/ 30分钟掌握ES6/ES2015核心内容 : http://www.jianshu.com/p/ebfeb687eb70 HTML CSS CSS 资源大全中文版 JavaScript 资源大全中文版 JavaScript深入系列、JavaScript专题系列、ES6系列、React系列 菜鸟教程 http://www.runoob.com/ HTML 定义了网页的内容，CSS 描述了网页的布局，JavaScript 网页的行为 AngularJS 教程 ： http://www.runoob.com/angularjs/angularjs-tutorial.html AngularJS2 教程http://www.runoob.com/angularjs2/angularjs2-tutorial.html HTML 教程- (HTML5 标准)： http://www.runoob.com/html/html-tutorial.html CSS 教程： http://www.runoob.com/css/css-tutorial.html 手册网 http://www.shouce.ren/ 参考手册速查 http://www.shouce.ren/api/index CSS参考手册： http://www.shouce.ren/docs/css/ HTML 教程： http://www.shouce.ren/api/view/a/7 HTML快速参考手册： http://www.shouce.ren/api/html/kuaisu/ w3school http://www.w3school.com.cn/ HTML 参考手册：http://www.w3school.com.cn/tags/index.asp CSS 参考手册：http://www.w3school.com.cn/cssref/index.asp Web API 接口： https://developer.mozilla.org/zh-CN/docs/Web/API CSS参考手册： http://css.doyoe.com/ powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/angular/002-angularJS开发遇见的问题.html":{"url":"doc/angular/002-angularJS开发遇见的问题.html","title":"angularJS开发遇见的问题","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1、开发环境下 npm install 编译进行一半就停止 2、 WEBPACK_EXTERNAL_MODULE_XX is not defined 3、Angular2管理外部类型定义和处理“Duplicate identifier” TypeScript错误 4、Module build failed: TypeError: Cannot read property 'exclude' of undefined 5、Node Sass does not yet support your current environment: OS X 64-bit with Unsupported runtime 6、Node Sass could not find a binding for your current environment: OS X 64-bit with Node.js 6.x 7、DI错误 8. error：cannot find defined file ‘jquery’ 9. Error: No NgModule metadata found for '[object Object]' 10. TypeError: Cannot read property 'split' of undefined 11. 模板语法绑定错误 12. 浏览器不识别大写地址，如big-Data， 13. Refused to display 'URL' in a frame because it set 'X-Frame-Options' to 'sameorigin' 13. cnpm安装报错：Install fail! Error: EACCES: permission denied, 14. ng serve:Error: Cannot find module 'color-convert' [TOC] 1、开发环境下 npm install 编译进行一半就停止 问题分析：npm install 包没有安装完全， 解决方法 删除项目目录下面的 node_modules 文件夹，运行命令：npm install，npm start，多试几次。 更换npm安装源： # 安装npm 镜像源管理包 ~ npm install nrm -g # 下面命令会列出npm镜像源 ~ nrm ls # 选择淘宝的镜像源 ~ nrm use taobao 然后从复方法一的步骤，尝试10次后就不要再尝试了，说明这个方法不管用。 从同事那里把已经成功的 node_modules 文件夹 复制过来，放到工程目录下面，然后运行命令：# 如果操作系统不同，就需要运行下面的命令来从新绑定系统 ~ npm rebuild node-sass # 启动命令 ~ npm start 2、 WEBPACK_EXTERNAL_MODULE_XX is not defined 解决方法：https://stackoverflow.com/questions/39103483/uncaught-referenceerror-webpack-external-module-xx-is-not-defined/39105605#39105605The solution was to set libraryTarget: 'amd' in the webpack.config.js file like so: output: { filename: 'dist/[name].bundle.js', libraryTarget: 'amd' }, 3、Angular2管理外部类型定义和处理“Duplicate identifier” TypeScript错误 https://segmentfault.com/a/1190000007560996 4、Module build failed: TypeError: Cannot read property 'exclude' of undefined 这个错误是由于awesome-typescript-loader package导致的，解决方法：编辑文件~/node_modules/awesome-typescript-loader/dist/instance.js:https://github.com/s-panferov/awesome-typescript-loader/issues/293大约是142行，替换applyDefaults 函数体内容： function applyDefaults(configFilePath, compilerConfig, loaderConfig) { _.defaults(compilerConfig.options, { sourceMap: true, verbose: false, skipDefaultLibCheck: true, suppressOutputPathCheck: true }); if (loaderConfig.transpileOnly) { compilerConfig.options.isolatedModules = true; } _.defaults(compilerConfig.options, { sourceRoot: compilerConfig.options.sourceMap ? process.cwd() : undefined }); _.defaults(loaderConfig, { sourceMap: true, verbose: false, }); delete compilerConfig.options.outDir; delete compilerConfig.options.inlineSourceMap; delete compilerConfig.options.outFile; delete compilerConfig.options.out; delete compilerConfig.options.noEmit; } 保存后，从新运行命令 npm start即可解决问题。 5、Node Sass does not yet support your current environment: OS X 64-bit with Unsupported runtime 根据链接：https://github.com/sass/node-sass/releases/tag/v3.13.1可知道是node版本太高了，卸载node后，下载低版本的node即可解决问题。 6、Node Sass could not find a binding for your current environment: OS X 64-bit with Node.js 6.x 根据错误提示,终端运行npm rebuild node-sass即可解决这个问题。 7、DI错误 这个错误由于使用了服务， 但是这个服务没有引入到模块中，找到服务，并把服务引入到模块中就好。 8. error：cannot find defined file ‘jquery’ 运行npm start时报错，错误信息： @types\\fullcalendar\\index.d.ts cannot find type definition file for 'jquery', Module ''*'' has no exported member 'Duration' Module ''*'' has no exported member 'Moment' 解决方案： 在tsconfig.json 文件中 添加下面语句： \"typeRoots\": [ \"node_modules/@types\" ], 9. Error: No NgModule metadata found for '[object Object]' 错误原因 在添加新模块的时候，模块类名 前面没有加default关键字，如： export class UserDetailModule { } 解决方法 在模块类名前面加上关键字default： export default class UserDetailModule { } 10. TypeError: Cannot read property 'split' of undefined 错误原因： 使用split方法的元素是个undefined; 解决方法 在使用split方法前，先判断元素是否为空。 11. 模板语法绑定错误 错误代码Html文件 {{value.text}} ts文件 public value: any; 正确写法： {{value?.text}} 或者 {{value.text}} ？.是angular提供的安全导航操作符，用来保护出现在属性路径中的null和undefined值 12. 浏览器不识别大写地址，如big-Data， 如在浏览器中输入http://localhost:3000/#/big-Data， Google浏览器会先把big-data,然后去匹配路径，导致angular路由 无法匹配转到了默认路径上， 所以最好不要有大写字母存在。 13. Refused to display 'URL' in a frame because it set 'X-Frame-Options' to 'sameorigin' 触发原因：页面的返回头被设置 X-Frame-Options SAMEORIGIN ，只能被同源的iframe 引用。跨域名的iframe 没法显示了。 这个在angular中， 本地开发中webpack中配置代理， 服务器中 Nginx中配置代理即可解决问题。 13. cnpm安装报错：Install fail! Error: EACCES: permission denied, 使用速度命令安装：sudo cnpm i 14. ng serve:Error: Cannot find module 'color-convert' 使用npm命令安装这个缺少的包：sudo cnpm i color-convert powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/angular/003-arcgis开发记录.html":{"url":"doc/angular/003-arcgis开发记录.html","title":"arcgis开发记录","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 arcgis JavaScript API安装 1. arcgisAPI下载地址：https://developers.arcgis.com/downloads/ 2. 4.4版本API：本地配置 3. 3.18版本修改方法 angular2中加载arcgis JS API * arcgis加载图层 并显示图层上点的信息* 使用图层上默认的参数，来显示图层上点的信息 更好的方案： 使用 arcgis 地图的 点击事件，来个性化弹窗 添加图层的时候可以调用方法，把所有点的 信息全部得到 arcgis地图坐标系。 没毛病 目录 [TOC] arcgis JavaScript API安装 1. arcgisAPI下载地址：https://developers.arcgis.com/downloads/ 打开网站后选择‘ArcGIS API for JavaScript’，如果不要最新版则点击后面的‘All versions’，选择一个自己需要的版本。 4.4版本的下载地址 2. 4.4版本API：本地配置 下载好后，把解压后的文件中 library目录拷贝到 angular2的src目录下(与index.html同级)， 打开文件library/4.4/dojo/dojo.js baseUrl:\"http://localhost:3000/library/4.4/dojo\",hasCache:{\"config-deferredInstrumentation\":0,\"config-selectorEngine\":\"acme\", 搜索内容 https://[HOSTNAME_AND_PATH_TO_JSAPI]dojo 把这个字符串替换成 http://localhost:3000/library/4.4/dojo保存后退出。 打开文件library/4.4/init.js 搜索内容 https://[HOSTNAME_AND_PATH_TO_JSAPI]dojo 把这个字符串替换成 http://localhost:3000/library/4.4/dojo保存后退出。 3. 3.18版本修改方法 打开文件library/4.4/dojo/dojo.js baseUrl:((location.protocol === 'http:' || location.protocol === 'https:') ? location.protocol : 'http:') + '//' + \"localhost:3000/library/3.18/dojo\",hasCache:{\"config-selectorEngine\":\"acme\", 搜索内容 [HOSTNAME_AND_PATH_TO_JSAPI] 把这个字符串替换成 localhost:3000/library/4.4/dojo保存后退出。注意：一定不要加http:// 打开文件library/4.4/init.js 搜索内容 [HOSTNAME_AND_PATH_TO_JSAPI] 把这个字符串替换成 localhost:3000/library/4.4/dojo保存后退出。注意：一定不要加http:// 测试API是否成功 启动服务后，在浏览器中输入网址： http://localhost:3000/library/4.4/init.js如果有返货内容则说明部署成功。 angular2中加载arcgis JS API angular2里面需要先安装 arcgis 的包 # 介绍： https://www.npmjs.com/package/angular2-esri-loader npm install angular2-esri-loader esri-loader 在组件中加载 arcgis的 API， 加载好后就可以在其他方法中直接使用了： private loadEsriModules() { //来自：https://github.com/StefanNieuwenhuis/awesome-mapping-app this.esriLoader.load({ // url: 'https://js.arcgis.com/4.4/' }).then(() => { this.esriLoader.loadModules([ 'esri/Map', 'esri/layers/MapImageLayer', //地图 图层服务 'esri/views/MapView', //2D地图 'esri/views/SceneView', //3D地图 //https://developers.arcgis.com/javascript/latest/api-reference/esri-layers-FeatureLayer.html#source \"esri/layers/FeatureLayer\", //提取图层服务 \"esri/widgets/Home\", //在视图中出现一个回到原点的按钮Home \"esri/widgets/BasemapGallery\", \"esri/widgets/Expand\", \"esri/widgets/Search\",//地点搜索 \"esri/widgets/ScaleBar\",//比例尺 \"esri/core/watchUtils\", //鹰眼图 \"dojo/dom\", //鹰眼图 ]).then(([Map, MapImageLayer, MapView, SceneView, FeatureLayer, Home, BasemapGallery, Expand, Search, ScaleBar, watchUtils, dom]) => { this.esriMap = Map; this.esriMapImageLayer = MapImageLayer; this.esriMapView = MapView; this.esriSceneView = SceneView; this.esriFeatureLayer = FeatureLayer; this.esriHome = Home; this.esriBasemapGallery = BasemapGallery; this.esriExpand = Expand; this.esriSearch = Search; this.esriScaleBar = ScaleBar; this.esriwatchUtils = watchUtils; this.esridom = dom; this.arcGisLoadFinish = true; }) }) } arcgis加载图层 并显示图层上点的信息 参考链接：https://developers.arcgis.com/javascript/latest/sample-code/featurelayerview-query/index.html 使用图层上默认的参数，来显示图层上点的信息 addMapLayre() { this.view.map.removeAll(); let popupTemplate = { title: 'Cities', content: \" 城市: {CITY_NAME}\" + \" LABEL_FLAG: {LABEL_FLAG}\" + \" OBJECTID: {OBJECTID}\" + \" POP: {POP}\" + \" POP_CLASS: {POP_CLASS}\" + \" POP_RANK: {POP_RANK}\" }; for (let e of this.layerBtnListsSelect) { if (e.data && e.data.url) { //https://developers.arcgis.com/javascript/latest/api-reference/esri-layers-FeatureLayer.html#properties-summary let layer = new this.esriFeatureLayer({ outFields: [\"*\"], //把每个点的所有属性都查询出来。 popupTemplate: popupTemplate, //弹窗模板 url: e.data.url //图层服务地址 }); this.view.map.add(layer); // adds the layer to the map //下面注销掉的代码可以查看全部点的信息 // this.view.whenLayerView(layer).then(function (lyrView) { // lyrView.watch(\"updating\", function (val) { // if (!val) { // wait for the layer view to finish updating // lyrView.queryFeatures().then(function (results) { // console.log(results); // prints all the client-side graphics to the console // }); // } // }); // }); } } } 使用这个方法好处 ：简单，方便。坏处： 1. 要根据不同的图层来制作不同的弹窗模板。 2. 弹窗样式固定。 更好的方案： 使用 arcgis 地图的 点击事件，来个性化弹窗 参考链接：https://geonet.esri.com/message/609517#comment-609517 https://developers.arcgis.com/javascript/latest/api-reference/esri-views-View.html#on let _view = this.view; this.view.on(\"click\", function (event) { _view.hitTest(event.screenPoint).then(function (response) { var graphics = response.results; graphics.forEach(function (graphic) { console.log(graphic); }); }); }); 在这里使用view 的 on事件，当点击地图上一个点的时候，如果这个点事图层上的点，则会出发这个事件， 如果不是，则没有有反应。一个例子： https://developers.arcgis.com/javascript/latest/sample-code/view-hittest/index.html 添加图层的时候可以调用方法，把所有点的 信息全部得到 https://developers.arcgis.com/javascript/latest/api-reference/esri-layers-FeatureLayer.html#querying // returns all the graphics from the layer view // lyr: 创建的图层 new FeatureLayer({...}) view.whenLayerView(lyr).then(function(lyrView){ lyrView.watch(\"updating\", function(val){ if(!val){ // wait for the layer view to finish updating lyrView.queryFeatures().then(function(results){ console.log(results); // prints all the client-side graphics to the console }); } }); }); arcgis地图坐标系。 参考链接： https://developers.arcgis.com/javascript/3/jsapi/screenpoint-amd.htmlhttps://developers.arcgis.com/javascript/latest/api-reference/esri-Viewpoint.html 没毛病 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/angular/004-angular2开发知识点.html":{"url":"doc/angular/004-angular2开发知识点.html","title":"angular2开发知识点","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 一、API 网关地址 配置 二、服务注册使用 三、模块组件注册使用 四、html中style类动态绑定 1. 单个类的绑定：[class.special]=\"isSpecial\" 2. 多个类的绑定：[ngClass]=\"{'selected':status === '','saveable': this.canSave,}\" 3. 单个内联样式绑定：[style.color]=\"isSpecial ? 'red': 'green'\" 4. 多个内联样式绑定：[ngStyle]=\"currentStyles\" angular2 第三方插件的使用 1. 安装插件： 2. 模块中引入prime 3. 在组件中使用插件 angular中阻止点击事件冒泡 目录 [TOC] 一、API 网关地址 配置 cloudlink-front-framework/config/webpack.dev.js # line 13 ~ 19 /** * Webpack Constants */ const ENV = process.env.ENV = process.env.NODE_ENV = 'development'; const HOST = process.env.HOST || 'localhost'; const PORT = process.env.PORT || 3000; const HMR = helpers.hasProcessFlag('hot'); # line 150 ~ 171 devServer: { port: METADATA.port, host: METADATA.host, historyApiFallback: { index: '/index.html' }, watchOptions: { aggregateTimeout: 300, poll: 1000 }, proxy: { '/cloudlink/v1/**': { target: 'http://192.168.100.90:8050', // target: 'http://192.168.120.110:8050', // target: 'http://192.168.20.221:8901', //赵杨 ip // target: 'http://192.168.100.212:8050', secure: false, pathRewrite: { '^/cloudlink/v1': '' } } } }, 二、服务注册使用 如上图所示，先有一个模型跟服务，需要在enterprise-auth/enterprise-authed-approve里面使用：模型使用： # enterprise-admin/enterprise-auth/enterprise-authed-approve/enterprise-authed-approve.component.ts # 只需要在这个文件中写如下代码即可： import {EnterpriseAdminModel} from \"../shared/enterprise-admin.model\"; 服务的使用： 注意： 如果服务里面又引入服务，那么在使用这个服务时，也要导入引入的服务。 # 服务的依赖注入： https://angular.cn/docs/ts/latest/guide/dependency-injection.html # 方法一： 直接在组件中引入使用 # enterprise-admin/enterprise-auth/enterprise-authed-approve/enterprise-authed-approve.component.ts # 在文件中写入如下代码： import {EnterpriseAdminService} from \"../shared/enterprise-admin.service\"; # 导入服务文件 @Component({ selector: \"jas-enterprise-authed-approve\", templateUrl: \"./enterprise-authed-approve.component.html\", styleUrls: [\"./enterprise-authed-approve.component.css\"], providers:[EnterpriseAdminService] # 在这里写上服务名字 }) ------------------------------------------------------------------------------------------ # 方法二： 在组件的所在的模块中注册服务后，在组件中直接使用 # enterprise-auth/enterprise-auth.module.ts # 在文件中写入如下代码： import { EnterpriseAdminService } from './shared/enterprise-admin.service'; @NgModule({ imports: [ ], declarations: [ ], providers:[EnterpriseAdminService ] # 引入声明 }) # enterprise-auth/enterprise-authed-approve/enterprise-authed-approve.component.ts # 在文件中写入如下代码： import {EnterpriseAdminService} from \"../shared/enterprise-admin.service\"; # 引入使用 ------------------------------------------------------------------------------------------ # 方法三：在组件的所在的模块中为服务申明一个名字，在子模块中直接用这个名字调用 # enterprise-auth/enterprise-auth.module.ts # 在文件中写入如下代码： mport { EnterpriseAdminService } from './shared/enterprise-admin.service'; @NgModule({ providers:[ {provide:'view',useClass:EnterpriseAdminService} # 引入声明 ] }) # enterprise-auth/enterprise-authed-approve/enterprise-authed-approve.component.ts # 在构造函数中直接引用： constructor(@Inject('view') private viewService, 三、模块组件注册使用 如上图所示，模块charts需要在enterprise-admin下注册使用： # 模块的注册使用 # src/app/jasframework/enterprise-admin/charts/charts.module.ts import {Charts} from './charts.component'; import {ChartsRoutes} from './charts.routing' import {NgModule} from '@angular/core'; import {CommonModule} from '@angular/common'; @NgModule({ imports: [CommonModule, ChartsRoutes], declarations: [Charts], bootstrap: [Charts] }) export default class ChartsModule { } # src/app/jasframework/enterprise-admin/charts/charts.routing.ts import {Routes, RouterModule} from '@angular/router'; import {Charts} from './charts.component'; const routes:Routes = [ { path: '', component: Charts, children: [ ] }, ]; export const ChartsRoutes = RouterModule.forChild(routes); # src/app/jasframework/enterprise-admin/charts/charts.component.ts import {Component, OnInit} from '@angular/core'; @Component({ selector: 'charts', templateUrl: 'charts.component.html', providers: [ ] }) export class Charts implements OnInit { constructor() { } ngOnInit() { } } # src/app/jasframework/enterprise-admin/charts/charts.component.html hello charts # 注册模块使之生效 # 只需要在enterprise-admin的路由文件中注册这个路径就可以了 # src/app/jasframework/enterprise-admin/enterprise-admin.routing.ts const routes: Routes = [ { path: '', component: EnterpriseAdminComponent, children:[{ path: 'charts', # 这里是路径 loadChildren: ()=>System.import('./charts/charts.module.ts'), # 指导去哪里找这个模块 }] }, ]; 模块比组件多了xx.module.ts与xx.routing.ts两个文件。如果删除这2个文件，那么就是组件。 组件的加载使用： # 还是以charts为例，代码在上面，少了xx.module.ts与xx.routing.ts两个文件。 # 注册组件使之生效 # 需要在enterprise-admin的路由文件中注册这个路径，在模块中也需要声明 # src/app/jasframework/enterprise-admin/enterprise-admin.routing.ts import {Charts} from './charts/charts.component'; # 引入这个组件 const routes: Routes = [ { path: '', component: EnterpriseAdminComponent, children:[{ path: 'charts', # 这里是路径 component: Charts, # 指明组件 }] }, ]; # src/app/jasframework/enterprise-admin/enterprise-admin.module.ts import {Charts} from './charts/charts.component'; # 引入这个组件 @NgModule({ imports: [ CommonModule,EnterpriseAdminRoutes ], declarations: [ EnterpriseAdminComponent, Charts ], # 在这里写入Charts,这里是声明 bootstrap: [ EnterpriseAdminComponent ] }) 四、html中style类动态绑定 1. 单个类的绑定：[class.special]=\"isSpecial\" 单个style类绑定介绍：https://angular.cn/guide/template-syntax#css-类绑定由class前缀，一个点 (.)和 CSS 类的名字组成， 其中后两部分是可选的。形如：[class.class-name]。 // 不使用style类绑定的代码： Bad curly special // 当badCurly 有值的时候，会清除所有样式类 Bad curly // 使用style绑定 The class binding is special 当模板表达式的求值结果是真值时，Angular 会添加这个类，反之则移除它。 2. 多个类的绑定：[ngClass]=\"{'selected':status === '','saveable': this.canSave,}\" 参考链接：https://angular.cn/guide/template-syntax#ngclass-指令用ngClass绑定到一个key:value 形式的控制对象。这个对象中的每个 key 都是一个 CSS 类名，如果它的 value 是true，这个类就会被加上，否则就会被移除。 // component.ts currentClasses: {}; setCurrentClasses() { // CSS classes: added/removed per current state of component properties this.currentClasses = { 'saveable': this.canSave, 'modified': !this.isUnchanged, 'special': this.isSpecial }; } // component.thml This div is initially saveable, unchanged, and special 3. 单个内联样式绑定：[style.color]=\"isSpecial ? 'red': 'green'\" https://angular.cn/guide/template-syntax#样式绑定单个内联样式绑定由style前缀，一个点 (.)和 CSS 样式的属性名组成。 形如：[style.style-property]。 Red Save 有些样式绑定中的样式带有单位。在这里，以根据条件用 “em” 和 “%” 来设置字体大小的单位。 Big Small 4. 多个内联样式绑定：[ngStyle]=\"currentStyles\" https://angular.cn/guide/template-syntax#ngstyle-指令NgStyle需要绑定到一个 key:value 控制对象。 对象的每个 key 是样式名，它的 value 是能用于这个样式的任何值。下面的列子会根据另外三个属性的状态把组件的currentStyles属性设置为一个定义了三个样式的对象： // src/app/app.component.ts currentStyles: {}; setCurrentStyles() { // CSS styles: set per current state of component properties this.currentStyles = { 'font-style': this.canSave ? 'italic' : 'normal', 'font-weight': !this.isUnchanged ? 'bold' : 'normal', 'font-size': this.isSpecial ? '24px' : '12px' }; } // src/app/app.component.html This div is initially italic, normal weight, and extra large (24px). 你既可以在初始化时调用setCurrentStyles()，也可以在所依赖的属性变化时调用。 angular2 第三方插件的使用 以 使用primeNG插件为例:https://www.primefaces.org/primeng/#/setup 1. 安装插件： npm install primeng --save 2. 模块中引入prime # src/app/advanced-research/advanced-research.module.ts import { DropdownModule } from 'primeng/primeng'; @NgModule({ imports: [ DropdownModule, ], providers: [], declarations: [] }) export default class advancedResearchModule { } 3. 在组件中使用插件 angular中阻止点击事件冒泡 在点击事件中调用下面方法，或者在点击事件的父元素中调用方法 // component.ts 文件中 // 阻止事件冒泡 public stopBubble(e) { // 如果提供了事件对象，则这是一个非IE浏览器 if (e && e.stopPropagation) { // 因此它支持W3C的stopPropagation()方法 e.stopPropagation(); } else { // 否则，我们需要使用IE的方式来取消事件冒泡 window.event.cancelBubble = true; } } // component.html文件中 {{subItem.name}} powered by Gitbook文件最后修改时间： 2021-03-11 09:55:29 "},"doc/angular/005-angular2网页前端执行流程.html":{"url":"doc/angular/005-angular2网页前端执行流程.html","title":"angular2网页前端执行流程","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 示例代码版本： http://192.168.102.9/jas-paas/cloudlink-front-framework/tree/045f4811da782c107eca72f9bdea39ebaa086a7d 命令行运行命令启动服务 示例代码版本： http://192.168.102.9/jas-paas/cloudlink-front-framework/tree/045f4811da782c107eca72f9bdea39ebaa086a7d 命令行运行命令启动服务 在开发环境下，打开项目目录，运行命令npm start, 这个命令会进入package.json文件中： # package.json \"scripts\": { \"start\": \"npm run server:dev\", # 这个就是 npm start 命令执行的脚本，这个脚本指向了下面的脚本 \"server:dev\": \"webpack-dev-server --config config/webpack.dev.js --progress --profile --watch --content-base src/\", # 这里最终是执行了webpack的打包 } webpack的执行顺序：``` angular2官方网站关于webpack的介绍文档 https://angular.cn/docs/ts/latest/guide/webpack.html 首先进入./webpack.config.js文件里面， case 'dev': case 'development': default: module.exports = require('./config/webpack.dev')({env: 'development'}); # 开发环境，进入这个文件路径 config/webpack.dev.js 在这个文件中还有打包好多输入文件路径以及规则，还有启动后的网址端口，链接的API地址 const commonConfig = require('./webpack.common.js'); # 这个文件引入了打包的文件入口 const ENV = process.env.ENV = process.env.NODE_ENV = 'development'; const HOST = process.env.HOST || 'localhost'; # 访问地址 const PORT = process.env.PORT || 3000; # 访问端口号 开发环境下的API链接设置 proxy: { '/cloudlink/v1/**': { target: 'http://192.168.100.90:8050',: false, pathRewrite: { '^/cloudlink/v1': '' } } } config/webpack.common.js 在这里，有打包文件的入口以及一些规则，想要知道什么意思看angular2官方网站关于webpack的介绍。 entry: { 'polyfills': './src/polyfills.browser.ts', 'vendor': './src/vendor.browser.ts', 'main': './src/main.browser.ts' # 这里就是程序的入口 }, ---------- ---------- ---------- * 浏览器输入地址： http://localhost:3000/ * 入口： index.html 文件路径： cloudlink-front-framework/src/index.html line: 27 这里是应用标签。程序入口 文件路径： cloudlink-front-framework/src/app/app.module.ts line: 15 import { App } from './app.component'; # 这里加载组件，包括模板（网页html） line: 49 routing # 加载路由 文件路径： cloudlink-front-framework/src/app/app.component.ts line:25 template: # 这里是路由文件里面的内容，执行到这里去找路由 , 文件路径： cloudlink-front-framework/src/app/app.routing.ts line:5 { path: '', redirectTo: 'cloudlink', pathMatch: 'full' }, 由于什么也没输入，所以默认进入这个空的 这里给默认的添加了一个路径 ‘cloudlink’ 此时进入下个组件中 { path: 'demo', redirectTo: 'demo/dashboard' }, { path: '**', redirectTo: 'cloudlink/dashboard' } 文件路径： cloudlink-front-framework/src/app/core/home/home.module.ts import { routing } from './home.routing'; # 加载自己的路由 import { NgaModule } from '../../theme/nga.module'; # 加载菜单模块 import { HomeComponent } from './home.component'; # 加载组件，这里有执行，有网页， 文件路径： cloudlink-front-framework/src/app/core/home/home.component.ts line:31 template: ` # 自定义标签 这里是垂直导航菜单 # src/app/theme/components/baSidebar/baSidebar.component.ts # line：8 ： selector: 'ba-sidebar', # src/app/theme/components/baSidebar/baSidebar.html # line： 11 ： # 自定义标签，这里负责列表垂直菜单选项 # src/app/theme/components/menuItem/menuItem.component.ts # line: 6: selector: 'menuItem', # src/app/theme/components/menuItem/menuItem.component.html # 在这里从后台API查询后，列出菜单。 #自定义标签 这里是网页顶部header菜单，如退出按钮菜单 # src/app/theme/components/baPageTop/baPageTop.component.ts # line:8 : selector: 'ba-page-top', # 这里加载路由 ` 文件路径： src/app/core/home/home.routing.ts line:6 const routes: Routes = [ { path: 'login', loadChildren: () => System.import('../login/login.module') # 这里是登录 }, { path: 'register', loadChildren: () => System.import('../register/register.module') }, { path: 'cloudlink', # 匹配这里 component: HomeComponent, children: [ { path: '', redirectTo: 'dashboard', pathMatch: 'full' }, # 这里匹配空，并且加上了‘dashboard’ { path: 'jas', loadChildren: () => System.import('../../jasframework/jas/jas.module.ts'), canLoad: [AuthGuard] }, { path: 'dashboard', loadChildren: () => System.import('../dashboard/dashboard.module'), canLoad: [AuthGuard] }, ```文件路径： src/app/core/dashboard/dashboard.module.ts文件路径： src/app/core/dashboard/dashboard.component.ts文件路径： src/app/core/dashboard/dashboard.html这里没有什么，正常显示。 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/angular/006-angular2中引入插件.html":{"url":"doc/angular/006-angular2中引入插件.html","title":"angular2中引入插件","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 angular中引入jQuery 1. 安装jQuery插件 2. 在index.html中引用jquery 3. 在组件app.component.ts中添加jQuery功能 4. 参考链接 angular2中引入 easyui 1. 参考链接 2. 引入easyUI 引入ngx-img: 图片上传插件 1. 安装使用 2. 直接把源码模块复制到自己的项目中去 [TOC] angular中引入jQuery 1. 安装jQuery插件 ~ npm i jquery cloudlink-front-framework@0.1.0 /Users/yulilong/work/cloudlink-front-framework ├── UNMET PEER DEPENDENCY @angular/common@2.4.6 ├── UNMET PEER DEPENDENCY @angular/compiler@2.4.6 ├── UNMET PEER DEPENDENCY @angular/compiler-cli@>=2.1.x ├── UNMET PEER DEPENDENCY @angular/core@2.4.6 ├── UNMET PEER DEPENDENCY @angular/forms@2.4.6 ├── jquery@2.2.4 └── UNMET PEER DEPENDENCY rxjs@5.0.0-beta.12 2. 在index.html中引用jquery src/index.html # 在这里引入jQuery \"> 3. 在组件app.component.ts中添加jQuery功能 src/app/jasframework/enterprise-admin/app-enterprise/enterprise-list/enterprise-list-show-view/enterprise-list-show-view.component.ts import { EnterpriseAppInfo } from './../../shared/app-enterprise.model'; declare var $:any; @Component({ selector: 'enterprise-list-show', templateUrl: './enterprise-list-show-view.component.html', styleUrls: ['./enterprise-list-show-view.component.css'], }) export class EnterpriseListShowViewComponent implements OnInit { ngOnInit() { $(\".title11\").html(\"这是JQUERY插件设置\"); } } 首先需要使用declare生命我们的jQuery，使之成为一个可用的变量，然后，我们需要导入OnInit模块并实现，我们编写的jquery代码就在这里，问中展示了我们向id为title的标签替换内容，HTML页面是这样的: src/app/jasframework/enterprise-admin/app-enterprise/enterprise-list/enterprise-list-show-view/enterprise-list-show-view.component.html 4. 参考链接 http://www.jb51.net/article/105123.htm angular2中引入 easyui 1. 参考链接 angular中引入easyUI教程： http://jeasyui.com/download/a07.phpangular中使用easyUI教程： http://www.jeasyui.com/demo-angular/main/index.php?sort=descEasyUI for Angular 简评： http://www.zisuzz.com/topic/29/easyui-for-angular-简评 2. 引入easyUI 下载easyUIangular组件： http://jeasyui.com/download/downloads/angular-easyui-0.7.zip 解压后把components文件复制到用的文件中。 把themes文件放到asset文件夹下， 在index文件中引入样式： 或者直接在组件样式(app.component.css )中引入： @import 'easyui/themes/material/easyui.css'; @import 'easyui/themes/angular.css'; @import 'easyui/themes/icon.css'; 引入ngx-img: 图片上传插件 npm网站地址：https://www.npmjs.com/package/ngx-img源码地址： https://github.com/harryy2510/ngx-imgdemo展示地址：https://harryy2510.github.io/ngx-img/home 1. 安装使用 // 安装 npm install --save ngx-img // 如果是在根模块中引入 import { NgxImgModule } from 'ngx-img'; @NgModule({ declarations: [AppComponent, ...], imports: [NgxImgModule.forRoot(), ...], bootstrap: [AppComponent] }) export class AppModule { } // 不在根模块，在其他模块引入 import { NgxImgModule } from 'ngx-img'; @NgModule({ declarations: [OtherComponent, ...], imports: [NgxImgModule, ...], }) export class OtherModule { } // 使用方法看demo ：https://harryy2510.github.io/ngx-img/home 2. 直接把源码模块复制到自己的项目中去 如果第一种方法报错，那么说明使用npm安装使用不适用你（本人就是失败），那么可以去github源码上把这个模块复制到自己的项目下。https://github.com/harryy2510/ngx-img/blob/master/src/module/ngx-img.module.ts目前项目源码是上面链接的模块，git clone 项目后，把这个模块复制到自己项目中，引入模块，写上示例代码，然后运行。此时会报错，以为缺少一个包cropperjs，使用npm install cropperjs --save安装后，即可成功使用。 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/angular/007-angular-CLI中一些问题.html":{"url":"doc/angular/007-angular-CLI中一些问题.html","title":"angular-CLI中一些问题","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 将ng设置成使用cnpm npm install 生成的package-lock.json是什么文件？有什么用？ 更换npm的源地址 [TOC] 将ng设置成使用cnpm ng set --global packageManager=cnpm http://www.jianshu.com/p/fea407503beb?mType=Group npm install 生成的package-lock.json是什么文件？有什么用？ package-lock.json is automatically generated for any operations where npm modifies either the node_modules tree, or package.json. It describes the exact tree that was generated, such that subsequent installs are able to generate identical trees, regardless of intermediate dependency updates. 大概意思好像是：package-lock.json是当 node_modules 或 package.json 发生变化时自动生成的文件。 这个文件主要功能是确定当前安装的包的依赖，以便后续重新安装的时候生成相同的依赖，而忽略项目开发过程中有些依赖已经发生的更新。 对比之下，大概是想做类似 Yarn 的功能。 详细内容，请自行查阅官方文档：https://docs.npmjs.com/files/package-lock.json 链接：https://www.zhihu.com/question/62331583/answer/197691747 更换npm的源地址 npm本来的源地址： npm config get registry https://registry.npmjs.org/ 更换npm的源地址: // 淘宝源 npm config set registry https://registry.npm.taobao.org // 自己本来的源 npm config set registry https://registry.npmjs.org/ 参考链接：http://blog.csdn.net/v2810769/article/details/52585662 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/angular/008-angular下arcgis开发遇见的问题.html":{"url":"doc/angular/008-angular下arcgis开发遇见的问题.html","title":"angular下arcgis开发遇见的问题","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 地图加载后不完全： arcgis自己的样式没有加载上 运行后，页面没有地图，地图服务报500错误 angular中，arcgis JA API 3.18版本中，画线没有提示信息了 地图中出现白线，样式出错导致的（arcgis3.18版本API） 目录 [TOC] 地图加载后不完全： arcgis自己的样式没有加载上 如上图所示，arcgis地图加载不完全，经过排查，是由于没有加载arcgis自己的CSS样式，把CSS加载上就好了。 运行后，页面没有地图，地图服务报500错误 运行网页后，页面没有地图，打开 console后看见如下信息： dojo.io.script error Error {__zone_symbol__error: Error at Error.g (http://192.168.100.92/polyfills.6fc95ed753dec1452ced.bundle.js:3:13200) at…, …} __zone_symbol__message : \"Error handling service request : Could not find a service with the name 'MapServer/ChinaOnlineStreetColor' in the configured clusters. Service may be stopped or ArcGIS Server may not be running.\" 经查找，这个是地图服务发生错误，导致不能读取地图了， angular中，arcgis JA API 3.18版本中，画线没有提示信息了 这个是由于 bootstrap样式中 .tooltipCSS 样式类中 opacity属性冲突了，导致了arcgis自己的样式失效了。 可在全局样式中添加如下属性： /*arcgis 组件3.18版本中在地图中画线时 提示语句出现：覆盖掉bootstrap中的样式才能出现。如果以后不用arcgis了，可以删除这个样式*/ .arcgis-version-three-map .tooltip { opacity: 1; /*透明度*/ } 地图中出现白线，样式出错导致的（arcgis3.18版本API） 如上图所示在地图中出现了一条白线，经过查找，在显示地图的块中，对DIV块进行了宽高的拉伸,arcgis地图显示的DIV块可使用arcgis自己的类样式来拉伸： /*arcgis地图大小，通过arcgis自己的css类来实现*/ html, body, div.map { width: 100%; height: 100%; padding: 0; margin: 0 auto; overflow: hidden; } 同时把自己写的地图拉伸样式去掉就可以了 powered by Gitbook文件最后修改时间： 2021-03-11 09:58:19 "},"doc/angular/009-angular编程规范.html":{"url":"doc/angular/009-angular编程规范.html","title":"angular编程规范","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 一、单一职责 1. 单一法则 2. 简单函数 二、命名 1. 总体命名指导原则 2. 使用点和横杠来分隔文件名 3. 符号名与文件名 4. 服务名 5. 指令选择器 6. 为组件添加自定义前缀 7. 为指令添加自定义前缀 8. 管道名 9. 单元测试文件名 10. 端到端测试文件名 11. Angular NgModule 命名 三、编程约定 1. 类 2. 常量 3. 接口 4. 属性和方法 5. 导入语句中的空行 四、应用程序结构与 Angular 模块 1. LIFT 2. 定位 3. 识别 4. 扁平 5. T-DRY （尝试不重复自己） 6. 总体结构指导原则 7. 按特性组织的目录结构 8. 应用的根模块 9. 特性模块 10. 共享特性模块 11. 核心特性模块 12. 防止多次导入CoreModule 13. 惰性加载的目录 14. 永远不要直接导入惰性加载的目录 五、组件 1. 组件选择器命名 2. 把组件当做元素 3. 把模板和样式提取到它们自己的文件 4. 内联输入和输出属性装饰器 5. 避免为输入和输出属性指定别名 6. 成员顺序 7. 把逻辑放到服务里 8. 不要给输出属性加前缀 9. 把表现层逻辑放到组件类里 六、指令 1. 使用指令来加强已有元素 2. HostListener 和 HostBinding 装饰器 vs. 组件元数据 host 七、服务 1. 服务总是单例的 2. 单一职责 3. 提供一个服务 4. 使用 @Injectable() 类装饰器 八、数据服务 1. 通过服务与Web服务器交互 九、生命周期钩子 1. 实现生命周期钩子接口 目录 [TOC] 一、单一职责 1. 单一法则 坚持每个文件只定义一样东西（例如服务或组件）, 考虑把文件大小限制在 400 行代码以内。 这么做的理由： 单组件文件非常容易阅读、维护，并能防止在版本控制系统里与团队冲突。 单组件文件可以防止一些隐蔽的程序缺陷，当把多个组件合写在同一个文件中时，可能造成共享变量、创建意外的闭包，或者与依赖之间产生意外耦合等情况。 单独的组件通常是该文件默认的导出，可以用路由器实现按需加载。 最关键的是，可以增强代码可重用性和阅读性，减少出错的可能性。 2. 简单函数 坚持定义简单函数，考虑限制在 75 行之内。 这么做的理由： 简单函数更易于测试，特别是当它们只做一件事，只为一个目的服务时。 简单函数促进代码重用。 简单函数更易于阅读。 简单函数更易于维护。 简单函数可避免易在大函数中产生的隐蔽性错误，例如与外界共享变量、创建意外的闭包或与依赖之间产生意外耦合等。 二、命名 命名约定对可维护性和可读性非常重要。本指南为文件名和符号名推荐了一套命名约定。 1. 总体命名指导原则 坚持所有符号使用一致的命名规则。 坚持遵循同一个模式来描述符号的特性和类型。推荐的模式为feature.type.ts。 这么做的理由： 命名约定提供了一致的方式来查找内容，让我们一眼就能锁定。 项目的一致性是至关重要的。团队内的一致性也很重要。整个公司的一致性会提供惊人的效率。 命名约定帮助我们更快得找到不在手头的代码，更容易理解它。 目录名和文件名应该清楚的传递它们的意图。 例如，app/heroes/hero-list.component.ts包含了一个用来管理英雄列表的组件。 2. 使用点和横杠来分隔文件名 坚持在描述性名字中，用横杠来分隔单词。 坚持使用点来分隔描述性名字和类型。 坚持遵循先描述组件特性，再描述它的类型的模式，对所有组件使用一致的类型命名规则。推荐的模式为feature.type.ts。 坚持使用惯用的后缀来描述类型，包括.service、.component、*.pipe、.module、.directive。 必要时可以创建更多类型名，但必须注意，不要创建太多。 这么做的理由： 类型名字提供一致的方式来快速的识别文件中有什么。 利用编辑器或者 IDE 的模糊搜索功能，可以很容易地找到特定文件。 像.service这样的没有简写过的类型名字，描述清楚，毫不含糊。 像.srv, .svc, 和 .serv这样的简写可能令人困惑。 为自动化任务提供模式匹配。 3. 符号名与文件名 坚持为所有东西使用一致的命名约定，以它们所代表的东西命名。 坚持使用大写驼峰命名法来命名类。符号名匹配它所在的文件名。 坚持在符号名后面追加约定的类型后缀（例如Component、Directive、Module、Pipe、Service）。 坚持在符号名后面追加约定的类型后缀（例如.component.ts、.directive.ts、.module.ts、.pipe.ts、.service.ts）。 坚持在文件名后面追加约定的类型后缀（例如.component.ts、.directive.ts、.module.ts、.pipe.ts、.service.ts）。 这么做的理由： 遵循一致的约定可以快速识别和引用不同类型的资产。 # app.component.ts @Component({ ... }) export class AppComponent { } # hero-list.component.ts @Component({ ... }) export class HeroListComponent { } # validation.directive.ts @Directive({ ... }) export class ValidationDirective { } # app.module.ts @NgModule({ ... }) export class AppModule # init-caps.pipe.ts @Pipe({ name: 'initCaps' }) export class InitCapsPipe implements PipeTransform { } # user-profile.service.ts @Injectable() export class UserProfileService { } 4. 服务名 坚持使用一致的规则命名服务，以它们的特性来命名。 坚持为服务的类名加上Service后缀。 例如，获取数据或英雄列表的服务应该命名为DataService或HeroService。 这么做的理由： 提供一致的方式来快速识别和引用服务。 # hero-data.service.ts @Injectable() export class HeroDataService { } # credit.service.ts @Injectable() export class CreditService { } 5. 指令选择器 坚持使用小驼峰命名法来命名指令的选择器。 这么做的理由： 保持指令中定义的属性名与绑定的视图 HTML 属性名字一致。 Angular HTML 解析器是大小写敏感的，它识别小写驼峰写法。 6. 为组件添加自定义前缀 坚持使用带连字符的小写元素选择器值（例如admin-users）。 坚持为组件选择器添加自定义前缀。 例如，toh前缀表示 Tour of Heroes（英雄指南），而前缀`admin表示管理特性区。 坚持使用前缀来识别特性区或者应用程序本身。 这么做的理由： 防止与其它应用中的组件和原生 HTML 元素发生命名冲突。 更容易在其它应用中推广和共享组件。 组件在 DOM 中更容易被区分出来。 # app/users/users.component.ts @Component({ selector: 'admin-users' # 这里为users添加一个前缀 admin }) export class UsersComponent {} 7. 为指令添加自定义前缀 坚持为指令的选择器添加自定义前缀（例如前缀toh来自Tour of Heroes）。 坚持用小驼峰形式拼写非元素选择器，除非该选择器用于匹配原生 HTML 属性。 这么做的理由： 防止名字冲突。 指令更加容易被识别。 @Directive({ selector: '[tohValidate]' # 为 Validate 添加一个前缀toh }) export class ValidateDirective {} 8. 管道名 坚持为所有管道使用一致的命名约定，用它们的特性来命名。 这么做的理由： 提供一致方式快速识别和引用管道。 9. 单元测试文件名 坚持测试规格文件名与被测试组件文件名相同。 坚持测试规格文件名添加.spec后缀。 这么做的理由： 提供一致的方式来快速识别测试。 提供一个与 karma 或者其它测试运行器相配的命名模式。 10. 端到端测试文件名 坚持端到端测试规格文件和它们所测试的特性同名，添加.e2e-spec后缀。 这么做的理由： 提供一致的方式快速识别端到端测试文件。 提供一个与测试运行器和构建自动化匹配的模式。 app.e2e-spec.ts heroes.e2e-spec.ts 11. Angular NgModule 命名 坚持为符号名添加Module后缀. 坚持为文件名添加.module.ts扩展名。 坚持用特性名和所在目录命名模块。 坚持为 RoutingModule 类名添加RoutingModule后缀。 坚持为 RoutingModule 的文件名添加-routing.module.ts后缀。 这么做的理由： 提供一致的方式来快速标识和引用模块。 大驼峰命名法是一种命名约定，用来标识可用构造函数实例化的对象。 很容易就能看出这个模块是同名特性的根模块。 RoutingModule是一种专门用来配置 Angular 路由器的模块。 “类名和文件名保持一致”的约定使这些模块易于发现和验证。 ```app.module.ts @NgModule({ ... }) export class AppModule { } heroes.module.ts @NgModule({ ... }) export class HeroesModule { } villains.module.ts @NgModule({ ... }) export class VillainsModule { } app-routing.module.ts @NgModule({ ... }) export class AppRoutingModule { } heroes-routing.module.ts @NgModule({ ... }) export class HeroesRoutingModule { } -------------- ## **三、编程约定** * 坚持一致的编程、命名和空格的约定。 ### **1. 类** * 坚持使用大写驼峰命名法来命名类。 ***这么做的理由：*** * 遵循类命名传统约定。 * 类可以被实例化和构造实例。根据约定，用大写驼峰命名法来标识可构造的东西。 export class ExceptionService { constructor() { } } ### **2. 常量** * 坚持用const声明变量，除非它们的值在应用的生命周期内会发生变化。 * 考虑 把常量名拼写为小驼峰格式。 * 坚持容许现存的const常量沿用大写蛇形命名法。 ***这么做的理由：*** * 告诉读者这个值是不可变的。 * TypeScript 会要求在声明时立即初始化，并阻止再次赋值，以确保达成我们的意图。 * 小驼峰变量名 (heroRoutes) 比传统的大写蛇形命名法 (HERO_ROUTES) 更容易阅读和理解。 * 把常量命名为大写蛇形命名法的传统源于现代 IDE 出现之前， 以便阅读时可以快速发现那些const定义。 TypeScript 本身就能够防止意外赋值。 * 传统的大写蛇形命名法仍然很流行、很普遍，特别是在第三方模块中。 修改它们没多大价值，还会有破坏现有代码和文档的风险。 export const mockHeroes = ['Sam', 'Jill']; // prefer export const heroesUrl = 'api/heroes'; // prefer export const VILLAINS_URL = 'api/villains'; // tolerate ### **3. 接口** * 坚持使用大写驼峰命名法来命名接口。 * 考虑不要在接口名字前面加I前缀。 * 考虑用类代替接口。 ***这么做的理由：*** * [TypeScript 指导原则](https://github.com/Microsoft/TypeScript/wiki/Coding-guidelines)不建议使用 “I” 前缀。 * 单独一个类的代码量小于类+接口。 * 类可以作为接口使用（只是用implements代替extends而已）。 * 在 Angular 依赖注入系统中，接口类可以作为服务提供商的查找令牌。 app/shared/hero-collector.service.ts import { Injectable } from '@angular/core'; import { Hero } from './hero.model'; @Injectable() export class HeroCollectorService { hero: Hero; constructor() { } } ### **4. 属性和方法** * 坚持使用小写驼峰命名法来命名属性和方法。 * 避免为私有属性和方法添加下划线前缀。 ***这么做的理由：*** * 遵循传统属性和方法的命名约定。 * JavaScript 不支持真正的私有属性和方法。 * TypeScript 工具让识别私有或公有属性和方法变得很简单。 app/shared/toast.service.ts import { Injectable } from '@angular/core'; @Injectable() export class ToastService { message: string; private toastCount: number; hide() { this.toastCount--; this.log(); } show() { this.toastCount++; this.log(); } private log() { console.log(this.message); } } ### **5. 导入语句中的空行** * 坚持在第三方导入和应用导入之间留一个空行。 * 考虑按模块名字的字母顺排列导入行。 * 考虑在解构表达式中按字母顺序排列导入的东西。 ***这么做的理由：*** * 空行可以让阅读和定位本地导入更加容易。 * 按字母顺序排列可以让阅读和定位本地导入更加容易。 app/heroes/shared/hero.service.ts import { Injectable } from '@angular/core'; import { Http } from '@angular/http'; import { Hero } from './hero.model'; import { ExceptionService, SpinnerService, ToastService } from '../../core'; -------------- ## **四、应用程序结构与 Angular 模块** * 准备一个近期实施方案和一个长期的愿景。从零开始，但要考虑应用程序接下来的路往哪儿走。 * 所有应用程序的源代码都放到名叫src的目录里。 所有特性区都在自己的文件夹中，带有它们自己的 Angular 模块。 * 所有内容都遵循每个文件一个特性的原则。每个组件、服务和管道都在自己的文件里。 所有第三方程序包保存到其它目录里，而不是src目录。 你不会修改它们，所以不希望它们弄乱我们的应用程序。 使用本指南介绍的文件命名约定。 ### **1. LIFT** * 坚持组织应用的结构，达到这些目的：快速定位 (Locate) 代码、一眼识别 (Identify) 代码、 尽量保持扁平结构 (Flattest) 和尝试 (Try) 遵循DRY (Do Not Repeat Yourself, 不重复自己) 原则。 * 坚持四项基本原则定义文件结构，上面的原则是按重要顺序排列的。 ***这么做的理由：*** * LIFT提供了一致的结构，它具有扩展性强、模块化的特性。因为容易快速锁定代码，提高了开发者的效率。 另外，检查应用结构是否合理的方法是问问自己：我们能快速打开与此特性有关的所有文件并开始工作吗？ ### **2. 定位** * 坚持直观、简单和快速地定位代码。 ***这么做的理由：*** * 要想高效的工作，就必须能迅速找到文件，特别是当不知道（或不记得）文件名时。 把相关的文件一起放在一个直观的位置可以节省时间。 富有描述性的目录结构会让你和后面的维护者眼前一亮。 ### **3. 识别** * 坚持命名文件到这个程度：看到名字立刻知道它包含了什么，代表了什么。 * 坚持文件名要具有说明性，确保文件中只包含一个组件。 * 避免创建包含多个组件、服务或者混合体的文件。 ***这么做的理由：*** * 花费更少的时间来查找和琢磨代码，就会变得更有效率。 较长的文件名远胜于较短却容易混淆的缩写名。 ### **4. 扁平** * 坚持尽可能保持扁平的目录结构。 * 考虑当同一目录下达到 7 个或更多个文件时创建子目录。 * 考虑配置 IDE，以隐藏无关的文件，例如生成出来的.js文件和.js.map文件等。 ***这么做的理由：*** * 没人想要在超过七层的目录中查找文件。扁平的结构有利于搜索。 * 另一方面，心理学家们相信， 当关注的事物超过 9 个时，人类就会开始感到吃力。 所以，当一个文件夹中的文件有 10 个或更多个文件时，可能就是创建子目录的时候了。 * 还是根据你自己的舒适度而定吧。 除非创建新文件夹能有显著的价值，否则尽量使用扁平结构。 ### **5. T-DRY （尝试不重复自己）** * 坚持 DRY（Don't Repeat Yourself，不重复自己）。 * 避免过度 DRY，以致牺牲了阅读性。 ***这么做的理由：*** * 虽然 DRY 很重要，但如果要以牺牲 LIFT 的其它原则为代价，那就不值得了。 这也就是为什么它被称为 T-DRY。 例如，把组件命名为hero-view.component.html是多余的，因为带有.html扩展名的文件显然就是一个视图 (view)。 但如果它不那么显著，或不符合常规，就把它写出来。 ### **6. 总体结构指导原则** * 坚持从零开始，但要考虑应用程序接下来的路往哪儿走。 * 坚持有一个近期实施方案和一个长期的愿景。 * 坚持把所有源代码都放到名为src的目录里。 * 坚持如果组件具有多个伴隨文件 (.ts、.html、.css和.spec)，就为它创建一个文件夹。 ***这么做的理由：*** * 在早期阶段能够帮助保持应用的结构小巧且易于维护，这样当应用增长时就容易进化了。 * 组件通常有四个文件 (*.html、 *.css、 *.ts 和 *.spec.ts)，它们很容易把一个目录弄乱。 * 把组件放在专用目录中的方式广受欢迎，对于小型应用，还可以保持组件扁平化（而不是放在专用目录中）。 这样会把四个文件放在现有目录中，也会减少目录的嵌套。无论你如何选择，请保持一致。 ### **7. 按特性组织的目录结构** * 坚持根据特性区命名目录。 * 坚持为每个特性区创建一个 Angular 模块。 ***这么做的理由：*** * LIFT 原则中包含了所有这些。 * 遵循 LIFT 原则精心组织内容，避免应用变得杂乱无章。 * 当有很多文件时（例如 10 个以上），在专用目录型结构中定位它们会比在扁平结构中更容易。 * Angular 模块使惰性加载可路由的特性变得更容易。 * Angular 模块隔离、测试和复用特性更容易。 ### **8. 应用的根模块** * 坚持在应用的根目录创建一个 Angular 模块（例如/src/app）。 * 考虑把根模块命名为app.module.ts。 ***这么做的理由：*** * 每个应用都至少需要一个根 Angular 模块。 * 能让定位和识别根模块变得更容易。 app/app.module.ts import { NgModule } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { AppComponent } from './app.component'; import { HeroesComponent } from './heroes/heroes.component'; @NgModule({ imports: [ BrowserModule, ], declarations: [ AppComponent, HeroesComponent ], exports: [ AppComponent ], entryComponents: [ AppComponent ] }) export class AppModule {} ### **9. 特性模块** * 为应用中每个明显的特性创建一个 Angular 模块。 * 坚持把特性模块放在与特性区同名的目录中（例如app/heroes）。 * 坚持特性模块的文件名应该能反映出特性区的名字和目录（例如app/heroes/heroes.module.ts）。 * 坚持特性模块的符号名应该能反映出特性区、目录和文件名（例如在app/heroes/heroes.module.ts中定义HeroesModule）。 ***这么做的理由：*** * 特性模块可以对其它模块暴露或隐藏自己的实现。 * 特性模块标记出组成该特性分区的相关组件集合。 * 方便路由到特性模块 —— 无论是用主动加载还是惰性加载的方式。 * 特性模块在特定的功能和其它应用特性之间定义了清晰的边界。 * 特性模块帮助澄清开发职责，以便于把这些职责指派给不同的项目组。 * 特性模块易于隔离，以便测试。 ### **10. 共享特性模块** * 坚持在shared目录中创建名叫SharedModule的特性模块（例如在app/shared/shared.module.ts中定义SharedModule）。 * 坚持在共享模块中声明那些可能被特性模块引用的可复用组件、指令和管道。 * 考虑把可能在整个应用中到处引用的模块命名为SharedModule. * 避免 在共享模块中提供服务。服务通常是单例的，应该在整个应用或一个特定的特性模块中只有一份。 * 坚持在SharedModule中导入所有模块都需要的资产（例如CommonModule和FormsModule）。 * 坚持在SharedModule中声明所有组件、指令和管道。 * 坚持从SharedModule中导出其它特性模块所需的全部符号。 * 避免在SharedModule中指定应用级的单例服务提供商。如果是刻意要得到多个服务单例也行，不过还是要小心。 ***这么做的理由：*** * SharedModule中包含的组件、指令和管道可能需要来自其它公共模块的特性（例如来自CommonModule中的ngFor指令）。 * SharedModule的存在，能让常用的组件、指令和管道在很多其它模块的组件模板中都自动可用。 * 惰性加载的特性模块如果导入了这个共享模块，会创建一份自己的服务副本，这可能会导致意料之外的后果。 * 为何？对于单例服务，你不希望每个模块都有自己的实例。 而如果SharedModule提供了一个服务，那就有可能发生这种情况。 ### **11. 核心特性模块** * 考虑把那些数量庞大、辅助性的、只用一次的类收集到核心模块中，让特性模块的结构更清晰简明。 * 坚持把那些“只用一次”的类收集到CoreModule中，并对外隐藏它们的实现细节。简化的AppModule会导入CoreModule，并且把它作为整个* 应用的总指挥。 * 坚持在core目录下创建一个名叫CoreModule的特性模块（例如在app/core/core.module.ts中定义CoreModule）。 * 坚持把要共享给整个应用的单例服务放进CoreModule中（例如ExceptionService和LoggerService）。 * 坚持导入CoreModule中的资产所需要的全部模块（例如CommonModule和FormsModule）。 * 坚持把应用级、只用一次的组件收集到CoreModule中。 只在应用启动时从AppModule中导入它一次，以后再也不要导入它（例如NavComponent和SpinnerComponent）。 ***这么做的理由：*** * CoreModule提供了一个或多个单例服务。Angular使用应用的根注入器注册这些服务提供商，让每个服务的这个单例对象对所有需要它们的组件都是可用的，而不用管该组件是通过主动加载还是惰性加载的方式加载的。 * CoreModule将包含一些单例服务。而如果是由惰性加载模块来导入这些服务，它就会得到一个新实例，而不是所期望的全应用级单例。 * 真实世界中的应用会有很多只用一次的组件（例如加载动画、消息浮层、模态框等），它们只会在AppComponent的模板中出现。 不会在其它地方导入它们，所以没有共享的价值。 然而它们又太大了，放在根目录中就会显得乱七八糟的。 ### **12. 防止多次导入CoreModule** * 应该只有AppModule才允许导入CoreModule。 * 坚持防范多次导入CoreModule，并通过添加守卫逻辑来尽快失败。 ***这么做的理由：*** * 守卫可以阻止对CoreModule的多次导入。 * 守卫会禁止创建单例服务的多个实例。 ### **13. 惰性加载的目录** * 某些边界清晰的应用特性或工作流可以做成惰性加载或按需加载的，而不用总是随着应用启动。 * 坚持把惰性加载特性下的内容放进惰性加载目录中。 典型的惰性加载目录包含路由组件及其子组件以及与它们有关的那些资产和模块。 ***这么做的理由：*** 这种目录让标识和隔离这些特性内容变得更轻松。 ### **14. 永远不要直接导入惰性加载的目录** * 避免让兄弟模块和父模块直接导入惰性加载特性中的模块。 ***这么做的理由：*** 直接导入并使用此模块会立即加载它，而原本的设计意图是按需加载它。 ----------------- ## **五、组件** ### **1. 组件选择器命名** * 坚持使用中线 (dashed) 命名法或烤串 (kebab) 命名法来命名组件中的元素选择器。 ***这么做的理由：*** * 保持元素命名与自定义元素命名规范一致。 app/heroes/shared/hero-button/hero-button.component.ts @Component({ selector: 'toh-hero-button', templateUrl: './hero-button.component.html' }) export class HeroButtonComponent {} ### **2. 把组件当做元素** * 坚持给组件一个元素选择器，而不是属性或类选择器。 ***这么做的理由：*** * 组件有很多包含 HTML 以及可选 Angular 模板语法的模板。 它们显示内容。开发人员会把组件像原生HTML元素和WebComponents一样放进页面中。 * 查看组件模板的 HTML 时，更容易识别一个符号是组件还是指令。 不好的用法： hero-button.component.ts @Component({ selector: '[tohHeroButton]', templateUrl: './hero-button.component.html' }) export class HeroButtonComponent {} app.component.html 好的做法： hero-button.component.ts @Component({ selector: 'toh-hero-button', templateUrl: './hero-button.component.html' }) export class HeroButtonComponent {} app.component.html ### **3. 把模板和样式提取到它们自己的文件** * 坚持当超过 3 行时，把模板和样式提取到一个单独的文件。 * 坚持把模板文件命名为[component-name].component.html，其中，[component-name] 是组件名。 * 坚持把样式文件命名为[component-name].component.css，其中，[component-name] 是组件名。 * 坚持指定相对于模块的 URL ，给它加上./前缀。 ***这么做的理由：*** * 巨大的、内联的模板和样式表会遮盖组件的意图和实现方式，削弱可读性和可维护性。 * 在多数编辑器中，编写内联的模板和样式表时都无法使用语法提示和代码片段功能。 Angular的TypeScript语言服务（即将到来）可以帮助那些编辑器在编写HTML模板时克服这一缺陷，但对CSS样式没有帮助。 * 当你移动组件文件时，相对于组件的URL不需要修改，因为这些文件始终会在一起。 * ./前缀是相对URL的标准语法，不必依赖Angular的特殊处理，如果没有前缀则不行。 ### **4. 内联输入和输出属性装饰器** * 坚持 使用@Input()和@Output()，而非@Directive和@Component装饰器的inputs和outputs属性: * 坚持把@Input()或者@Output()放到所装饰的属性的同一行。 ***这么做的理由：*** * 易于在类里面识别哪些属性是输入属性或输出属性。 * 如果需要重命名与@Input或者@Output关联的属性或事件名，你可以在一个位置修改。 * 依附到指令的元数据声明会比较简短，更易于阅读。 * 把装饰器放到同一行可以精简代码，同时更易于识别输入或输出属性。 不好的写法： app/heroes/shared/hero-button/hero-button.component.ts @Component({ selector: 'toh-hero-button', template: , inputs: [ 'label' ], outputs: [ 'change' ] }) export class HeroButtonComponent { change = new EventEmitter(); label: string; } 好的写法： @Component({ selector: 'toh-hero-button', template: {{label}} }) export class HeroButtonComponent { @Output() change = new EventEmitter(); @Input() label: string; } ### **5. 避免为输入和输出属性指定别名** * 避免除非有重要目的，否则不要为输入和输出指定别名。 ***这么做的理由：*** * 同一个属性有两个名字（一个对内一个对外）很容易导致混淆。 * 如果指令名也同时用作输入属性，而且指令名无法准确描述这个属性的用途时，应该使用别名。 ### **6. 成员顺序** * 坚持把属性成员放在前面，方法成员放在后面。 * 坚持先放公共成员，再放私有成员，并按照字母顺序排列。 ***这么做的理由：*** * 把类的成员按照统一的顺序排列，易于阅读，能立即识别出组件的哪个成员服务于何种目的。 ### **7. 把逻辑放到服务里** * 坚持在组件中只包含与视图相关的逻辑。所有其它逻辑都应该放到服务中。 * 坚持把可重用的逻辑放到服务中，保持组件简单，聚焦于它们预期目的。 ***这么做的理由：*** * 当逻辑被放置到服务里，并以函数的形式暴露时，可以被多个组件重复使用。 * 在单元测试时，服务里的逻辑更容易被隔离。当组件中调用逻辑时，也很容易被模拟。 * 从组件移除依赖并隐藏实施细节。 * 保持组件苗条、精简和聚焦。 ### **8. 不要给输出属性加前缀** * 坚持命名事件时，不要带前缀on。 * 坚持把事件处理器方法命名为on前缀之后紧跟着事件名。 ***这么做的理由：*** * 与内置事件命名一致，例如按钮点击。 * Angular 允许另一种备选语法 `on-*`。如果事件的名字本身带有前缀on，那么绑定的表达式可能是on-onEvent。 不好的写法： app/heroes/hero.component.ts @Component({ selector: 'toh-hero', template: ... }) export class HeroComponent { @Output() onSavedTheDay = new EventEmitter(); } 好的写法： export class HeroComponent { @Output() savedTheDay = new EventEmitter(); } ### **9. 把表现层逻辑放到组件类里** * 坚持把表现层逻辑放进组件类中，而不要放在模板里。 ***这么做的理由：*** * 逻辑应该只出现在一个地方（组件类里）而不应分散在两个地方。 * 将组件的表现层逻辑放到组件类而非模板里，可以增强测试性、维护性和重复使用性。 不好的写法： @Component({ selector: 'toh-hero-list', template: Our list of heroes: Total powers: {{totalPowers}} Average power: {{totalPowers / heroes.length}} # 这里 }) export class HeroListComponent { heroes: Hero[]; totalPowers: number; } 好的写法： @Component({ selector: 'toh-hero-list', template: Our list of heroes: Total powers: {{totalPowers}} Average power: {{avgPower}} }) export class HeroListComponent { heroes: Hero[]; totalPowers: number; get avgPower() { return this.totalPowers / this.heroes.length; } ---------------- ## **六、指令** ### **1. 使用指令来加强已有元素** * 坚持当你需要有表现层逻辑，但没有模板时，使用属性型指令。 ***这么做的理由：*** * 属性型指令没有模板。 * 一个元素可以使用多个属性型指令。 ### **2. HostListener 和 HostBinding 装饰器 vs. 组件元数据 host** * 考虑优先使用@HostListener和@HostBinding，而不是@Directive和@Component装饰器的host属性。 * 坚持让你的选择保持一致。 ***这么做的理由：*** * 对于关联到@HostBinding的属性或关联到@HostListener的方法，要修改时，只需在指令类中的一个地方修改。 如果使用元数据属性host，你就得在组件类中修改属性声明的同时修改相关的元数据。 * host元数据只是一个便于记忆的名字而已，并不需要额外的 ES 导入。 使用@HostListener和@HostBinding: app/shared/validator.directive.ts import { Directive, HostBinding, HostListener } from '@angular/core'; @Directive({ selector: '[tohValidator]' }) export class ValidatorDirective { @HostBinding('attr.role') role = 'button'; @HostListener('mouseenter') onMouseEnter() { // do work } } 使用host元数据： import { Directive } from '@angular/core'; @Directive({ selector: '[tohValidator2]', host: { 'attr.role': 'button', '(mouseenter)': 'onMouseEnter()' } }) export class Validator2Directive { role = 'button'; onMouseEnter() { // do work } } ------------- ## **七、服务** ### **1. 服务总是单例的** * 坚持在同一个注入器内，把服务当做单例使用。用它们来共享数据和功能。 ***这么做的理由：*** * 服务是在特性范围或应用内共享方法的理想载体。 * 服务是共享状态性内存数据的理想载体。 app/heroes/shared/hero.service.ts export class HeroService { constructor(private http: Http) { } getHeroes() { return this.http.get('api/heroes') .map((response: Response) => response.json().data); } } ### **2. 单一职责** * 坚持创建单一职责的服务，用职责封装在它的上下文中。 * 坚持当服务成长到超出单一用途时，创建一个新服务。 ***这么做的理由：*** * 当服务有多个职责时，它很难被测试。 * 当某个服务有多个职责时，每个注入它的组件或服务都会承担这些职责的全部开销。 ### **3. 提供一个服务** * 坚持将服务提供到共享范围内的顶级组件的 Angular 注入器。 ***这么做的理由：*** * Angular 注入器是层次化的。 * 在顶层组件提供服务时，该服务实例在所有子组件中可见并共享。 * 服务是共享方法或状态的理想载体。 * 当不同的两个组件需要一个服务的不同的实例时，上面的方法这就不理想了。在这种情况下，对于需要崭新和单独服务实例的组件，最好在组件级提供服务。 ### **4. 使用 @Injectable() 类装饰器** * 坚持当使用类型作为令牌来注入服务的依赖时，使用@Injectable()类装饰器，而非@Inject()参数装饰器。 ***这么做的理由：*** * Angular 的 DI 机制会根据服务的构造函数参数的声明类型来解析服务的所有依赖。 * 当服务只接受类型令牌相关的依赖时，比起在每个构造函数参数上使用@Inject()，@Injectable()的语法简洁多了。 不好的写法： app/heroes/shared/hero-arena.service.ts export class HeroArena { constructor( @Inject(HeroService) private heroService: HeroService, @Inject(Http) private http: Http) {} } 好的写法： @Injectable() export class HeroArena { constructor( private heroService: HeroService, private http: Http) {} } ---------- ## **八、数据服务** ### **1. 通过服务与Web服务器交互** * 坚持把数据操作和与数据交互的逻辑重构到服务里。 * 坚持让数据服务来负责 XHR 调用、本地储存、内存储存或者其它数据操作。 ***这么做的理由：*** * 组件的职责是为视图展示或收集信息。它不应该关心如何获取数据，它只需要知道向谁请求数据。把如何获取数据的逻辑移动到数据服务里，简化了组件，让其聚焦于视图。 * 在测试使用数据服务的组件时，可以让数据调用更容易被测试（模拟或者真实）。 * 数据管理的详情，比如头信息、方法、缓存、错误处理和重试逻辑，不是组件和其它的数据消费者应该关心的事情。 * 数据服务应该封装这些细节。这样，在服务内部修改细节，就不会影响到它的消费者。并且更容易通过实现一个模拟服务来对消费者进行测试。 --------- ## **九、生命周期钩子** 使用生命周期钩子来介入到 Angular 暴露的重要事件里。 ### **1. 实现生命周期钩子接口** * 坚持实现生命周期钩子接口。 ***这么做的理由：*** * 如果使用强类型的方法签名，编译器和编辑器可以帮你揪出拼写错误。 不好的写法： app/heroes/shared/hero-button/hero-button.component.ts @Component({ selector: 'toh-hero-button', template: OK }) export class HeroButtonComponent { onInit() { // misspelled console.log('The component is initialized'); } } 好的写法： @Component({ selector: 'toh-hero-button', template: OK }) export class HeroButtonComponent implements OnInit { ngOnInit() { console.log('The component is initialized'); } } ``` powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/angular/010-TS_JS中一些知识点.html":{"url":"doc/angular/010-TS_JS中一些知识点.html","title":"TS_JS中一些知识点","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 es6 javascript对象方法Object.assign() ### 获取屏幕分辨率 ### es6 javascript对象方法Object.assign() 1 基本用法Object.assign方法用于对象的合并，将源对象（ source ）的所有可枚举属性，复制到目标对象（ target ）。 var target = { a: 1 }; var source1 = { b: 2 }; var source2 = { c: 3 }; Object.assign(target, source1, source2); target // {a:1, b:2, c:3} 2 注意点Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 var obj1 = {a: {b: 1}}; var obj2 = Object.assign({}, obj1); obj1.a.b = 2; obj2.a.b // 2 上面代码中，源对象obj1的a属性的值是一个对象，Object.assign拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。 3 常见用途（ 1 ）为对象添加属性（ 2 ）为对象添加方法（ 3 ）克隆对象（ 4 ）合并多个对象（ 5 ）为属性指定默认值 4 详细介绍： http://blog.csdn.net/qq_30100043/article/details/53422657 获取屏幕分辨率 # 可直接在JS代码中用 screen.height ：屏幕高度。 screen.width ：屏幕宽度。 screen.availHeight ：屏幕可用高度。即屏幕高度减去上下任务栏后的高度，可表示为软件最大化时的高度。 screen.availWidth ：屏幕可用宽度。即屏幕宽度减去左右任务栏后的宽度，可表示为软件最大化时的宽度。 # 任务栏高/宽度 ：可通过屏幕高/宽度 减去 屏幕可用高/宽度得出。如：任务栏高度 = screen.height - screen.availHeight 。 window.outerHeight ：浏览器高度。 window.outerWidth ：浏览器宽度。 window.innerHeight ：浏览器内页面可用高度；此高度包含了水平滚动条的高度(若存在)。可表示为浏览器当前高度去除浏览器边框、工具条后的高度。 window.innerWidth ：浏览器内页面可用宽度；此宽度包含了垂直滚动条的宽度(若存在)。可表示为浏览器当前宽度去除浏览器边框后的宽度。 # 工具栏高/宽度 ：包含了地址栏、书签栏、浏览器边框等范围。如：高度，可通过浏览器高度 - 页面可用高度得出，即：window.outerHeight - window.innerHeight。 # 详细介绍： http://www.cnblogs.com/polk6/p/5051935.html powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/001-ruby中语法知识.html":{"url":"doc/ruby/001-ruby中语法知识.html","title":"ruby中语法知识","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 return home 参考链接 知识点 类方法的定义 ruby中的布尔值 return home 参考链接 理解Ruby中的作用域 Ruby 中的类与对象 Ruby学习之元编程　　Kernel#evel(), Object#instance_evel()、Module#class_evel() 知识点 ruby中include和extend以及模块中ClassMethods Ruby require,load,include,extend的显著区别 Ruby中的 Object、Class、Module之间关系　　Class与Module的区别 method查看方法是哪个类定义的 methods查看对象有哪些方法 source_locationc查看方法定义处 method = method('_run_validate_callbacks') p method p method.source_location # # [\"/home/yulilong/.rvm/gems/ruby-2.3.0/gems/activesupport-5.0.0.1/lib/active_support/callbacks.rb\", 749 检查一个变量是否已经定义可以用defined?，如果未定义会返回字符串\"nil\"，否则返回该变量的定义类型。如下面的例子: irb(main):007:0> a = 1 => 1 irb(main):008:0> defined? a => \"local-variable\" irb(main):009:0> defined? b => nil irb(main):010:0> defined? nil => \"nil\" irb(main):011:0> defined? String => \"constant\" irb(main):012:0> defined? 1 => \"expression\" p caller 可以查看是谁调用了你 ruby的class http://blog.csdn.net/lyx2007825/article/details/10089115class Array class 对象中存在实例变量 (instance variables) ，可以通过方法 instance_variables 进行查看当前对象中的 实例变量 class MyClass def my_method @v = 1 end end obj = MyClass.new obj.class # => MyClass obj.instance_variables # => [] obj.my_method obj.instance_variables # => [:@v] .class的使用因为类也是一种对象，因此所有对象的特性也是类具有的特性。比如，(Class) 有自己的类，这个类就是——Class，举个例子，假如一个字符串可以通过 str#class 获得它的类 String ，那么 String 作为一个对象也可以通过 String#class 获知它自己的类。比如下面的代码: \"hello\".class # => String String.class # => Class Class.class # => Class 类方法的定义 class HelloWorld def greet end end # 1.在class ruby 中super和super()的区别http://blog.csdn.net/autumn20080101/article/details/8146310 ``` 我们经常要在子类的initialize方法中调用super和super()。 从语法上说super和super()是有微妙区别的。 super不带括号表示调用父类的同名函数，并将本函数的所有参数传入父类的同名函数； super()带括号则表示调用父类的同名函数，但是不传入任何参数； class SParent def initialize *args args.each {|arg| puts arg} endend class SChild def initialize a, b, c super endend a, b, c = *%W[a b c]SChild.new a, b, c # puts a, b, c if superSChild.new a, b, c # puts nothing if super() 可以看出当SChild的initialize中调用super()时，代码是不会打印任何信息的。这是因为super()没有向SParent的initialize方法传任何参数。 * **ruby 类方法中 self.class.方法名** 子类中方法调用父类中同名的 类方法 class AA def self.te p 'I an AA' end end class BB \"I an AA\" * **完美理解ruby中的yield的概念** 看到axgle 兄解释ruby中的yield的概念，形象的理解为“占位”的作用。 但是对yield还可以带着参数的概念总觉得有点不够形象， def foo yield [1,2,3] end foo {|v| p v} 以我看来更像是，比喻成一个纯虚函数更好理解，其中，在方法后跟块后，不过就是对yield的声明化了而已。 不过对于初步理解yield还是有很好帮助，算是完美解释了。大学里常常发生占位置的现象：头天晚上拿一本书放在课座上，表示位置已经被占了;第二天才来到这个座位上，翻开书正式上课.在这个现象中，“书本”充当了“占位符”的作用。在Ruby语言中，yield是占位符:先在前面的某部分代码中用yield把位置占着，然后才在后面的某个代码块(block)里真正实现它,从而完成对号入座的过程.定义finddef find(dir) Dir.entries(dir).each {|f| yield f} #获得dir目录下的文件名列表;对每个文件名,用yield来处理(至于怎么处理，还不知道，占个位置先^_^)end 使用findfind(\".\") do |f| #block开始 puts f #用输出文件名这个语句，真正实现了yield的处理(也可以用任何其他语句)end #block结束 由此可见，yield属于定义层，属于宣告层，也就是在心里说一句:\"这个位置不错，我先用书本占了再说!\"; 而block属于使用层，实现层,也就是最终你坐在了你先前占的位置上，从而真正的实现了对号入座的过程. * **empty、nil、blank三者之间的区别** http://www.cnblogs.com/lmei/p/3262816.html 这三个方法在ROR中经常用到，都是用来判断是否为空的。 区别是： ruby的方法：.nil?、.empty? rails的方法 ：.blank? 用法的区别： .nil? : 判断对象是否存在。.empty? : 是对象已经存在，判断是否为空字段。.blank? : 相当于同时满足 .nil? 和 .empty? 。注： Rails API中的解释是如果对象是：false, empty, 空白字符都是blank。比如说： \"\", \" \", nil, [], 和{}都算是blank。也就是说，object.blank? 相当于 object.nil? || object.empty?.nil? 和 empty? 的简单例子 true.blank? #=> false false.blank? #=> true \"true\".blank? #=> false \"\".blank? #=> true \"\\n\".blank? #=> true '\\n'.blank? #=> false 'true'.blank? #=> false ''.blank? #=> true 1.blank? #=> false [].blank? #=> true [1].blank? #=> false * alias设置别名 alias 别名 原名 #直接使用方法名 alias :别名 :原名 #使用符号名 除了为方法设置别名外，在重定义以存在的方法时，为了能用别名调用原来的方法，也需要用alias ``` ruby中的布尔值 ruby中布尔值是一个特殊对象。它由两个类型组成TrueClass和FalseClass，可以在irb里试一下 true.class，这两个类型生成两个特殊的对象： true 和 false。 所有ruby中的对象都可以转成布尔值，nil是false，其他全部是true，当然false还是false。 在irb里试：puts \"true\" if nil，则不会打出 true，而是返回nil。 0并不象想象中的那样是false，而是true. 可以在irb里试一下: puts \"true\" if 0 . 这会打印出true，说明0就是true，因为它是一个对象，ruby没有数字型的说法，而是一个对象。 在使用的时候，如果掌握不了这种灵活的用法，那么就注意几点就行了：1.使用同类型比较，返回的布尔值肯定是对的。比如： 0==\"0\" ，这是false。 0==0 就是true。2.不要直接取对象的布尔值。比如： 0 是true, \"0\" 也是 true， 而 0!=0 是false，如果判断非0一定要直接写 obj != 0 ，不能象c那样写。即使是判断nil，也用 obj.nil?，这样代码比较清晰。3.使用if ，弃用unless。如果你有时候会弄晕，那么为了保证安全，只用if ，即使是检查nil也不用unless。特别是你在多种语言间转来转去的时候。http://www.th7.cn/Program/c/201609/952039.shtml powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/002-include和extend以及模块中ClassMethods.html":{"url":"doc/ruby/002-include和extend以及模块中ClassMethods.html","title":"include和extend以及模块中ClassMethods","keywords":"","body":"http://developer.51cto.com/art/200907/132919.htm从模块引入方法、变量，使得编程变得简单，扩展性愈强，比以往的类的继承更灵活。这样的引入，仿佛将一个方法块，复制了一份放到了你所引用的类或者模块里面。你完全可以将多个互不相干的类中相同的方法拿出来写到一个模块中，这样可以使得代码精简，符合Ruby的设计初衷，而且，使得你的程序更有条理。 Ruby on Rails常见用法 通常引用模块有以下3种情况： 1.在类定义中引入模块，使模块中的方法成为类的实例方法 这种情况是最常见的 直接 include 即可 2.在类定义中引入模块，使模块中的方法成为类的类方法 这种情况也是比较常见的 直接 extend 即可 3.在类定义中引入模块，既希望引入实例方法，也希望引入类方法 这个时候需要使用 include, 但是在模块中对类方法的定义有不同，定义出现在self.included块中 def self.included(c) ... end 中 Ruby on Rails实例讲解 Code #!ruby #基类 module Base #显示 def show puts \"You came here!\" end end class Car extend Base #扩展了类方法，我们可以通过Car.show调用 end class Bus include Base #扩展了实例方法，可以通过Bus.new.show调用 end 但是我们经常有这样的需要，希望基类足够强大，既可以扩展实例方法，也可以扩展类方法，Ruby on Rails同样提供了解决方案。 #!ruby Code #基类 module Base def show puts \"You came here!\" end #扩展类方法 def self.included(base) def base.call puts \"I'm strong!\" end base.extend(ClassMethods) end #类方法 # extend ActiveSupport::Concern # if not add this line,then module ClassMethods is Invalid module ClassMethods def hello puts \"Hello baby!\" end end end class Bus include Base end 此时Bus已经具备了实例方法show,类方法：call 、hello,访问方式 肯定也有人提出此类疑问，使用extend能够实现此功能不？ 答案是：暂未找到，如您找到请明示，多谢！ 我也曾经做过以下实验，结果没有成功，在此也张贴出来，希望能给您带来一些启示。 #!ruby Code #基类 module Base def show puts \"You came here!\" end #扩展实例方法 def self.extended(base) base.extend(InstanceMethods) end module InstanceMethods def love puts 'We are instances,loving each other!' end end end class Car extend Base end 但是这样，实例方法扩展失败，依然扩展了类方法 #!ruby Car.show Car.love #类方法 Car.new.love #undefined method 'love' powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/003-require,load,include,extend的显著区别.html":{"url":"doc/ruby/003-require,load,include,extend的显著区别.html","title":"require,load,include,extend的显著区别","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 require，load用于包含文件；include，extend则用于包含模块。 include,require,load的显著区别 引用单个和目录下所有rb的方法 include和extend require，load用于包含文件；include，extend则用于包含模块。 include,require,load的显著区别 http://www.cnblogs.com/mover/p/3686176.html require和load不同，它只加载文件一次，即在第一次执行到require时载入，以后碰到require同一文件时自动忽略，已经被加载的文件保存在$”中。 require还可以用来加载二进制格式的库。Require可以使用绝对路径或相对路径，如果使用了相对路径，那么系统会在$:变量包含的目录中搜寻。 Require和load的另一个不同是当包含文件是Ruby代码时，require可以不加后缀名。Require将当前所有加载的文件保存在$\"变量中。 在Irb里用load比用require 好，load允许我们多次加载同一个文件，这样如果我们发现一个BUG后编辑文件，可以将它重新加载到Irb的会话中。 总结： require, load,include都是Kernel模块中的方法，他们的区别如下： require，load用于包含文件，include则用于包含的模块。 require加载一次，load可加载多次。 require加载Ruby代码文件时可以不加后缀名，load加载代码文件时必须加后缀名。 require一般情况下用于加载库文件，而load用于加载配置文件。 load例子： #!ruby 4.times do |i| File.open(\"temp.rb\",\"w\") do |f| f.puts \"def test\" f.puts \"#{i}\" f.puts \"end\" end load \"temp.rb\" puts test end 执行结果为： 0 1 2 3 引用单个和目录下所有rb的方法 http://blog.csdn.net/xuleilx/article/details/21830395除引用系统rb外，require中不能用相对路径。同一目录下的文件，如/usr/local/ruby/foo.rb与/usr/local/ruby/bar.rb两个文件。如果直接在foo.rb中： require 'bar' 执行时会报找不到bar.rb错误。这是因为运行: /home/oldsong~ ruby /usr/local/ruby/foo.rb 时会在ruby安装的lib目录和/home/oldsong/目录下查找bar.rb。而不会去rb文件的目录/usr/local/ruby/下查找。1、引用一个文件引用当前rb同目录下的file_to_require.rb require File.join(__FILE_, '../file_to_require')。 require File.expand_path('../file_to_require', __FILE__) require File.dirname(__FILE__) + '/file_to_require' 其中，File.expandpath是Rails常用的做法。 _FILE为常量，表示当前文件的绝对路径，如/home/oldsong/test.rb还可以： $LOAD_PATH.unshift(File.dirname(__FILE__)) # 先把目录加入LOAD_PATH变量中，然后可直接引用文件名 require 'bar' 2、引用一个目录下所有文件例：引用当前rb相同目录下lib/文件下所有*.rb文件。 # 方法一 Dir[File.dirname(__FILE__) + '/lib/*.rb'].each {|file| require file } # 方法二 # 一个gem # https://rubygems.org/gems/require_all include和extend http://blog.csdn.net/rocky_j2ee/article/details/3754781include主要用来将一个模块插入（mix）到一个类或者其它模块。extend 用来在一个对象（object，或者说是instance）中引入一个模块，这个类从而也具备了这个模块的方法。通常引用模块有以下3种情况：1.在类定义中引入模块，使模块中的方法成为类的实例方法这种情况是最常见的直接 include 即可 2.在类定义中引入模块，使模块中的方法成为类的类方法这种情况也是比较常见的直接 extend 即可 3.在类定义中引入模块，既希望引入实例方法，也希望引入类方法这个时候需要使用 include,但是在模块中对类方法的定义有不同，定义出现在 方法def self.included(c) ... end 中 完整的示例如下： #!ruby module Ma MA_VALUE = 1 def ma_1 puts \"it is ma_1\" end end module Mb MB_VALUE = 1 def self.included(c) def c.mb_2 puts \"it is mb_2\" end end def mb_1 puts \"it is mb_1\" end end class Ca include Ma end class Cb extend Ma include Mb end c1 = Ca.new c1.ma_1 c2 = Cb.new c2.mb_1 Cb.ma_1 Cb.mb_2 puts Ma::MA_VALUE puts Ca::MA_VALUE puts Mb::MB_VALUE puts Cb::MB_VALUE powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/004-Object、Class、Module之间关系.html":{"url":"doc/ruby/004-Object、Class、Module之间关系.html","title":"Object、Class、Module之间关系","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. 从继承关系来说，是Class -- Module -- Object，即Object是继承树的顶层，紧接着是Module，然后是Class。 2. module 与Class 区别 [TOC] 1. 从继承关系来说，是Class --> Module --> Object，即Object是继承树的顶层，紧接着是Module，然后是Class。 irb的输出结果： 2.3.0 :008 > puts Object.superclass BasicObject => nil 2.3.0 :009 > puts Module.superclass Object => nil 2.3.0 :010 > puts Class.superclass Module => nil 2.3.0 :011 > puts Object.public_methods - Kernel.public_methods new allocate superclass => nil 从上面的输出可以看出，Object中自己定义的方法只有\"superclass\" , \"allocate\"和\"new\"这三个方法，其余的方法，比如\"class\", \"to_s\", \"object_id\"等等都是在Kernel中实现的。 ruby中： 在Ruby中使用Class来标识所有的数据类型，所有的变量和常量都是Object的子类 Kernel是Module，Object的实现中包含了Kernel https://www.zhihu.com/question/19922190/answer/13359458 2. module 与Class 区别 一句话概括，就是： class可以实例化, module不可以, 别的都一样.关于继承的一点区别:class是使用作为继承的关键字，只支持单继承.module是使用include来做实例继承（实例化的时候动态功能插入），extend做类继承（可以理解为static继承）. module的应用场景: 作为namespace，里面放一般的const或者自己的class 作为工具模块，放通用方法，别的类里面直接include或者extend以后使用，也可以看成动态扩展业务类 可以作为抽象类，module里面提供默认实现，业务类include或者extend以后覆盖 作为接口来用，一个可用的接口库，module-interface http://jingpin.jikexueyuan.com/article/58139.html powered by Gitbook文件最后修改时间： 2021-03-12 09:16:46 "},"doc/ruby/005-rails中常见问题.html":{"url":"doc/ruby/005-rails中常见问题.html","title":"rails中常见问题","keywords":"","body":" N+1问题: N+1问题是数据库访问中最常见的一个性能问题，首先介绍一下什么是N+1问题：举个例子，我们数据库中有两张表，一个是Customers，一个是Orders。Orders中含有一个外键customer_id，指向了Customers的主键id。想要得到所有Customer以及其分别对应的Order，一种写法是：SELECT * FROM Customers;对于每一个Customer；SELECT * FROM Orders WHERE Orders.customer_id = #{customer.id}这样我们实际对数据库做了N+1次查询：选择所有Customer一次得到N个Customer，对于N个Customer分别选择其对应的Order一共N次。所以，一共执行了N+1次查询，这就是N+1问题 N+1问题的一般解决方法:使用Left Join一次性取出所有数据：SELECT * FROM Customers LEFT JOIN Orders on Customers.id = Orders.customer_id这样虽然取出的数据相对多一些，但是只需要一次执行 Rails中的N+1问题:因为Rails使用ActiveRecord访问数据库。所以，它的N+1问题暴露的不是那么明显。假设有如下代码，查找 10 条客户记录并打印这些客户的邮编： #!ruby clients = Client.limit(10) clients.each do |client| puts client.address.postcode end 上面的代码第一眼看起来不错，但实际上存在查询总次数较高的问题。这段代码总共需要执行 1（查找 10 条客户记录）+ 10（每条客户记录都需要加载地址）= 11 次查询。 Rails中 N + 1 查询问题的解决办法:Active Record 允许我们提前指明需要加载的所有关联，这是通过在调用 Model.find 时指明 includes 方法实现的。通过指明 includes 方法，Active Record 会使用尽可能少的查询来加载所有已指明的关联。回到之前 N + 1 查询问题的例子，我们重写其中的 Client.limit(10) 来使用及早加载： #!ruby clients = Client.includes(:address).limit(10) clients.each do |client| puts client.address.postcode end 上面的代码只执行 2 次查询，而不是之前的 11 次查询： #!mysql SELECT * FROM clients LIMIT 10 SELECT addresses.* FROM addresses WHERE (addresses.client_id IN (1,2,3,4,5,6,7,8,9,10)) 参考资料：http://www.cnblogs.com/15ho/p/6625673.htmlhttp://guides.rubyonrails.org/active_record_querying.html#eager-loading-associationshttp://guides.ruby-china.org/active_record_querying.html#%E5%8F%8A%E6%97%A9%E5%8A%A0%E8%BD%BD%E5%85%B3%E8%81%94 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/006-ruby比较常用的gems包.html":{"url":"doc/ruby/006-ruby比较常用的gems包.html","title":"ruby比较常用的gems包","keywords":"","body":" hashie https://rubygems.org/gems/hashie这个可以把hash数据当成对象使用 .点方法直接调用。 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/007-ruby_gems命令.html":{"url":"doc/ruby/007-ruby_gems命令.html","title":"ruby_gems命令","keywords":"","body":" 显示gem的帮助和版本 gem –h/--help #显示gem的帮助 gem –v /--version #显示gem的版本号 列出远程库的所有可用软件 gem query --remote # 短命令: gem q -r 查找远程主机上的特定软件 gem query --remote --name-matches doom # 短命令: gem q -rn doom # 你将看到一个匹配doom的详细列表。 gem list –remote --d #用子命令list列出远程安装的gems 安装一个远程软件 gem install --remote progressbar # 短命令: gem i -r progressbar –y # 远程安装progressbar到你的主机，-y的意思是无条件的安装依赖包 gem install rails –remote #从远程服务器安装rails包，其中rails可以被替换成任何一个gem list –remote –d中显示的软件包 安装软件的特定版本 gem ins -r progressbar-0.0.3 # 安装progressbar的0.0.3版本 gem ins -r progressbar --version '> 0.0.1' # 将安装progressbar的大于0.0.1的最新版本 查看一个已安装的软件 gem specification progressbar # 短命令: gem spec progressbar # 你会看到关于已安装的包progressbar的详细信息。 卸载一个软件 gem uninstall progressbar 卸载了progressbar 查看某个已安装的软件 gem query --local --name-matches doom # 短命令: 'gem q -ln doom' 构建gem包 gem build package.gemspec #运用bulid子命令构建gem包 http://www.jb51.net/article/65136.htm gem引用本地开发的gem包 gem \"azure-armrest\", :path => \"../azure-armrest/\" #相对路径或者全路径 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/008-国内RubyGems镜像.html":{"url":"doc/ruby/008-国内RubyGems镜像.html","title":"国内RubyGems镜像","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 概述 # 淘宝镜像 ## ruby-china镜像 ## 概述 对于电脑或服务器没有代理的需要设置ruby gems镜像，如果有代理，但是安装速度慢，也可以设置此镜像来加快安装速度。 淘宝镜像 https://ruby.taobao.org/之前都是使用淘宝镜像2016-12-27发现淘宝的ruby gem 镜像已经重定向到ruby-china了，所以不多做介绍了。 ruby-china镜像 http://gems.ruby-china.org/ 如何使用？ # 请尽可能用比较新的 RubyGems 版本，建议 2.6.x 以上。 $ gem update --system # 这里请翻墙一下 $ gem -v 2.6.3 $ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/ $ gem sources -l https://gems.ruby-china.org # 确保只有 gems.ruby-china.org 如果你使用 Gemfile 和 Bundle (例如：Rails 项目) # 你可以用 Bundler 的 Gem 源代码镜像命令。 $ bundle config mirror.https://rubygems.org https://gems.ruby-china.org # 这样你不用改你的 Gemfile 的 source。 source 'https://rubygems.org/' gem 'rails', '4.2.5' ... powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/009-Ruby中任务构建工具rake的入门学习教程.html":{"url":"doc/ruby/009-Ruby中任务构建工具rake的入门学习教程.html","title":"Ruby中任务构建工具rake的入门学习教程","keywords":"","body":"http://www.jb51.net/article/81476.htm Rake简介 Rake的意思是Ruby Make,一个用ruby开发的代码构建工具. 但是,为什么Ruby需要Rake? 按理说Ruby代码无需编译,应该不需要Rake才对呀?原来,Rake另有妙用,即把Rake当做一个任务管理工具来使用...这样做有两个好处: 1.以任务的方式创建和运行脚本 当然,你可以用脚本来创建每一个你希望自动运行的任务.但是,对于大型的应用来说,你几乎总是需要为数据库迁移(比如Rails中db:migrate任务)、清空缓存、或者代码维护等等编写脚本.对于每一项任务,你可能都需要写若干脚本,这会让你的管理变得复杂.那么,把它们用任务的方式整理到一起,会让管理变得轻松很多. 2.追踪和管理任务之间的依赖 Rake还提供了轻松管理任务之间依赖的方式.比如,\"migrate\"任务和\"schema:dump\"任务都依赖于 \"connect_to_database\"任务,那么在\"migrate\"任务调用之前,\"connect_to_database\"任务都会被执行. 下面入正题吧,即如何用Rake编写一个任务脚本.. 顺序执行 在Rake中定义任务后，可以指定任务的执行顺序，例如，每天早晨起床后的例行公事: 1. 关闭闹钟 2. 梳洗打扮 3. 泡杯咖啡 4. 遛狗 上面的几项事物，在Rakefile中这样描述 task :turn_off_alarm do puts \"Turned off alarm. Would have liked 5 more minutes, though.\" end task :groom_myself do puts \"Brushed teeth.\" puts \"Showered.\" puts \"Shaved.\" end task :make_coffee do cups = ENV[\"COFFEE_CUPS\"] || 2 puts \"Made #{cups} cups of coffee. Shakes are gone.\" end task :walk_dog do puts \"Dog walked.\" end task :ready_for_the_day => [:turn_off_alarm, :groom_myself, :make_coffee, :walk_dog] do puts \"Ready for the day!\" end 通过rake ready_for_the_day来执行任务，然后你就可以看到，所有的task都在按照你预定的顺序在执行。 Turned off alarm. Would have liked 5 more minutes, though. Brushed teeth. Showered. Shaved. Made 5 cups of coffee. Shakes are gone. Dog walked. Ready for the day! 此外还可以用过rake make_coffee COFFEE_CUPS=5这样在命令中给变量赋值。 命名空间 上面那样定义任务没有问题，但如果你需要另外定义些事物，比如工作相关的，交通相关的，这时候所有的任务混杂到一起显然就不合适了，毕竟上面那些任务只是我们起床的例行事物，与其它无关。 通过namespace可以帮助我们定义出Rails中类似rake db:migrate的任务，描画出事物间清晰的边界，将上面的任务包括在namespace的一个代码块中，如下 namespace :morning do task :turn_of_alarm .... end 这一次我们的调用命令就需要稍微做出些许变化，rake COFFEE_CUPS=3 morning:ready_for_the_day。 是不是跟rails中的rake任务调用方式很像呢？ 默认Task 有了上面那些设置，如果我们忘记或者不想写详细的任务名称，直接执行rake会有什么效果呢，结果是rake aborted!,任务被中断的报错。既然有这样的可能性，我们就需要消除这些隐患，通过设置default默认任务就可以做到，如下: task :default => 'morning:turn_off_alarm' 当你直接执行rake命令时，会执行默认操作，帮我们关闭闹钟。 描述你的Task 当任务渐渐变多以后，管理问题就暴露出来了，除了命名空间以外，我们还需要文档类的支持，帮助我们梳理任务并显示的告诉我们每个任务的目的和功能，这时你可以试一试用desc描述任务。 ... desc \"Make coffee\" task :make_coffee do cups = ENV[\"COFFEE_CUPS\"] || 2 puts \"Made #{cups} cups of coffee. Shakes are gone.\" end ... 上面的描述不仅可以在文档中查看，同时使用rake -T也能清洗的了解到每个任务是做什么的。rake -T的输出结果是按照字母顺序排的序。 rake morning:make_coffee # Make coffee 调取Task Rake还允许在不同任务之间互相调用，例如下面的代码,你想在下午也来杯咖啡，不用重复定义，直接使用上午的泡法，来一杯即可。 namespace :afternoon do task :make_coffee do Rake::Task['morning:make_coffee'].invoke puts \"Ready for the rest of the day!\" end end Rake脚本编写 先来个简单的例子,如下: 假设你是一个火星成员,老版本那些,即如燕儿虎跑之类的,在周末你打算去车车那边打火锅,然后集体PC去.对应这个情况,你需要为自己制定三个任务:搭车找车车、烤鱼和网吧PC.用vim创建创建一个名叫rakefile的文件(备注:Rake会在当前路径下寻找名叫Rakefile、rakefile、RakeFile.rb和rakefile.rb的rake文件),并键入如下代码: desc \"任务1 -- 搭车去车车那里\"#这据说是个苦差,因为太远了 task :busboy do puts \"发现挫男\" end desc \"任务2 -- 烤鱼\" task :bitchfish do puts \"老板,先烤九斤鱼\" end desc \"任务3 -- 网吧PC\" task :pc do puts \"我选中路\" end 打开命令行工具,进入这个文件所在目录,然后运行下面的命令,大致应该类似如下结果: D:\\work>rake busboy (in D:/work) 发现挫男 D:\\work>rake bitchfish (in D:/work) 老板,先烤九斤鱼 D:\\work\\ruby_works\\ruby_book>rake laundry (in D:/work) 我选中路 (备注:文字部分是没啥逻辑的,纯粹娱乐下...) 分析： 相信看完上面那段东东,你已经知道怎么搞了...现在介绍些基础知识,方便加深理解.从上面的代码可以知道,此文件一共定义了3个任务,desc是Rake定义的方法,表示对下面定义任务的描述.这个描述会在使用Rake --tasks(或者Rake -T)命令时输出在屏幕上. D:\\work>rake --tasks (in D:/work) rake bitchfish #任务2 -- 烤鱼 rake busboy #任务1 -- 搭车去车车那里(这据说是个苦差,因为太远了) rake pc 任务3 -- 网吧PC task是Rake最重要的方法.它的方法定义是:task(args, &block).任务体是一个block,本例中只是简单输出你所要做的工作.需要注意的是代码 puts \"发现挫男\" 完全是一个普通的Ruby语句,puts是Ruby中进行输出的一般性方法,可以看出,Rake任务可以完全使用Ruby的能力,这使得它非常强大. go..go..go..go.. 接下来加入依赖关系： 很显然,在我们定义的任务中,\"烤鱼\"是依赖于\"搭车去车车那里\"的(其它地方有没烤鱼吃不知道,反正地点就定在那了).那么,我们需要在我们的任务定义中加入这个依赖关系,修改后的文件如下: desc \"任务1 -- 搭车去车车那里\" task :busboy do puts \"发现挫男\" end desc \"任务2 -- 烤鱼\" task :bitchfish => :busboy do puts \"老板,先烤九斤鱼\" end desc \"任务3 -- 网吧PC\" task :pc do puts \"我选中路\" end 再次运行烤鱼任务,你会得到如下结果: D:\\work>rake bitchfish (in D:/work) 发现挫男 老板,先烤九斤鱼 加入命名空间： 跟任何编程语言类似,当你的rake文件很多时,当你有很多任务的时候,你需要关注它们的命名冲突问题,命名空间(namespace)就是一个自然的解决方案.你可以为上面的三个任务定义一个叫做dan的命名空间. namespace :dan do desc \"任务1 -- 搭车去车车那里\" task :busboy do puts \"发现挫男\" end …… end 再次运行rake --tasks,你会得到如下的结果: D:\\work >rake --tasks (in D:/work) rake dan:bitchfish # 任务2 -- 烤鱼 rake dan:pc # 任务3 -- 网吧PC rake dan:busboy # 任务1 -- 搭车去车车那里 你现在需要使用rake dan:bitchfish才能启动烤鱼这个任务了. (BTW,你可以在你的rakefile中使用多个命名空间,对任务进行分类.) 了解了上面两个知识点后,我们来了解下两个具体实例: 1.在一个任务中调用另外一个任务 当任务众多的时候,你很可能需要在一个任务中调用另外一个任务,假设我们把今天所有要做的工作定义为一个任务:today.在这个任务中,有两个任务需要被调用,一个是烤鱼,一个是网吧PC.当然,由于烤鱼依赖于搭车去车车那里,我们还是需要搭车去车车那里的.在文件的顶部定义一个today的任务: desc \"今天的任务\" task :today do Rake::Task[\"dan:bitchfish\"].invoke Rake::Task[\"dan:pc\"].invoke end namespace :dan do …… end 可以看出,调用其它任务的方式很简单,只需要调用 Rake::Task[\"task_name\"].invoke 方法就可以了.在命令行中启动rake today,可以得到: D:\\work >rake today (in D:/work) 发现挫男 老板,先烤九斤鱼 我选中路 2.默认任务： 可以为Rake增加一个默认任务,这样可以简单地用Rake命令来触发这个默认任务,在上面的rakefile中,我们可以用如下方式把\"today\"任务作为默认任务. task :default => [:today] 然后调用直接在命令行中调用rake,可以得到跟调用rake today同样的输出结果. 这就是我们简单的一个Rake任务定义,下面是完整的修改后的rakefile: task :default => [:today] desc \"今天的任务\" task :today do Rake::Task[\"dan:bitchfish\"].invoke Rake::Task[\"dan:pc\"].invoke end namesoace :dan do desc \"任务1 -- 搭车去车车那里(这据说是个苦差,因为太远了)\" task :busboy do puts \"发现挫男\" end desc \"任务2 -- 烤鱼\" task :bitchfish do puts \"老板,先烤九斤鱼\" end desc \"任务3 -- 网吧PC\" task :pc do puts \"我选中路\" end end 看完上面两个例子,估计rake任务就算全部了解了...其它都是些代码枪花罢了..多耍便是.. powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/010-Ruby中的Rake任务详述.html":{"url":"doc/ruby/010-Ruby中的Rake任务详述.html","title":"Ruby中的Rake任务详述","keywords":"","body":"http://wenku.baidu.com/link?url=tLW8V7LpI66Z7jRd_HkqGkXi-qNTZYr11_FZ6b0lt9qf7lHMQtO5eWbQqJ4K87eFcrGZ2IAm-7oG3gzI4-_XZs2gpVdY-pODVFL8sXfCZsq ﻿Rake简介 Rake和Make及Ant Rake的意思是Ruby Make，一个用ruby开发的代码构建工具。Rake的英文意思是耙子，一种很朴实的劳动工具。真的是很贴切，Rake正是一个功能强大、勤勤恳恳的劳动工具。 但是，为什么Ruby需要Rake？ Ruby代码不需要编译，为什么需要Rake？其实，与其说Rake是一个代码构建工具，不如说Rake是一个任务管理工具，通过Rake我们可以得到两个好处： 以任务的方式创建和运行脚本 当然，你可以用脚本来创建每一个你希望自动运行的任务。但是，对于大型的应用来说，你几乎总是需要为数据库迁移（比如Rails中db:migrate任务）、清空缓存、或者代码维护等等编写脚本。对于每一项任务，你可能都需要写若干脚本，这会让你的管理变得复杂。那么，把它们用任务的方式整理到一起，会让管理变得轻松很多。 追踪和管理任务之间的依赖 Rake还提供了轻松管理任务之间依赖的方式。比如，“migrate”任务和“schema：dump”任务都依赖于 “connect_to_database”任务，那么在“migrate”任务调用之前，“connect_to_database”任务都会被执行。 在哪里可以获得Rake？ Rake的主页是在http://rake.rubyforge.org/，在这里你可以获得Rake的简单介绍，API以及一些有用文档的链接。可以在http://rubyforge.org/frs/?group_id=50获得最新版的Rake，在作者写作时，最新版本是0.7.3。 Rake脚本编写 一个简单脚本 Rake的脚本相当简单，下面用一个例子进行说明。假设你是一个勤劳的家庭型程序员，在周末你打算为你的家人做一些贡献。所以你为自己制定了三个任务：买菜、做饭和洗衣服。打开你的文本编辑器，创建一个名叫rakefile的文件（Rake会在当前路径下寻找名叫Rakefile、rakefile、RakeFile.rb和rakefile.rb的rake文件），并输入如下内容： desc \"任务1 -- 买菜\" task :purchaseVegetables do puts \"到沃尔玛去买菜。\" end desc \"任务2 -- 做饭\" task :cook do puts \"做一顿香喷喷的饭菜。\" end desc \"任务3 -- 洗衣服\" task :laundry do puts \"把所有衣服扔进洗衣机。\" end 打开命令行工具，进入这个文件所在目录，然后运行下面的命令，大致应该类似如下结果： D:\\work\\ruby_works\\ruby_book>rake purchaseVegetables (in D:/work/ruby_works/ruby_book) 到沃尔玛去买菜。 D:\\work\\ruby_works\\ruby_book>rake cook (in D:/work/ruby_works/ruby_book) 做一顿香喷喷的饭菜。 D:\\work\\ruby_works\\ruby_book>rake laundry (in D:/work/ruby_works/ruby_book) 把所有衣服扔进洗衣机。 分析 很简单，也很易读，对吧。这个文件一共定义了3个任务，desc是Rake定义的方法，表示对下面定义任务的描述。这个描述会在使用Rake --tasks（或者Rake -T，为懒人准备的快捷方式）命令时输出在屏幕上。 D:\\work\\ruby_works\\ruby_book>rake --tasks (in D:/work/ruby_works/ruby_book) rake cook # 任务2 -- 做饭 rake laundry # 任务3 -- 洗衣服 rake purchaseVegetables # 任务1 -- 买菜 下面的语句定义了purchaseVegetables这个任务，task是Rake最重要的方法。它的方法定义是：task(args, &block)。任务体是一个block，本例中只是简单输出你所要做的工作。需要注意的是代码 puts \"到沃尔玛去买菜。\" 完全是一个普通的Ruby语句，puts是Ruby中进行输出的一般性方法，可以看出，Rake任务可以完全使用Ruby的能力，这使得它非常强大。 加入依赖关系 很显然，在我们定义的任务中，做饭是依赖于买菜的（我相信大多数程序员在周末的冰箱里除了可乐没有别的）。那么，我们需要在我们的任务定义中加入这个依赖关系，修改后的文件如下： desc \"任务1 -- 买菜\" task :purchaseVegetables do puts \"到沃尔玛去买菜。\" end desc \"任务2 -- 做饭\" task :cook => :purchaseVegetables do puts \"做一顿香喷喷的饭菜。\" end desc \"任务3 -- 洗衣服\" task :laundry do puts \"把所有衣服扔进洗衣机。\" end 再次运行做饭任务，你会得到如下结果： D:\\work\\ruby_works\\ruby_book>rake cook (in D:/work/ruby_works/ruby_book) 到沃尔玛去买菜。 做一顿香喷喷的饭菜。 是的，你当然需要先买菜，谁让你是一个冰箱空空如野的程序员呢。 命名空间 跟任何编程语言类似，当你的rake文件很多时，当你有很多任务的时候，你需要关注它们的命名冲突问题，命名空间（namespace）就是一个自然的解决方案。你可以为上面的三个任务定义一个叫做home的命名空间。 namespace :home do desc \"任务1 -- 买菜\" task :purchaseVegetables do puts \"到沃尔玛去买菜。\" end …… end 再次运行rake --tasks，你会得到如下的结果： D:\\work\\ruby_works\\ruby_book >rake --tasks (in D:/work/ruby_works/ruby_book) rake home:cook # 任务2 -- 做饭 rake home:laundry # 任务3 -- 洗衣服 rake home:purchaseVegetables # 任务1 -- 买菜 你现在需要使用rake home:cook才能启动做饭这个任务了。当然，你可以在你的rakefile中使用多个命名空间，对任务进行分类。 在一个任务中调用另外一个任务 当任务众多的时候，你很可能需要在一个任务中调用另外一个任务，假设我们把今天所有要做的工作定义为一个任务：today。在这个任务中，有两个任务需要被调用，一个是做饭，一个是洗衣服。当然，由于做饭依赖于买菜，我们还是需要买菜的（这一步是逃不过去的，呵呵）。在文件的顶部定义一个today的任务： desc \"今天的任务\" task :today do Rake::Task[\"home:cook\"].invoke Rake::Task[\"home:laundry\"].invoke end namespace :home do …… end 可以看出，调用其它任务的方式很简单，只需要调用Rake::Task[\"task_name\"].invoke 方法就可以了。在命令行中启动rake today，可以得到： D:\\work\\ruby_works\\ruby_book >rake today (in D:/work/ruby_works/ruby_book) 到沃尔玛去买菜。 做一顿香喷喷的饭菜。 把所有衣服扔进洗衣机。 默认任务 可以为Rake增加一个默认任务，这样可以简单地用Rake命令来触发这个默认任务，在上面的rakefile中，我们可以用如下方式把“today”任务作为默认任务。 task :default => [:today] 然后调用直接在命令行中调用rake，可以得到跟调用rake today同样的输出结果。 这就是我们简单的一个Rake任务定义，下面是完整的修改后的rakefile： task :default => [:today] desc \"今天的任务\" task :today do Rake::Task[\"home:cook\"].invoke Rake::Task[\"home:laundry\"].invoke end namespace :home do desc \"任务1 -- 买菜\" task :purchaseVegetables do puts \"到沃尔玛去买菜。\" end desc \"任务2 -- 做饭\" task :cook => :purchaseVegetables do puts \"做一顿香喷喷的饭菜。\" end desc \"任务3 -- 洗衣服\" task :laundry do puts \"把所有衣服扔进洗衣机。\" end end Rails中的Rake任务 Rails预定义了大量的Rake任务，在Rails应用的开发过程中，你想必已经在大量使用它们了。在Rails中，所有的Rake任务都放在rails目录的lib/tasks目录下（在作者的环境下是c:\\ruby\\lib\\ruby\\gems\\1.8\\gems\\rails-1.1.4\\lib\\tasks\\），所有的rake任务都以.rake作为后缀名，这些以.rake结尾的文件会被自动加载到你的环境中。你可以到一个已有的Rails工程根目录下键入rake --tasks，可以看到很多的rake任务已经为你整装待发了。 在Rails中，最常使用的Rake任务之一是进行数据库的迁移（migration）。数据库迁移程序允许你使用Ruby脚本来定义数据库模式，而db:migrate就是进行这个工作的rake任务。下面我们来分析这个rake任务。 db:migrate任务 db:migrate任务存放在lib/tasks/databases.rake文件中。这个文件中定义了所有与数据库操作相关的任务，我们仅仅抽出db:migrate的定义： namespace :db do desc \"Migrate the database through scripts in db/migrate. Target specific version with VERSION=x\" task :migrate => :environment do ActiveRecord::Migrator.migrate(\"db/migrate/\", ENV[\"VERSION\"] ? ENV[\"VERSION\"].to_i : nil) Rake::Task[\"db:schema:dump\"].invoke if ActiveRecord::Base.schema_format == :ruby end …… end 分析 首先是命名空间的声明，migrate任务的命名空间是db。这也就是我们用db:migrate来引用它的原因。 下面是一个描述，说明该任务的功能是把定义在db/migrate目录下（相对于你的Rails应用程序的根目录）的迁移脚本迁移到数据库中，如果不指定VERSION的话，默认是最新版本，否则可以恢复到一个指定的版本。 接着是任务的定义，该任务依赖于enviroment任务，这个任务在misc.rake中定义，用来加载Rails的环境，它的定义相当简单： task :environment do require(File.join(RAILS_ROOT, 'config', 'environment')) end 用来加载config/environment.rb文件，该文件会加载Rails工作所需要加载的环境。由于加载了这个环境，所以ActiveRecord对象现在可以使用，下面就是调用ActiveRecord::Migrator.migrate方法对每个db/migrate/下的脚本文件进行迁移。 最后会调用db:schema:dump任务，该任务的主要作用是产生db/schema.rb文件。该文件用来记录不同版本的数据库模式。这个任务的定义就在db:migrate任务下面不远的地方，有兴趣的读者可以自行进行分析。 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/011-ruby_on_Rails中的Rake教程.html":{"url":"doc/ruby/011-ruby_on_Rails中的Rake教程.html","title":"ruby_on_Rails中的Rake教程","keywords":"","body":"http://blog.csdn.net/maowenbin/article/details/5539564 原文：http://jasonseifer.com/2010/04/06/rake-tutorial 引言：作为一个rails的开发者，你可能很熟悉使用rake进行你的测试，或者使用rake db:migrate运行你的migrations，但是你真的知道Rake的背后故事吗？你意识到可以自己写一个Rake任务或者一个有用的 lib吗 ？ 下面是我们使用Rake任务的例子： 1、给列表中的用户发送邮件 2、每晚数据的计算和报告 3、过期或重新生成缓存 4、备份数据和svn版本(how's this : subversion repository ) 5、运行数据处理脚本(sort of,how much is called this ) 6、Pouring drinks to get a good buzz on(一句玩笑，是这两位仁兄的风格) 这篇文章中，我们将讨论为什么要创建Rake，和他怎么样帮助我们的rails应用。最好你可以写自己的Rake。 一、历史回顾：make 为了了解Rake的来历，我们先了解一下Rake的爷爷：Make。 让我们回到那个代码块需要编译，解释性语言和iphone还没出现在地球上的时代。 回到那时，我们下载的大型程序，还是一堆源代码和一个shell脚本。这个shell脚本包含了所有需要用来compile/link/build的代 码。你需要运行“install_me.sh”这个脚本，每一行代码将被运行（编译每一行源文件），然后生成一个你能够运行的文件。 对于大多数人这样是不错的，但是对于程序开发人员却是一个不幸。每次你对源代码进行一个小的改动，并进行测试的时候，你需要回到shell脚本，并重新编 译所有的源代码，显然对于大的程序“那是相当的”耗时的。 1977年（作者出生那年，我78年），贝尔实验室的Stuart Feldman创造了“make”。解决了编译时间过长的问题。Make用来编译程序，取得两方面的进步： Stuart Feldman （1）Make可以发现哪个文件在上一次编译后改动过，根据这点，再次运行Make时，仅编译改动过的文件。这个很大程序上减少了重新编译大型程序的时 间。 （2）Make可以进行从属跟踪。你可以告诉编译器，源文件A的编译需要源文件B，源文件B的编译需要源文件C，所以Make在编译A时发现B没有编译， 将会先编译B。 可以这样定义：Make是一个可执行程序。像ls或dir一样。让Make理解如何让编译一个项目，需要创建一个makefile文件，描述所有的源文件 和依赖关系。makefiles有自己的语法，你不用去了解。 这些年Make出现了其他的变体，并且被其他的语言使用。事实上，ruby用户在rake出现前也在使用它。 “但是，ruby并不需要编译，我们用它来干嘛？” 是啊。ruby是一个解释性语言，我们不需要编译它的源代码，所以ruby程序员为什么使用它呢？ 两个重要的原因： （1）创建任务 在大型的应用中，你经常编写脚本，在命令行下运行一些任务。比如清除缓存，维护任务，或者迁移数据库。你可以写一个MakeFile来组织你的任务，而不 是写十个不相干的脚本（或者一个复杂的）。这样你可以简单的运行：“make stupid”。 （2）从属任务跟踪 当你开始写一些维护任务的时候，可能发现有些任务的使用可能有重复。比如，“migrate”任务和“schema:dump”都需要链接数据库，这样我 可以创建一个任务\"connect_to_database\"，使“migrate”和“schema:dump”都依赖 于\"connect_to_database\"，这样下次运行“migrate”时，\"connect_to_database\"会先于 “migrate”运行 二、如何得到Rake 几年前，Jim Weirich 在一个 Java项目上使用了Make，他发现如果在他的Makefile中写一小段ruby代码 将会带来非常大的方便。所以 他创建了Rake。 左：Jim Weirich，中：Jason Seifer，右：Gregg Pollack （后面两位为本文作者） Jim 为Rake创建了任务功能，附属关系跟踪，甚至创建了时间段判断(timestamp recognition)，（在上一次编译的基础上仅编译改动的部分），当然，对于ruby，我们并不需要编译。 我很想知道Jim在代码里做了什么，你也想知道吧。Jim可能从来没想给这个代码写个文档，可能现在他也是被烦透了，写了一个 。呵 呵 三、Rake如何工作 开始我想给这个部分起名为\"How to get wasted with Rake\"。 那么我想喝点酒，该怎么做呢？ 1、去买酒 2、喝酒 3、喝醉 如果我要使用Rake完成这个任务，我会创建一个“Rakefile”文件： task :purchaseAlcohol do puts \" Purchased Vodka \" end task :mixDrink do puts \" Mixed Fuzzy Navel \" end task :getSmashed do puts \" Dood, everthing's blurry, can I halff noth'r drinnnk? \" end 这样我可以在这个Rakefile的目录，分别运行这些任务： $ rake purchaseAlcohol Purchased Vodka $ rake mixDrink Mixed Fuzzy Navel $ rake getSmashed Dood , everthing' s blurry, can I halff noth ' r drinnnk? 酷！但是从顺序上看，我可以用任何的顺序运行这个任务。比如喝醉在买酒或者喝酒之前。当然这不符合人的习惯。 四、Rake的顺序 task :purchaseAlcohol do puts \" Purchased Vodka \" end task :mixDrink => :purchaseAlcohol do puts \" Mixed Fuzzy Navel \" end task :getSmashed => :mixDrink do puts \" Dood, everthing's blurry, can I halff noth'r drinnnk? \" end 这样，如果想喝酒，就得先去买，如果想喝醉，就得先喝酒。 $ rake purchaseAlcohol Purchased Vodka $ rake mixDrink Purchased Vodka Mixed Fuzzy Navel $ rake getSmashed Purchased Vodka Mixed Fuzzy Navel Dood , everthing' s blurry, can I halff noth ' r drinnnk? 看到了吧，我喝醉和，因为酒已经买了，也被我喝了。(译者：我是喜欢百事的，所以倘若我写，定然拿百事当例子。但是我让我儿子和可口，为什么呢？下面告诉 你。) 现在，你的欲望无法满足了，你想让你的朋友加入进来。就像一个团队的开发，如果你想加入一个新人，你得有合适的规划。你得有文档。那么问题来了。 五、如何给我的Rake添加文档 Rake添加文档非常的方便，使用“desc”就可以了： desc \" This task will purchase your Vodka \" task :purchaseAlcohol do puts \" Purchased Vodka \" end desc \" This task will mix a good cocktail \" task :mixDrink => :purchaseAlcohol do puts \" Mixed Fuzzy Navel \" end desc \" This task will drink one too many \" task :getSmashed => :mixDrink do puts \" Dood, everthing's blurry, can I halff noth'r drinnnk? \" end 看到了吧，我的每个任务都添加了desc，这样我们可以输入\"rake -T\"或者\"rake --tasks\": $rake --tasks rake getSmashed # This task will drink one too many rake mixDrink # This task will mix a good cocktail rake purchaseAlcohol # This task will purchase your Vodka 简单乎？呵呵 六、Rake的命名空间 当你开始酗酒，并且开始使用大量的rake任务的时候，你需要一个好方法将他们分类，这时用到了命名空间，如果我在上面的例子使用了命名空间，那么： namespace :alcoholic do desc \" This task will purchase your Vodka \" task :purchaseAlcohol do puts \" Purchased Vodka \" end desc \" This task will mix a good cocktail \" task :mixDrink => :purchaseAlcohol do puts \" Mixed Fuzzy Navel \" end desc \" This task will drink one too many \" task :getSmashed => :mixDrink do puts \" Dood, everthing's blurry, can I halff noth'r drinnnk? \" end end 命名空间允许你将一些任务放到特定的分类中，在一个Rakefile中，你可以加入几个命名空间。运行rake --tasks rake alcoholic:getSmashed # This task will drink one too many rake alcoholic:mixDrink # This task will mix a good cocktail rake alcoholic:purchaseAlcohol # This task will purchase your Vodka 所以如果想运行这个任务，只要输入 rake alcoholic:getSmashed： 七、如何写一个有用的ruby任务 最近，我想用ruby创建几个文件夹： desc \" Create blank directories if they don't already exist \" task(:create_directories ) do # The folders I need to create shared_folders = [\" icons \" ,\" images \" ,\" groups \" ] for folder in shared_folders # Check to see if it exists if File .exists?(folder) puts \" #{ folder} exists \" else puts \" #{ folder} doesn't exist so we're creating \" Dir .mkdir \" #{ folder} \" end end end 当然，还可以在rake中使用更多的 文件工具File Utils ， 或者加入其他的部分。 八、如何为我的rails应用写一个Rake任务 一个rails应用中，已经有了一些rake任务，你可以在你的项目目录里运行：rake --tasks。 为了给你的rails应用添加一个新的任务，你可以打开/lib/tasks目录（已经存在的），添加一个叫 something.rake的文 件，这个任务会被自动的检索到，这些任务会被添加到rake tasks列表中，你可以在根目录里运行他们，现在把我们上面的例子放到这个rails应用中。 utils.rake namespace :utils do desc \" Create blank directories if they don't already exist \" task(:create_directories ) do # The folders I need to create shared_folders = [\" icons \" ,\" images \" ,\" groups \" ] for folder in shared_folders # Check to see if it exists if File .exists?(\" #{ RAILS_ROOT } /public/ #{ folder} \" ) puts \" #{ RAILS_ROOT } /public/ #{ folder} exists \" else puts \" #{ RAILS_ROOT } /public/ #{ folder} doesn't exist so we're creating \" Dir .mkdir \" #{ RAILS_ROOT } /public/ #{ folder} \" end end end end 注意上面的代码，我使用了#{RAILS_ROOT} 来得到rails应用的当前位置，现在运行“rake --tasks”，你可以看到我们的任务已经添加到tasks列表中了。 ... rake tmp:pids :clear # Clears all files in tmp/pids rake tmp:sessions :clear # Clears all files in tmp/sessions rake tmp:sockets :clear # Clears all files in tmp/sockets rake utils:create_directories # Create blank directories if they don't already exist ... 九、如何在任务中调用rails的model 呵呵，这个正是我最多使用rake的地方，写一个rake任务，代替原来需要手工操作的地方，或者一些任务代替经常需要按照计划自动执行（使用 cronjobs ） 的事情。就像我开头说的那样我用rake任务执行下面的擦作： 1、给列表中的用户发送邮件 2、每晚数据的计算和报告 3、过期或重新生成缓存 4、备份数据和svn版本(how's this : subversion repository ) 5、运行数据处理脚本(sort of,how much is called this ) 这个补充了原来的功能，而且相当简单。下面这个任务是检查用户的过期时间，对快过期的用户发送邮件。 utils.rake namespace :utils do desc \" Finds soon to expire subscriptions and emails users \" task(:send_expire_soon_emails => :environment ) do # Find users to email for user in User .members_soon_to_expire puts \" Emailing #{ user.name} \" UserNotifier .deliver_expire_soon_notification(user) end end end 使用你的model只用一步，\"=> :environment\" task(:send_expire_soon_emails => :environment) do 如果在我的开发环境上运行这个任务，我只需要 \"rake utils:send_expire_soon_emails\" ， 如果我想在产品环境下运行这个任务，我需要\"rake RAILS_ENV=production utils:send_expire_soon_emails\" 。 如果你想在每晚都运行这个任务，你需要写一个 cronjob ，像这样： 0 0 * * * cd / var / www/apps/rails_app/ && / usr / local/bin/rake RAILS_ENV =production utils:send_expire_soon_emails 相当的方便。 十、在哪找到一些例子 现在对一个有用的rake任务已经了解很多了，那么我将给你几个资源，我想最好的学习方法是看看别人的代码。 brand new rake tasks 在edge rails 中，这个可以创建和重置你的数据库。 Craig Ambrose写的数据库备份， database backups 。 Adam Greene写了一组任务 set of Rake tasks ，可以将所有的数据备份到amazon S3。他还给了我一个升级版本，你可以在这下载here 。 Jay Fields的任务测试，testing rake tasks 。 a new way of setting the RAILS_ENV and teaches how to use rake to boot you into a Mysql shell （看的时候留意一下他的注释） Rake Bookshelf Books ， 和Martin Fowler的Using the Rake Build Language 教程，这两个都很有用，虽然有点过时。 如果你发现其他更好的文章，发贴子给我们。 译者：恩，这段不用翻译，懂的朋友自然会去看的了。 Still reading? If you are, I wanted to let you know that we're looking for more people to write for RailsEnvy. If you have an idea for a good rails tutorial we want to hear from you! Basically we would work with you to flesh out the tutorial and help polish (acting as an editor). It could definitely be a great way to get your name out there, and start getting some hits (for your blog or company). Email Gregg at RailsEnvy if you're interested. 另：我刚收到jim的邮件，如何更简单的创建我的目录。 # This is needed because the existing version of directory in Rake is slightly broken, but Jim says it'll be fixed in the next version. alias :original_directory :directory def directory (dir) original_directory dir Rake ::Task [dir] end # Do the directory creation namespace :utils do task :create_directories => [ directory(' public/icons ' ), directory(' public/images ' ), directory(' public/groups ' ), ] end 注：图片均来自英文原文(Pics come from the english page) (译者：目前这个内容不是研究的重点，所以会不忙的时候翻译一点点) powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/012-ruby_or_rails_错误解决.html":{"url":"doc/ruby/012-ruby_or_rails_错误解决.html","title":"rubyor_rails错误解决","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 rails fileutils.rb:250:in `mkdir': Permission denied @ dir_s_mkdir 由于之前安装了miq-Citrix,导致manageiq登陆不上提示token无效 Mac下irb中文乱码 rails fileutils.rb:250:in `mkdir': Permission denied @ dir_s_mkdir http://stackoverflow.com/questions/33754137/rails-server-command-returns-error-mkdir-permission-denied-dir-s-mkdir 这个问题就是rails要创建的文件没有权限，如果你了解这个文件路径，那么可以手动修改这个路径的权限,则问题就解决了。 sudo mkdir tmp sudo chmod 777 tmp 由于之前安装了miq-Citrix,导致manageiq登陆不上提示token无效 删除系统中/var 中的 www 文件夹就好了 Mac下irb中文乱码 错误信息： // 在终端使用irb， 然后使用中文字符串会出现下面问题 irb(main):002:0* str = '\\U+FFE4\\U+FFB8\\U+FFAD\\U+FFE5\\U+FFBD' 解决办法： 经查找在Mac下需要readline 编译ruby版本才可以。 // 先安装readline brew install readline Updating Homebrew... Downloading https://homebrew.bintray.com/bottles/readline-7.0.3_1.high_sierr ######################################################################## 100.0% ==> Pouring readline-7.0.3_1.high_sierra.bottle.tar.gz ==> Caveats This formula is keg-only, which means it was not symlinked into /usr/local, because macOS provides the BSD libedit library, which shadows libreadline. In order to prevent conflicts when programs look for libreadline we are defaulting this GNU Readline installation to keg-only.. For compilers to find this software you may need to set: LDFLAGS: -L/usr/local/opt/readline/lib CPPFLAGS: -I/usr/local/opt/readline/include ==> Summary 🍺 /usr/local/Cellar/readline/7.0.3_1: 46 files, 1.5MB // 卸载ruby版本 // 使用上面的路径来安装新的ruby版本 LDFLAGS: -L/usr/local/opt/readline/lib CPPFLAGS: -I/usr/local/opt/readline/include rvm install ruby版本 // 安装好后重新reload一下环境 rvm reload // 使用刚安装的ruby版本 rvm use ruby版本 参考链接： http://my.tv.sohu.com/us/63263814/28072115.shtml powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/013-ruby面试题.html":{"url":"doc/ruby/013-ruby面试题.html","title":"ruby面试题","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 ruby 基础 1、each、map、collect的区别 2、Block, lambda, Proc 的区别 ruby中闭包 3、alias 的用法, alias 与 alias_method 的区别 4、Ruby的对象体系 5、 Include, Extend, Load, Require 的使用区别 6、yield、yield self 7、 Ruby中的元编程 7.1 实例变量、方法、类 7.2 send、eval、respond_to? 8、全局变量，实例变量，局部变量，类变量，Symbol 9、ruby的特点 rails active record 创建、查询、修改、删除 关联模型 查询接口 数据库基本操作 其他面试题 ruby 基础 1、each、map、collect的区别 each: 仅遍历数组，并做相应操作，数组本身不发生改变。 map:遍历数组，并做相应操作后，返回新数组(处理)，原数组不变。 collect: 跟map作用一样。 collect! map!: 多了一个作用，改变原数组。 // 终端打开 irb // each a = [ \"a\", \"b\", \"c\", \"d\" ] b = a.each { |x| x + \"!\" } // a == b == [ \"a\", \"b\", \"c\", \"d\" ] // map map! a = [ \"a\", \"b\", \"c\", \"d\" ] b = a.map { |x| x + \"!\" } a // [\"a\", \"b\", \"c\", \"d\"] b // [\"a!\", \"b!\", \"c!\", \"d!\"] c = a.map! { |x| x + \"!\" } a // [\"a!\", \"b!\", \"c!\", \"d!\"] c // [\"a!\", \"b!\", \"c!\", \"d!\"] // collect collect! a = [ \"a\", \"b\", \"c\", \"d\" ] b = a.collect { |x| x + \"!\" } a // [\"a\", \"b\", \"c\", \"d\"] b // [\"a!\", \"b!\", \"c!\", \"d!\"] c = a.collect! { |x| x + \"!\" } a // [\"a!\", \"b!\", \"c!\", \"d!\"] c // [\"a!\", \"b!\", \"c!\", \"d!\"] 2、Block, lambda, Proc 的区别 proc和lambda都是对象，而block不是 block是proc的实例，proc可以重复使用，函数参数只能有一个block，但可以有多个proc # 说明block是proc的一个实例 def what_am_i(&block) block.class end puts what_am_i {} # = lambda会检查参数个数，proc不会。 lam = lambda { |x| puts x } # creates a lambda that takes 1 argument lam.call(2) # prints out 2 lam.call # ArgumentError: wrong number of arguments lam.call(1,2,3) pro = Proc.new { |x| puts x } # creates a proc that takes 1 argument pro.call(2) # 2 pro.call # returns nil pro.call(1,2,3) # 1 lambda和proc对于return处理方式不同 lambda：一个函数调用lambda，lambda里return后返回函数接着执行。 proc: 一个函数调用proc，proc里return后， 函数也会return。 def lambda_test lam = lambda { return } lam.call puts \"Hello world\" end lambda_test def proc_test proc = Proc.new { return } proc.call puts \"Hello world\" end proc_test 参考资料： What Is the Difference Between a Block, a Proc, and a Lambda in Ruby? 浅谈Ruby中的block, proc, lambda, method object的区别 ruby中闭包 在Ruby里，如果该方法返回一个代码块，而该代码块获得了局部变量的引用，则这些局部变量将在方法返回后依然可以访问。 def show(name) count = 1; return proc do |value| puts count +=1; puts name + '我是闭包' + value end end sh = show(\"ruby\") sh.call('213') sh.call('kkk') 参考： Ruby的4种闭包：blocks, Procs, lambdas 和 Methods 3、alias 的用法, alias 与 alias_method 的区别 alias: 给已经存在的方法或变量设置一个别名，在重新定义已存在的方法时，还可以通过别名来调用原来的方法。 alias_method: 和alias类似，但只能给方法起别名，是Module的一个私有实例方法。 class Demo def hello puts \"old_hell0\" end # 给hello方法取别名 # alias old_hello hello alias_method :old_hello, :hello def hello puts \"new_hello\" end end obj = Demo.new obj.hello obj.old_hello 参考： https://www.cnblogs.com/smallbottle/p/3968704.html https://ruby-china.org/topics/27747 4、Ruby的对象体系 +------------+ | BasicObject| +------------+ ^ |superclass | +----+-----+ superclass-----------+ | Object | ^----------| Module | +----+-----+------+ +-+---------+ ^ | ^ |superclass | |Superclass | | | +---------+ +-+-------+ +---> +-+-------+ | 'hello' | class | String | class | Class | | +---------->+ +--------->+ +------> +---------+ +---------+ +----+----+ | ^ | | class | ![](https://img-blog.csdn.net/20160413232121267?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center) 'hello'.class # String String.class # Class String.superclass # Object Class.class # Class Class.superclass # Module Module.class # Class Module.superclass # Object Object.class # Object Object.superclass # BasicObject BasicObject.class # Class BasicObject.superclass # nil Module是Class的父类，Class和Module的差别是Class是一个增强的Module，它比Module多了一个new，allocate方法，除了这一个区别，当然这个区别特别重要，Class和Module基本是一样的。 参考： https://blog.csdn.net/feigeswjtu/article/details/51040006 5、 Include, Extend, Load, Require 的使用区别 include和extend用于在类中引入模块，区别： include：把模块中的方法作为类的实例方法 extend: 把模块中的方法作为类的类方法 module A def class_type puts \"This class is of type:#{self.class}\" end end class B extend A end class C include A end B.class_type C.new.class_type require、load用于加载库，如.rb文件，区别： require: 加载一个库，并且只加载一次，如果多次加载会返回false。文件不需要扩展名 load: 加载一个库，可多次加载。需要指定文件扩展名。 # 在当前目录中有一个 two.rb文件 require './two'; load './two.rb'; 6、yield、yield self 所有的方法(methods)都会隐式的带一个块(block)参数。 yield用来执行块参数，也可以通过call()方法执行。 yield 相当于是 block.call() 方法的调用，所以参数个数也需要对应, method 定义中 &block 参数必须在最后 def foo1() yield 1,2,3 # 这里的 1 2 3 就是传递的参数 end def foo2(time, &block) yield 1, 2, 3 block.call(5, 6, 7) puts time end foo1 {|x,y,z| puts z} # => 3 foo2('2018') {|x,y,z| puts z} # => 3 7 2018 yield self 在一个对象中，self 表示是一个当前对象的引用。 yield self if block_given? 相当于如果有块参数，那个调用快参数，参数是自己。 def foo(&block) puts self yield self if block_given? yield \"AAAAAAAAA\" end foo {|x| puts x} foo 参考链接：https://www.cnblogs.com/licongyu/p/5522027.html 7、 Ruby中的元编程 Ruby中的元编程，是可以在运行时动态地操作语言结构（如类、模块、实例变量等）的技术。你甚至于可以在不用重启的情况下，在运行时直接键入一段新的Ruby代码，并执行它。 　　Ruby的元编程，也具有“利用代码来编写代码”的作用。例如，常见的attr_accessor等方法就是如此。 7.1 实例变量、方法、类 同一个类的实例可以有不同的实例变量，因为实例变量只有使用的时候才会被建立。 匿名类：对一个具体对象添加方法是，ruby会插入一个新的匿名类来容纳新建的方法，匿名类不可见。 def initialize(*args): 方法可以通过参数不同执行不同的操作 7.2 send、eval、respond_to? send send是Object类的实例方法。第一个参数是方法名，后面是方法的参数 使用send方法，你所想要调用的方法就顺理成章的变成了一个普通的参数。你可以在运行时，直至最后一刻自由决定到底调用哪个方法。 class Rubyist def welcome(*args) \"Welcome \" + args.join(' ') end end obj = Rubyist.new puts(obj.send(:welcome, \"hello\", \"world\")) eval(\"obj.welcome('123')\") eval 用于执行一个用字符串表示的代码,eval方法可以计算多行代码，使得将整个程序代码嵌入到字符串中并执行成为了可能。eval方法很慢，在执行字符串前最好对其预先求值。 str = \"Hello\" puts eval(\"str + ' world'\") # => \"Hello world\" respond_to? 所有的对象都有此方法，使用respond_to?方法，你可以确定对象是否能使用指定的方法。 obj = Object.new if obj.respond_to?(:program) obj.program else puts \"Sorry, the object doesn't understand the 'program' message.\" end 参考资料：http://deathking.github.io/metaprogramming-in-ruby/chapter04.html 参考资料： Ruby中的元编程 8、全局变量，实例变量，局部变量，类变量，Symbol 格式 名称 作用范围 举例 $开头 全局变量 从定义到程序结束 $name @开头 实例变量 self @name @@开头 类变量 内部直接用，外部用类名::变量名 @@name [a-z_]开头 局部变量 定义的类、模块、方法内部，在类、模块、方法间不能共享 name [A-Z] 常量 内部、外部均可，外部访问类名::常量名 NAME :开头 Symbol 内外 :name 参考资料：https://blog.csdn.net/emerald0106/article/details/7358766 9、ruby的特点 解释型执行，方便快捷:Ruby是解释型语言，其程序无需编译即可执行 语法简单、优雅: 完全面向对象: Ruby从一开始就被设计成纯粹的面向对象语言，因此所有东西都是对象，例如整数等基本数据类型。 内置正则式引擎，适合文本处理:Ruby支持功能强大的字符串操作和正则表达式检索功能，可以方便的对字符串进行处理。 自动垃圾收集: 具有垃圾回收（Garbage Collect，GC）功能，能自动回收不再使用的对象。不需要用户对内存进行管理。 跨平台和高度可移植性:Ruby支持多种平台，在Windows， Unix， Linux， MacOS上都可以运行。Ruby程序的可移植性非常好，绝大多数程序可以不加修改的在各种平台上加以运行。 有优雅、完善的异常处理机制: Ruby提供了一整套异常处理机制，可以方便优雅地处理代码处理出错的情况。 缺点： 解释型语言，所以速度较慢 静态检查比较少 rails active record 创建、查询、修改、删除 class Product 上面的代码会创建 Product 模型，对应于数据库中的 products 表。同时，products 表中的字段也映射到 Product 模型实例的属性上。 关联模型 关联原因： 操作两个有关系的表时简化操作。 如果两个表有关联，比如一个作者表，一个图书表，一个作者对应多本书，如果此时删除一个作者前要先把作者对应的书删除，然后在删除作者。但是关联后，只需要在模型中删除作者语句即可，删除书的动作active_record会自动完成。 belongs_to:一对一关系 belongs_to 关联创建两个模型之间一对一的关系，声明所在的模型实例属于另一个模型的实例。 写belongs_to的模型里的一条记录相对于另一个表里有唯一一条记录，叫一对一。 例如有作者和图书两个模型，而且每本书只能指定给一位作者，在图书表中写上： class Book has_one：一对一关系 has_one 关联也建立两个模型之间的一对一关系，但语义和结果有点不一样。这种关联表示模型的实例包含或拥有另一个模型的实例。例如，应用中每个供应商只有一个账户，可以这么定义供应商模型： class Supplier has_one与belongs_to的选择： ​ has_many ：一对多 has_many 关联表示模型的实例有零个或多个另一模型的实例。例如，对应用中的作者和图书模型来说，作者模型可以这样声明： class Author :through: 通过第三张表来关联 has_many :through 这种关联表示一个模型的实例可以借由第三个模型，拥有零个和多个另一模型的实例。例如，在医疗锻炼中，病人要和医生约定练习时间。这中间的关联声明如下： class Physician has_one :through 这种关联表示一个模型通过第三个模型拥有另一模型的实例。例如，每个供应商只有一个账户，而且每个账户都有一个账户历史，那么可以这么定义模型： class Supplier has_and_belongs_to_many 直接建立两个模型之间的多对多关系，不借由第三个模型。例如，应用中有装配体和零件两个模型，每个装配体有多个零件，每个零件又可用于多个装配体，这时可以按照下面的方式定义模型： class Assembly 参考资料： https://ruby-china.github.io/rails-guides/association_basics.html 查询接口 检索对象 find # 检索指定主键对应的对象，没有记录find方法抛出 ActiveRecord::RecordNotFound 异常。 client = Client.find(10) # 查找主键（ID）为 10 的客户 take # 检索一条记录而不考虑排序，没有记录take方法返回 nil，而不抛出异常。 client = Client.take # SELECT * FROM clients LIMIT 1 first # 默认查找按主键排序的第一条记录。如果没有记录，first 方法返回 nil，而不抛出异常 client = Client.first # SELECT * FROM clients ORDER BY clients.id ASC LIMIT 1 last # 默认查找按主键排序的最后一条记录。没有记录last方法返回nil，而不抛出异常。 client = Client.last # SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1 client = Client.last(3) # 返回不超过指定数量的查询结果。 client = Client.order(:first_name).last # 返回按照指定属性排序的最后一条记录。 client = Client.last! # 和 last 方法类似,区别是没有记录会抛出 ActiveRecord::RecordNotFound 异常。 find_by # 查找匹配指定条件的第一条记录。 Client.find_by first_name: 'Lifo' # Client.where(first_name: 'Lifo').take find_each # 批量检索记录，每条记录传入块， User.find_each do |user| NewsMailer.weekly(user).deliver_now end 条件查询 where 方法用于指明限制返回记录所使用的条件，相当于 SQL 语句的 WHERE 部分。条件可以使用字符串、数组或散列指定。 纯字符串条件:容易受到 SQL 注入攻击的风险。 Client.where(\"orders_count = '2'\") # 查找所有 orders_count 字段的值为 2 的客户记录。 数组条件: 后面的参数会替换前面的问号(？) Client.where(\"orders_count = ?\", params[:orders]) Client.where(\"orders_count = ? AND locked = ?\", params[:orders], false) 条件中的占位符 Client.where(\"created_at >= :start_date AND created_at 排序 按 created_at 字段的升序方式取回记录： Client.order(:created_at) 还可以使用 ASC（升序） 或 DESC（降序） 指定排序方式： Client.order(created_at: :desc) Client.order(created_at: :asc) Client.order(orders_count: :asc, created_at: :desc) ​ 数据库基本操作 插入数据 insert into (field1,field2,field3..) values (value1,value2,value3); 查询 select * from ; select select from where =; select form where like '%value%'; // 模糊查询 删除（Delete） delete from where 更新（update) update set = where ; 参考链接：https://blog.csdn.net/yuanmxiang/article/details/51683232 https://www.cnblogs.com/daxueshan/p/6687521.html 其他面试题 https://www.jianshu.com/p/cc9f521d72ee powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/014-RubyMine常用快捷键.html":{"url":"doc/ruby/014-RubyMine常用快捷键.html","title":"RubyMine常用快捷键","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 一级必会 二级进阶 三级耍酷 更改快捷键 [TOC] 一级必会 Mac OS 下快捷键 行注释(Comment with Line Comment): cmd + /块注释(Comment with block Comment): alt + cmd + / Ctrl+Alt+L(alt+cmd+l,)：格式化代码(reformat code)Ctrl+D(cmd +d)：复制一行Ctrl+Y(cmd+delete)：删除一行 end, cmd + →, ctl+e: 光标移到行尾 home, cmd + 左移键, ctl+A: 光标移到行尾 alt + space, cmd+Y:快速查看方法定义源码 替换(replace...): cmd + R Edit -> find -> replace... 移动行到上面(move line up) : alt + shit 方向键上 移动行到下面(move line down) : alt + shit 方向键下 移动语句到上面(move statement up) : cmd + shit 方向键上 移动语句到下面(move statement down) : cmd + shit 方向键下 移动光标到下一个单词(move caret to next word)： alt + 方向右键 移动光标到上一个单词(move caret to previous word)： alt + 方向←键 添加书签(toggle bookmark): F3 添加书签(toggle bookmark with mnemonic): alt/option + F3 显示书签(show bookmark): cmd + F3 跳到上一个书签(previous bookmark): cmd + ↑ 跳到下一个书签(previous bookmark): cmd + ↓ 向下选中： shift + ↓ 向上选中： shift + 上 切换大小写(toggle case): shift + cmd + U 编辑窗口拆分： 左上角 -> Window -> Editor Tabs -> Split Horizontally Shift+F10：运行runningCtrl+Alt+R：弹出RakeCtrl+Alt+G：弹出GenerateCtrl+Alt+L：格式化代码Alt+F1：切换视图(Project, Structure, etc.).Alt+F2：弹出预览窗口，可选择浏览器打开网页Alt+Insert：相当于File|New，不过要在class外执行Alt+Enter：快速修复提示，相当于Eclipse的Alt+F1Alt+Home：显示文件夹导航条Ctrl+J：插入动态模板代码，非常方便。Ctrl+Alt+J：用动态模板包围选中代码Ctrl+/，Ctrl+Shift+/：注释，去注释代码Ctrl+Space：代码自动补全，相当于Eclipse的Alt+/。建议修改为Alt+/Ctrl+Q：显示文档DocCtrl+W：动态选择，多次按依次选择 单词-行-段-全Ctrl+D：复制一行Ctrl+Y：删除一行Shift+Alt+N：在Controller,Model,View间跳转Shift+Alt+F10：运行，Dubug 二级进阶 Alt+Home：显示导航条Alt+F1：在不同视图中切换 (Project, Structure, etc.).Ctrl+Tab：在tool窗口和打开的文件窗口中切换Ctrl+F：在当前文件中查找Ctrl+Shift+F：在文件夹中查找Ctrl+Shift+F7：快速显示选中代码的调用Ctrl+Shift+.：在*.html.erb文件中插入Ctrl+N，Ctrl+Shift+N，Ctrl+Shift+Alt+N：通过名字查找类，文件，符号Ctrl+Shift+T：To surround a block of codeCtrl+Alt+D：显示Model关系图，即ER图。View | Show Model Dependency Diagram 三级耍酷 a.界面调整Esc：从任何界面返回到编辑器Shift+Esc：回到编辑器，隐藏所有工具栏Shift+F6：重命名，文件，方法名，类名，变量名等F12：相当于Shift+Esc的回退键，显示最后一次打开的工具栏 b.变量选择Ctrl+Shfit+F7：高亮显示本文件中变量出现的位置F3，Shift+F3：在不同变量之间跳转Esc：取消选择Alt+Left, Alt+Right: 在不同的Tabs中切换Ctrl+点击Tab：弹出路径框，选择后会在新窗口打开。Ctrl+E：弹出最近打开的文件选择框Ctrl+Shift+Up, Ctrl+Shift+Down：把代码住上移和住下移Ctrl+Shift+Backspace：光标移动到上次修改的位置Ctrl++，Ctrl+-：展开或收缩代码Ctrl+Shift++，Ctrl+Shift+-：全部展开或收缩代码Ctrl+~：切换主题，配色等(一般默认会被输入法占用) 更改快捷键 示例：把代码提示快捷键由Alt+Space改为Ctrl+Alt+/ 打开File>>Setting>>Keymap 找到Main menu>>Code>>Complete Code>>Basic，选择右边的“Add Keyboard Shortcut” 在弹出的框里光标放到输入框，同时按下：Ctrl+Alt+/ 成功后应用保存，即可生效. 转载自：http://blog.csdn.net/iam_song/article/details/7863636 powered by Gitbook文件最后修改时间： 2021-03-12 09:28:22 "},"doc/ruby/015-rubymine习惯设置.html":{"url":"doc/ruby/015-rubymine习惯设置.html","title":"rubymine习惯设置","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. 其他的习惯设置 3. rubymine2016 汉化 4. rubymine 编辑器代码自动缩进设置 5. rubymine 颜色设置 整体风格颜色(主题颜色) 正则表达式颜色 字符串转义 颜色设置 1. 输入行的背景色 2. 代码编辑区背景色 3. 行号字的颜色设置 行号背景色设置 4. 鼠标选择区域前景色(字体颜色) 5. 鼠标选择的背景色 6. 字符串的颜色设置 7. HTML代码 × 8. span企业信息管理dsdsddddd/div 9. 局部变量颜色设置 10. 数字颜色设置 11. 行注释，块注释 颜色修改 12. git 新增行，修改行，删除行 颜色标记修改 13. git diff 弹窗 真实背景色 14. 编辑器 分隔线颜色设置 15. 垂直缩进线颜色设置 *16. 括号匹配颜色 * 17. 鼠标光标颜色 *18. 折叠文本颜色 * 19. 注入语言片段背景色修改 20. 光标定位变量一样的 颜色 21 export class EnterpriseListShowComponent implements OnInit { 22. 实例成员方法名颜色设置： 23. 方法参数颜色设置 Parameter 24.实例变量颜色，接口颜色 25. 搜索结果的颜色背景色设置： 6. 当回车后，按删除键后又回到了上一行，禁止 7. Editor Tabs 编辑器标签页设置，显示正在编辑文件的路径 8.工具栏显示与隐藏 9.关闭rubymine代码自动保存功能 12. 代码折叠设置 14. 编辑器代码自动换行 21. 代码从新格式化格式设置 22. 关闭TypeScript 自动编译 23. 显示/隐藏 编辑器中空格上的白点 24. 显示/隐藏 编辑器 代码块垂直线 25. 显示/隐藏 编辑器 行号 2. 显示/隐藏 编辑器 右边距 编辑器标签的设置，由单行显示变多行(打开的文件名)： 编辑过的文件名标记星号，知道修改了什么文件 [TOC] 1. 其他的习惯设置 RubyMine2016.3自动补全默认第一个选项配置:http://blog.csdn.net/lj_550566181/article/details/53504208 rubymine2016官方文档英文：https://www.jetbrains.com/help/ruby/2016.3/reference.html 3. rubymine2016 汉化 参考链接： http://www.jb51.net/softs/516343.html rubymine2016安装教程下载链接： https://pan.baidu.com/s/1c2ou9w8 密码: kqjhRubyMine 2016汉化包使用方法：解压后，里面有个文件resources_cn.jar,把这个文件复制到/Applications/RubyMine.app/Contents/lib中 如果没有resources_cn.jar,怎按照下面的步骤来制作resources_cn.jar：1、链接: https://pan.baidu.com/s/1pLlWpSn 密码: yptn 下载汉化包2、将/Applications/RubyMine.app/Contents/lib目录下的resources_en.jar文件复制出来，并更名resources_cn.jar3、双击打开resources_cn.jar(注意是打开而不是解压出来)，将下载的汉化包zh_CN目录下的所有文件拖到刚才打开的resources_cn.jar文件内的messages目录中，并保存。4、将resources_cn.jar文件复制回/Applications/RubyMine.app/Contents/lib 4. rubymine 编辑器代码自动缩进设置 preferences(cmd + ,) -> Editor -> Code Style:Indents Dection -> detect and use existing file indents for sditing(检测并使用现有的文件缩进进行编辑) 对号去掉 EditorConfig -> Enable EditorConfig support 对号去掉 根据代码语言进行缩进设置： (TypeScript) Editor -> Code Style -> TypeScript -> Tabs and Indents 5. rubymine 颜色设置 整体风格颜色(主题颜色) preferences(cmd + ,) -> Editor -> Color Scheme -> Scheme： 选择一款喜欢的主题其中 default 主题是窗口是白色的，其他的有黑色的 正则表达式颜色 preferences(cmd + ,) -> Editor -> Color Scheme -> TypeScript -> Regular expression -> foreground 字符串转义 颜色设置 preferences(cmd + ,) -> Editor -> Color Scheme -> TypeScript -> valid string escape -> foreground 1. 输入行的背景色 preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Editor -> Caret row 2. 代码编辑区背景色 preferences(cmd + ,) -> Editor -> Colors Scheme -> General -> Text -> Default test -> background 3. 行号字的颜色设置 preferences(cmd + ,) -> Editor -> Colors Scheme -> General -> Code -> Line number 行号背景色设置 preferences(cmd + ,) -> Editor -> Colors Scheme -> General -> Editor -> Gutter background 4. 鼠标选择区域前景色(字体颜色) preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Editor -> Selection background 5. 鼠标选择的背景色 preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Editor -> Selection foreground 6. 字符串的颜色设置 preferences(cmd + ,) -> Editor -> Colors & Fonts -> Language Defaults -> String -> String text -> Foreground这是通用的设置，如果想某种语言字符串颜色特定 以ruby语言为例：preferences(cmd + ,) -> Editor -> Colors & Fonts -> Ruby -> String -> Foreground如果勾选了 Use inherited attributes则会使用上面的设置，在这里也告诉了此处默认的设置位置String -> String text of Language Defaults 7. HTML代码 &times; class= 颜色背景色设置 preferences(cmd + ,) -> Editor -> Colors & Fonts -> Language Defaults -> Markup -> Attribute ->Foreground 字体颜色， Background 背景色 &times; 颜色背景色设置preferences(cmd + ,) -> Editor -> Colors & Fonts -> Language Defaults -> Markup -> Entity ->Foreground 字体颜色， Background 背景色 颜色背景色设置preferences(cmd + ,) -> Editor -> Colors & Fonts -> Language Defaults -> Markup -> Tag ->Foreground 颜色， Background 背景色 8. 企业信息管理dsdsddddd div span 字体的颜色设置preferences(cmd + ,) -> Editor -> Colors & Fonts -> Language Defaults -> Keyword -> Foreground 没有被任何符号包含(企业信息管理ds)的字体颜色 设置preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Text -> Default text -> Foreground 9. 局部变量颜色设置 preferences(cmd + ,) -> Editor -> Colors & Fonts -> Language Defaults -> Identifiers -> Local variable -> Foreground其他语言个性化设置(JavaScript)： Editor -> Colors & Fonts -> JavaScript -> Local variable -> Foreground 10. 数字颜色设置 preferences(cmd + ,) -> Editor -> Colors & Fonts -> Language Defaults -> Number -> Foreground 11. 行注释，块注释 颜色修改 preferences(cmd + ,) -> Editor -> Colors & Fonts -> Language Defaults -> Comments -> Line comment -> Foreground 12. git 新增行，修改行，删除行 颜色标记修改 2016版的： git 新增行标记颜色修改：preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Gutter -> Added lines -> Background git 删除行标记颜色修改：preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Gutter -> Deleted lines -> Background git 修改行标记颜色修改：preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Gutter -> modified lines -> Background 2017版的： git 新增行标记颜色修改：preferences(cmd + ,) -> Editor -> Colors Scheme -> VCS -> Editor Gutter -> Added lines -> Background git 删除行标记颜色修改：preferences(cmd + ,) -> Editor -> Colors Scheme -> VCS -> Editor Gutter -> Deleted lines -> Background git 修改行标记颜色修改：preferences(cmd + ,) -> Editor -> Colors Scheme -> VCS -> Editor Gutter -> modified lines -> Background 13. git diff 弹窗 真实背景色 preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Text -> Background in readonly file - Background 14. 编辑器 分隔线颜色设置 分隔线颜色设置：preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Editor -> Tear line -> Foreground 选择分隔线颜色设置：preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Editor -> Tear line selection -> Foreground 右边线颜色设置：preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Editor -> Right margin 15. 垂直缩进线颜色设置 preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Code -> Vertical indent guide -> Background 16. 括号匹配颜色 preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Code -> Matched brace -> Background 17. 鼠标光标颜色 preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Editor -> Caret 18. 折叠文本颜色 折叠文本三个点颜色： preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Text -> Fold text -> Foreground 折叠文本背景色：preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Text -> Fold text -> Background 19. 注入语言片段背景色修改 preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Code -> Injected language fragment -> Background 20. 光标定位变量一样的 颜色 光标在变量定义处：preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Code -> Identifier under caret(write) -> Background 变量一样其他变量的背景色：preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Code -> Identifier under caret -> Background 21 export class EnterpriseListShowComponent implements OnInit { export class keyword 关键字颜色设置 (JavaScript) Editor -> Colors & Fonts -> JavaScript -> Keyword -> Foreground如果勾选了： Use inherited attributes ,则： Language Defaults -> Keyword 类名字颜色设置(JavaScript) Editor -> Colors & Fonts -> JavaScript -> Class -> Foreground如果勾选了： Use inherited attributes : Language Defaults -> Classes -> Class name 22. 实例成员方法名颜色设置： (JavaScript) Editor -> Colors & Fonts -> JavaScript -> Instance member function -> Foreground如果勾选了： Use inherited attributes,则： Language Defaults -> Classes -> Instance method 23. 方法参数颜色设置 Parameter 方法参数颜色设置：(JavaScript) Editor -> Colors & Fonts -> JavaScript -> Parameter:Foreground, 字体颜色Background, 背景色如果勾选了： Use inherited attributes，则: Language Defaults -> Indentifiers -> Parameter 24.实例变量颜色，接口颜色 类实例变量颜色设置：(TypeScript)Editor -> Colors & Fonts -> TypeScript -> Instance member variable -> Foreground如果勾选了： Use inherited attributes，则: JavaScript -> Instance member variable(通用) Editor -> Colors & Fonts -> Language Defaults -> Classes ->Instance field -> Foreground 接口颜色设置：(TypeScript)Editor -> Colors & Fonts -> TypeScript -> Interface -> Foreground如果勾选了： Use inherited attributes，则: Language Defaults -> Classes -> Interface name 25. 搜索结果的颜色背景色设置： preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Search Results -> Text search result搜索结果字体颜色： Foreground ，搜索结果背景色： Background 6. 当回车后，按删除键后又回到了上一行，禁止 Smart Keys，这个选择一下：preferences(cmd + ,) -> Editor -> General -> Smart Keys -> Backspace -> Unident: To nearest indent positionCode Style,这里设置一下：Editor -> Code Style:EditorConfig -> Enable EditorConfig support把这里的对号去掉根据编程语言进行相应设置：Editor -> Code Style -> TypeScript -> Tabs and Indents 7. Editor Tabs 编辑器标签页设置，显示正在编辑文件的路径 https://www.jetbrains.com/help/ruby/2016.3/editor-tabs.html?search=editor%20tabs 显示编辑文件的路径：rubymine左上角 -> View -> navigation Bar , 前面打上对号。 8.工具栏显示与隐藏 rubymine左上角 -> View -> Toolbar , 前面打上对号。 9.关闭rubymine代码自动保存功能 https://www.jetbrains.com/help/ruby/2016.3/saving-and-reverting-changes.html在编辑TypeScript代码的时候，由于自动保存导致每写一点代码，服务都会从新编译运行，因此需要关闭自动保存：preferences(cmd + ,) -> Appearance & Behavior -> System Settings -> Synchrogazation(同步):save file on frame deactivation(鼠标光标停止的时候保存文件，好像这么理解), 把这个前面的对号去掉，就可以在编辑时不会自动保存了。Synchronize file on frame or editor tab activation, 这个是否去掉暂时不知道， 12. 代码折叠设置 https://www.jetbrains.com/help/ruby/2016.1/code-folding.html#using_folding_comments preferences(cmd + ,) -> Editor -> General -> Code Folding： -> Show code folding outline: 这个打上对号，就会显示代码折叠的提示线。-> Collapse by default: 这下面是默认折叠的代码块的选项，哪个不想默认折叠把前面的对号去掉就可以了。 14. 编辑器代码自动换行 当代码一行太多的时候，如果不选择软换行，那么就会把编辑区右移，会很费劲，这时可选择软换行，在下一行接着显示这行的内容。 preferences(cmd + ,) -> Editor -> General：Soft Wraps -> Use soft wraps in editor , 前面打上对号，就会自动软换行。 21. 代码从新格式化格式设置 冒号后有一个空格，从新格式化设置：preferences(cmd + ,) -> Editor -> Code Style -> TypeScript -> Spaces -> After type reference colon':'打上对号 22. 关闭TypeScript 自动编译 preferences(cmd + ,) -> Languages & Frameworks -> TypeScript:Compiler: Enable TypeScript Compiler 去掉前面的对号，就不会自动编译了。 23. 显示/隐藏 编辑器中空格上的白点 preferences(cmd + ,) -> Editor -> General -> Appearance -> show whitespaces ,点击选中或取消。 24. 显示/隐藏 编辑器 代码块垂直线 preferences(cmd + ,) -> Editor -> General -> Appearance -> Vertical indent guide ,点击选中或取消。 25. 显示/隐藏 编辑器 行号 preferences(cmd + ,) -> Editor -> General -> Appearance -> show line numbers 2. 显示/隐藏 编辑器 右边距 preferences(cmd + ,) -> Editor -> General -> Appearance -> show right margin 编辑器标签的设置，由单行显示变多行(打开的文件名)： preferences(cmd + ,) -> Editor -> General -> Editor Tabs:Tab Appearance -> Show tabs in single row(在单行显示标签), 对号去掉。Tab Closing Policy(选项卡关闭策略) -> Tab limit(选项卡限制) , 里面的数字改大一点 编辑过的文件名标记星号，知道修改了什么文件 preferences(cmd + ,) -> Editor -> General -> Editor Tabs:Tab Appearance -> Mark modified tabs with asterisk (标记修改过的标签为星号)，打上对号。 powered by Gitbook文件最后修改时间： 2021-03-12 09:49:27 "},"doc/ruby/016-haml语法符号的含义.html":{"url":"doc/ruby/016-haml语法符号的含义.html","title":"haml语法符号的含义","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 haml官网 Haml 参考大全 简明教程 入门 haml中一些符号的作用 %百分号符号是一行的开始，紧接着一个元素的名字，然后后面跟一个可选的修饰语（见下例），比如一个空格，或一行文本等，就会被渲染到这个元素里成为其内容。它会创建一个这样的形式：. {}括号内的Ruby hash是用来指名一个元素的属性。它作为一个ruby hash的字面量，局部变量也可以在其中使用。Hash放在被定义好的标签之后，基本上就和Ruby语法一样，看例子： []方括号跟在一个标签定义之后，包含一个Ruby 对象，被用来为这个标签设置class和id属性。这个class的值被设置为这个对象的类名（两个单词用下划线形式表示，而不是驼峰表示方法）并且id的值被设置为对象的类名加上这个对象的id，也是下划线连接。因为一个对象的id通常是朦胧的实现细节，这是表现model的实例最有用的元素了（这句是不是翻译的太差？）。 /这个斜线字符，放在一个tag定义之后，可以让这个标签自我关闭。 . and #这两个符号是从CSS里借鉴来的。他们被用来表示一个元素的class和id属性 Implicit Div Elements（隐藏DIV）因为Div这个标签经常被用，所以你仅用.and#这两个符号来定义class和id的时候，一个div元素就会被自动的使用。 =等号符号用来插入ruby 代码的值到模板中。 !!!当用haml来表示一个XHTML文档，你可以通过!!!这个符号来自动生成文档类型和XML prolog。 /如果这个斜线写在打头的位置，则会注释这行。放在代码的上方，则注释整个代码： \\反斜杠符号允许字符串前面的第一个符号作为纯文本使用。 |管道符可以允许把输出为一行的内容写成多行。 :冒号是指定一个过滤器。冒号后面是你要使用的那个过滤器的名字。 横杠符号，很有性格，可以使文本变为”silent script”：意思是，代码可以执行，但并不输出任何东西。 BlocksRuby中的块，也不需要明显的去关闭，haml会让它自动关闭。这写都是基于缩进的。千万记住要缩进两个空格。 %百分号符号是一行的开始，紧接着一个元素的名字，然后后面跟一个可选的修饰语（见下例），比如一个空格，或一行文本等，就会被渲染到这个元素里成为其内容。它会创建一个这样的形式：. 式：.。举个例子： %one %two %three Hey there 会被编译为： Hey there 对于任何一个有效的标准元素字符，Haml都会自动的为其生成闭合标签。 {}括号内的Ruby hash是用来指名一个元素的属性。它作为一个ruby hash的字面量，局部变量也可以在其中使用。Hash放在被定义好的标签之后，基本上就和Ruby语法一样，看例子： %head{ :name => \"doc_head\" } %script{ 'type' => \"text/\" + \"javascript\", :src => \"javascripts/script_#{2 + 7}\" } 编译后为： []方括号跟在一个标签定义之后，包含一个Ruby 对象，被用来为这个标签设置class和id属性。这个class的值被设置为这个对象的类名（两个单词用下划线形式表示，而不是驼峰表示方法）并且id的值被设置为对象的类名加上这个对象的id，也是下划线连接。因为一个对象的id通常是朦胧的实现细节，这是表现model的实例最有用的元素了（这句是不是翻译的太差？）。看例子： # file: app/controllers/users_controller.rb def show @user = CrazyUser.find(15) end # file: app/views/users/show.haml %div[@user] %bar[290]/ Hello! 转换为： Hello! 这是基于RailsConf Europe 2006 大会上DHH提出的SimpleHelpful语法 /这个斜线字符，放在一个tag定义之后，可以让这个标签自我关闭。例子： %br/ %meta{'http-equiv' => 'Content-Type', :content => 'text/html'}/ 转换为： 有一些标签（meta, img, link, script, br, and hr tags等）当没有内容的时候会自动关闭。看例子： %br %meta{'http-equiv' => 'Content-Type', :content => 'text/html'} 转换为： . and #这两个符号是从CSS里借鉴来的。他们被用来表示一个元素的class和id属性,看例子： %div#things %span#rice Chicken Fried %p.beans{ :food => 'true' } The magical fruit %h1.class.otherclass#id La La La 转换为： Chicken Fried The magical fruit La La La 注意h1标签。两个点连用，第一个表示class属性，第二个则是用来链接那两个字符的空格。 Implicit Div Elements（隐藏DIV）因为Div这个标签经常被用，所以你仅用.and#这两个符号来定义class和id的时候，一个div元素就会被自动的使用。例如： #collection .item .description What a cool item! 和下面的这个相似： %div{:id => collection} %div{:class => 'item'} %div{:class => 'description'} What a cool item! 都会被转换为： What a cool item! =等号符号用来插入ruby 代码的值到模板中。 %p = ['hi', 'there', 'reader!'].join \" \" = \"yo\" 编译为: hi there reader! yo 你也能使用双等号来更容易的嵌入ruby代码。比如： %p == 1 + 1 = #{1 + 1} 编译为： 1 + 1 = 2 !!!当用haml来表示一个XHTML文档，你可以通过!!!这个符号来自动生成文档类型和XML prolog。比如：``` !!! XML !!! %html %head %title Myspace %body %h1 I am the international space station %p Sign my guestbook 转换为： \">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"> Myspace I am the international space station Sign my guestbook 你也可以在！！！后面加版本号。比如： !!! 1.1 转换为： \">http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\"> and !!! Strict \">http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"> 如果你不想用UTF-8的编码，你也可以指定你想要的编码： !!! XML iso-8859-1 转换为： * **/** 如果这个斜线写在打头的位置，则会注释这行。 放在代码的上方，则注释整个代码： %billabong / This is the billabong element I like billabongs! 转换为： I like billabongs! / %p This doesn't render... %div %h1 Because it's commented out! 转换为： This doesn't render... Because it's commented out! --> * **\\** 反斜杠符号允许字符串前面的第一个符号作为纯文本使用。 %title = @title - MySite 转换为： MyPage - MySite * **|** 管道符可以允许把输出为一行的内容写成多行。 %whoo %hoo I think this might get | pretty long so I should | probably make it | multiline so it doesn't | look awful. | %p This is short. is compiled to: 转换为： I think this might get pretty long so I should probably make it multiline so it doesn't look awful. * **:** 冒号是指定一个过滤器。冒号后面是你要使用的那个过滤器的名字。For example, %p :markdown Textile ======= Hello, *World* 转换为： Textile Hello, World Haml支持的过滤器定义 plain ruby preserve erb sass redcloth textile markdown * **-** 横杠符号，很有性格，可以使文本变为”silent script”：意思是，代码可以执行，但并不输出任何东西。 * **Blocks** Ruby中的块，也不需要明显的去关闭，haml会让它自动关闭。这写都是基于缩进的。千万记住要缩进两个空格。 (42...47).each do |i| %p= i %p See, I can count! 编译为: 42 43 44 45 46 ``` 上面的语法出自： http://blackanger.blog.51cto.com/140924/47642/ haml官网 http://haml.info/ Haml 参考大全 http://blackanger.blog.51cto.com/140924/47642/ 简明教程 http://www.codeweblog.com/%E7%BF%BB%E8%AF%91-haml%E5%AE%98%E7%BD%91%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/ 入门 http://www.2cto.com/kf/201601/485095.html powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/manageiq/001-manageIQ开发环境安装centos.html":{"url":"doc/manageiq/001-manageIQ开发环境安装centos.html","title":"manageIQ开发环境安装centos","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. manqgeiq官方的安装文档 2. manageiq自定义安装 2.1 操作系统安装 2.2 git安装 2.3 manageiq依赖安装 2.4 clone ManageIQ 代码 2.5 Installs dependencies, config, prepares database, etc 2.6 Starts the ManageIQ EVM Application in the background 2.7 开发环境最小配置运行 [TOC] 以下所有操作都不能在root用户操作，要用你登陆电脑的用户来操作 https://bitbucket.org/yulilong/my_wiki/wiki/Home 1. manqgeiq官方的安装文档 链接：http://manageiq.org/docs/guides/developer_setup.html你可以看这个官方的安装文档，这里面依赖环境安装是使用dnf管理其来安装的，我个人安装的时候会有点问题，你可以先尝试安装，如果有问题不能解决，那么可以看下面的安装教程。如果按照官方文档安装了，则下面的可以忽略了。 2. manageiq自定义安装 这个是文档是从一个空白电脑开始安装，如果你哪一步已经存在，请略过 2.1 操作系统安装 manageiq要求是 centos的 linux，所以请安装centos版linux，不会请找运维的同事或者网管安装。 推荐centos7 2.2 git安装 一般git linux系统自带，可在终端运行如下命令查看系统是否安装了git： $ git --version 如果出来版本号则说明已经安装了，如果没有安装请看如下教程安装： git安装,配置 这里面描写了git的安装、git命令的别名、以及拉取代码时自动验证用户名密码设置。 2.3 manageiq依赖安装 官方文档使用的是dnf包管理器来安装的，但是我安装时发现有的包使用dnf找不到，只好全部用yum来安装了。 Install packagessudo yum -y install memcached sudo yum -y install bzip2 libffi-devel readline-devel sudo yum -y install libxml2-devel libxslt-devel patch sudo yum -y install sqlite-devel sudo yum -y install nodejs sudo yum -y install gcc-c++ sudo yum -y install libcurl-devel rpm -q --whatprovides npm || sudo yum -y install npm sudo yum -y install openssl-devel sudo yum -y install cmake Install the Bower package managersudo npm install -g bower Enable Memcachedsudo systemctl enable memcached sudo systemctl start memcached PostgreSQL version is 9.4+ 的安装 postgres数据库官方推荐使用9.4+的版本，如果系统没有安装那么直接安装这个版本以上的，如果有旧的版本则先卸载在安装新的。 manageiq官方postgres9.4+的安装文档：http://manageiq.org/docs/guides/developer_setup/postgresql_software_collection # 您需要做的第一件事是启用SoftwareCollections.org包存储库。如果你使用CentOS，那么命令如下： $ sudo yum -y install centos-release-scl # 查看postgres是否已经安装了了低版本的，如果已经安装了高版本的，或者没安装在不需卸载，直接安装 $ psql --version $ sudo systemctl stop postgresql-server # 停止psotgres服务 $ sudo systemctl disable postgresql-server # 关掉postgres $ sudo yum -y remove 'postgresql-*' # 卸载postgres 卸载ruby 链接postgres 的gem包 pg，如果没有安装则略过： $ gem uninstall pg Install the PostgreSQL 9.4 collection $ sudo yum -y install \\ rh-postgresql94-postgresql-server \\ rh-postgresql94-postgresql-devel This will install the required files under /opt/rh/rh-postgresql94, so each time you need to use a command like pgsql you will have to use the complete path. Alternatively, you can enable that collection: $ scl enable rh-postgresql94 bash $ source /opt/rh/rh-postgresql94/enable 注意！！！下面这步会把～/.bash_profile 文件里面所有内容清空，使用前请备份注意： # 这条命令可以不用执行，后期经实测不影响manageIQ的使用 $ cat > $HOME/.bash_profile 在$HOME/.bash_profile文件加了这句话后，如果你重新登陆，会导致当前用户图形界面登陆不上。 两种解决方法： 1. 把这句注销调，后期经实测，没有这条语句对于rails开发没有影响，数据库能打开就好。 2. 打开/opt/rh/rh-postgresql94/enable，把如下三条语句注释掉： export XDG_CONFIG_DIRS=\"/etc/opt/rh/rh-postgresql94/xdg:${XDG_CONFIG_DIRS:-/etc/xdg}\" export XDG_DATA_DIRS=\"/opt/rh/rh-postgresql94/root/usr/share${XDG_DATA_DIRS:+:${XDG_DATA_DIRS}}\" export PKG_CONFIG_PATH=\"/opt/rh/rh-postgresql94/root/usr/lib64/pkgconfig${PKG_CONFIG_PATH:+:${PKG_CONFIG_PATH}}\" Create and configure the database By default the database directory used by the software collection is /var/opt/rh/rh-postgresql94/lib/pgsql/data, but the ManageIQ instructions assume it to be /var/lib/pgsql/data. The name of the service is also different. Make sure to take these differences into account when creating and configure the database. For example, to initially create the database you will need to do the following: $ su - root $ scl enable rh-postgresql94 bash $ postgresql-setup initdb To setup authentication you will need to modify the pg_hba.conf file, as described in the instructions, but taking into account the different location: $ PGDATA=/var/opt/rh/rh-postgresql94/lib/pgsql/data $ sudo grep -q '^local\\s' $PGDATA/pg_hba.conf || echo \"local all all trust\" | sudo tee -a $PGDATA/pg_hba.conf $ sudo sed -i.bak 's/\\(^local\\s*\\w*\\s*\\w*\\s*\\)\\(peer$\\)/\\1trust/' $PGDATA/pg_hba.conf To enable and start the server: $ sudo systemctl enable rh-postgresql94-postgresql $ sudo systemctl start rh-postgresql94-postgresql 修改数据库配置文件，允许连接 $ sudo vi /var/opt/rh/rh-postgresql94/lib/pgsql/data/pg_hba.conf 找到下面的内容：# IPv4 local connections: host all all 127.0.0.1/32 ident # IPv6 local connections: host all all ::1/128 ident 把ident修改为 trust 并在下面添加一行： host all all 192.168.0.0/24 trust 保存后重起数据库： $ sudo systemctl restart rh-postgresql94-postgresql 查看数据库的运行：$ lsof -i:5432 And, finally, to create the database user: $ su - postgres -bash-4.2$ scl enable rh-postgresql94 bash bash-4.2$ psql -c \"CREATE ROLE root SUPERUSER LOGIN PASSWORD 'smartvm'\" rvm,ruby,gems,rails,pqadmin3,rubymine,isntall 这里是rails开发的必要插件，具体安装看如下链接： centos7,rvm,ruby,gems,rails,pqadmin3,rubymine,isntall 2.4 clone ManageIQ 代码 git clone https://github.com/ManageIQ/manageiq 2.5 Installs dependencies, config, prepares database, etc $ bin/setup 2.6 Starts the ManageIQ EVM Application in the background 下面的命令是开始启动服务，这个是正常的启动。 # 启动manageIQ服务，网站 $ rails server # 这个是后台处理程序，读取虚拟机信息，读取镜像信息等，如果只是网站则不需要运行这个 $ bundle exec rake evm:start 2.7 开发环境最小配置运行 $ MIQ_SPARTAN=minimal rake evm:start $ rails server powered by Gitbook文件最后修改时间： 2021-03-12 08:56:01 "},"doc/manageiq/002-manageIQ开发环境安装Mac.html":{"url":"doc/manageiq/002-manageIQ开发环境安装Mac.html","title":"manageIQ开发环境安装Mac","keywords":"","body":" manageIQ官方安装文档http://manageiq.org/docs/guides/developer_setupMac 安装在中间 Install Homebrew下面的安装都要brew，如果没有brew需要第一个安装 # https://brew.sh/ $ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" Install Packages brew install git brew install memcached brew install postgresql brew install cmake brew install node Install the Bower package manager npm install -g bower Configure and start PostgreSQL Required PostgreSQL version is 9.4+ # Enable PostgreSQL on boot mkdir -p ~/Library/LaunchAgents ln -sfv /usr/local/opt/postgresql/*.plist ~/Library/LaunchAgents launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.postgresql.plist # Create the ManageIQ superuser psql -d postgres -c \"CREATE ROLE root SUPERUSER LOGIN PASSWORD 'smartvm'\" Start memcached # Enable Memcached on boot ln -sfv /usr/local/opt/memcached/homebrew.mxcl.memcached.plist ~/Library/LaunchAgents launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.memcached.plist Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。 它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高动态、数据库驱动网站的速度。 Memcached基于一个存储键/值对的hashmap。其守护进程（daemon ）是用C写的， 但是客户端可以用任何语言来编写，并通过memcached协议与守护进程通信。 powered by Gitbook文件最后修改时间： 2021-03-11 15:33:28 "},"doc/manageiq/003-manageIQ代码结构、框架、执行流程分析.html":{"url":"doc/manageiq/003-manageIQ代码结构、框架、执行流程分析.html","title":"manageIQ代码结构、框架、执行流程分析","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. 概述 2. manageiq代码的目录结构 3. rais 程序架构、执行流程 4. manageiq代码执行过程展示 5. manageiq登陆过程分析 7. providers 部分代码启动流程 8. rails是如何加载的 [TOC] 1. 概述 由于manageiq是使用rails编写的，所以manageiq的源代码目录结构是标准的rails的目录结构，rails开发语言是ruby，框架是mvc模式的。 2. manageiq代码的目录结构 1、首先了解一下标准的rails目录结构，如下图： 2、ManageIQ的代码目录结构:ManageIQ is a Rails application with the following standard layout: 详细介绍请看manageiq的官方文档介绍：http://manageiq.org/docs/guides/architecture/source_code_layout 3. rais 程序架构、执行流程 Rails 采用了“模型-视图-控制器”（简称 MVC）架构模式。这种模式把应用中的数据（例如用户信息）与显示数据的代码分开，这是图形用户界面（Graphical User Interface，简称 GUI）常用的架构方式。 MVC 架构图解： 与 Rails 应用交互时，浏览器发出一个请求（request），Web 服务器收到请求之后将其传给 Rails 应用的控制器，决定下一步做什么。某些情况下，控制器会立即渲染视图（view），生成 HTML，然后发送给浏览器。在动态网站中，更常见的是控制器与模型（model）交互。模型是一个 Ruby 对象，表示网站中的一个元素（例如一个用户），并且负责与数据库通信。与模型交互后，控制器再渲染视图，把生成的 HTML 返回给浏览器。 程序执行流程： 图中各步的说明如下： 浏览器向 /users 发送请求； Rails 的路由把 /users 交给 Users 控制器的 index 动作处理； index 动作要求 User 模型读取所有用户（User.all）； User 模型从数据库中读取所有用户； User 模型把所有用户组成的列表返回给控制器； 控制器把所有用户赋值给 @users 变量，然后传入 index 视图； 视图使用嵌入式 Ruby 把页面渲染成 HTML； 控制器把 HTML 送回浏览器。 关于rails的资料请看如下链接：Ruby on Rails 教程Ruby on Rails 指南 4. manageiq代码执行过程展示 看过上面的介绍后，如果想要了解manageiq的代码可根据如下方法来查找： 浏览器发送一个链接请求， 去config/routes.rb里面， 根据链接来确定这个请求由哪个controller的action来处理， 这里找到了controller。 cotroller调用model来处理请求，然后调用view来对结果进行渲染， 这里找到了model与view。 浏览器接收结果，对结果进行展示， 一次请求结束。 、 根据上面的执行流程，如果想知道manageiq某一个网页的代码，以及修改某一部分，就可以按照上面的过程来查找。 5. manageiq登陆过程分析 启动服务 在此之前需要先安装好环境，并下载代码，进入代码目录并执行下面命令： rails server 浏览器输入地址：http://localhost:3000 此时浏览器已经向rails服务发送了请求，请求的是默认地址。 去路由中需要默认地址负责处理的controller 路由文件位置：https://github.com/ManageIQ/manageiq/blob/darga-4/config/routes.rb 在里面找到默认路由设置代码https://github.com/ManageIQ/manageiq/blob/darga-4/config/routes.rb#L2623 root :to => 'dashboard#login' 从这段代码可以看到处理默认访问的controller是 dashboard里面的login方法，去 controller里面找到dashboard控制器。 controllers/dashboard_controller.rb对请求进行处理 controller文件位置：https://github.com/ManageIQ/manageiq/blob/darga-4/app/controllers/dashboard_controller.rb在里面找到login方法：https://github.com/ManageIQ/manageiq/blob/darga-4/app/controllers/dashboard_controller.rb#L347这个方法执行完毕后，如果在方法里面没有指定执行的view，那么则默认去view里面找到同名的文件夹，在里面找到跟这个方法名同名的文件。 views/dashboard/login.html.haml对网页进行渲染 view文件位置：https://github.com/ManageIQ/manageiq/blob/darga-4/app/views/dashboard/login.html.haml在里面找到登陆按钮的位置：https://github.com/ManageIQ/manageiq/blob/darga-4/app/views/dashboard/login.html.haml#L91 如下图所示： 当在浏览器中输入用户名、密码后点击 login 按钮后，如上图 1、2、3 过程所示，会从新回到 controller里面去验证用户名密码。 controllers/dashboard_controller.rb 的authenticate方法对密码进行验证 代码位置：https://github.com/ManageIQ/manageiq/blob/darga-4/app/controllers/dashboard_controller.rb#L433 如果验证成功，则会指向一个新的url地址，代码如下：page.redirect_to(validation.url) 登陆过程结束，此时进入到了网站页面。 7. providers 部分代码启动流程 服务启动后，选择 Compute -> Clouds -> Providers, 此时网页链接： http://localhost:3000/ems_cloud/show_list ，然后在齿轮图标那里选择 Add a New Cloud Provider，这里就是添加aliyun代码的部分了，此时网页链接：http://localhost:3000/ems_cloud/new 根据链接http://localhost:3000/ems_cloud/new去路由中寻找处理此请求的controllers 路由位置：https://github.com/ManageIQ/manageiq/blob/darga-4/config/routes.rb#L906 ，在里面没有找到new，但是控制代码里面有new方法。 controllers/ems_cloud_controller.rb对请求进行处理 controller文件位置：https://github.com/ManageIQ/manageiq/blob/darga-4/app/controllers/ems_cloud_controller.rb在这个文件里面没有new方法，但是在include 里面找到了new：https://github.com/ManageIQ/manageiq/blob/darga-4/app/controllers/ems_common.rb#L131在这个方法里面设置了有哪些providers，并把结果传给view。 views/ems_cloud/new.html.haml对网页进行渲染 view文件位置：https://github.com/ManageIQ/manageiq/blob/darga-4/app/views/ems_cloud/new.html.haml这里面在基本渲染后，又调用的局部渲染： = render :partial => \"shared/views/ems_common/angular/form\" 文件位置：https://github.com/ManageIQ/manageiq/blob/darga-4/app/views/shared/views/ems_common/angular/_form.html.haml这里面是选择providers的位置：https://github.com/ManageIQ/manageiq/blob/darga-4/app/views/shared/views/ems_common/angular/_form.html.haml#L27 view处理结束后把结果返回给网页，这次请求将结束。 8. rails是如何加载的 http://blog.csdn.net/cloudcraft/article/details/7654118https://ruby-china.org/topics/23588http://www.oschina.net/question/136896_166772?sort=time powered by Gitbook文件最后修改时间： 2021-03-11 23:08:23 "},"doc/manageiq/004-manageIQ汉化.html":{"url":"doc/manageiq/004-manageIQ汉化.html","title":"manageIQ汉化","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 dashboard 页面标题的汉化 代码版本https://github.com/ManageIQ/manageiq/tree/euwe-1 I18自动转化成网页当前语言的包rails I18n 资料： http://guides.ruby-china.org/i18n.htmlhttps://github.com/svenfuchs/rails-i18nhttps://rubygems.org/gems/rails-i18nGemfile 里面：gem \"rails-i18n\", \"~>5.x\".rb文件里引用：require 'rails_i18n' 汉化的文件 manageiq/locale/zh_CN/manageiq.pomanageiq/app/assets/javascripts/locale/zh_CN/app.js dashboard 页面标题的汉化 网址： http://localhost:3000/dashboard/show controller处理信息https://github.com/ManageIQ/manageiq/blob/euwe-1/app/controllers/dashboard_controller.rb#L88这里面对数据进行处理后，view调用默认的show页面对数据进行渲染。 app/views/dashboard/show.html.haml 网页渲染。 # https://github.com/ManageIQ/manageiq/blob/euwe-1/app/views/dashboard/show.html.haml#L8 # 这一行显示数据接着处理，此时跳到另个文件里继续执行程序 = WidgetPresenter.new(self, controller, widget).render_partial app/presenters/widget_presenter.rb 对 render_partial 方法进行处理https://github.com/ManageIQ/manageiq/blob/euwe-1/app/presenters/widget_presenter.rb#L19 def render_partial @controller.render_to_string(:template => 'dashboard/_widget', :handler => [:haml], :layout => false, :locals => {:presenter => self}).html_safe end # :template => 'dashboard/_widget', :handler => [:haml], # 这里是调用app/views/dashboard/_widget.html.haml app/views/dashboard/_widget.html.haml # https://github.com/ManageIQ/manageiq/blob/euwe-1/app/views/dashboard/_widget.html.haml#L8 = h(presenter.widget.title) # 这一行就是 dashboard里面的每个插件的标题，也就是需要汉化的标题 # https://github.com/ManageIQ/manageiq/blob/euwe-1/app/views/dashboard/_widget.html.haml#L35 = render :partial => 'widget_footer', :locals => {:widget => presenter.widget} # 这里是每个小插件下面的时间显示设置，指向文件位置： app/views/dashboard/_widget_footer.html.haml # https://github.com/ManageIQ/manageiq/blob/euwe-1/app/views/dashboard/_widget_footer.html.haml#L10 = _('Never') # 这行会根据地区自动来转换翻译 # https://github.com/ManageIQ/manageiq/blob/euwe-1/locale/zh_CN/manageiq.po msgid \"Next\" msgstr \"下次更新\" # https://github.com/ManageIQ/manageiq/blob/euwe-1/app/views/dashboard/_widget_footer.html.haml#L15 = format_timezone(next_run_on, session[:user_tz], \"widget_footer\") # 这里是把时间转换为中国区的， format_timezone 所在文件：lib/vmdb/global_methods.rb#L36 # https://github.com/ManageIQ/manageiq/blob/euwe-1/lib/vmdb/global_methods.rb#L36 def format_timezone(time, timezone = Time.zone.name, ftype = \"view\") new_time = I18n.l(new_time.to_date) + new_time.strftime(\" %H:%M:%S %Z\") # 这里就是时间格式转换的代码 # 这里进行了中国区的时间转换 展示板里面的插件数据库位置 数据库名： vmdb_development表名： miq_widgets字段： title \"Guest OS Information\" \"Hosts - Summary by Version\" \"Vendor and Guest OS Chart\" \"Virtual Infrastructure Platforms\" \"Top CPU Consumers (weekly)\" \"Top Memory Consumers (weekly)\" \"Top Storage Consumers\" \"EVM: Recently Discovered Hosts\" \"EVM: Recently Discovered VMs\" \"Tenant Quotas\" http://localhost:3000/dashboard/show 页面左上角 \"Default Dashboard\" 出处 # https://github.com/ManageIQ/manageiq/blob/euwe-1/app/views/layouts/_tabs.html.haml#L7 = h(tab[1]) # 这里列出了\"Default Dashboard\"字段 # https://github.com/ManageIQ/manageiq/blob/euwe-1/app/views/layouts/_content.html.haml#L122 = render :partial => 'layouts/tabs' # 这里是调用tab字段 # https://github.com/ManageIQ/manageiq/blob/euwe-1/app/views/layouts/application.html.haml#L52 = render :partial => \"layouts/content\" # 这里是调用 content # views/layouts/_tabs.html.haml 中变量 @tabs 的定义处： # https://github.com/ManageIQ/manageiq/blob/euwe-1/app/controllers/dashboard_controller.rb#L96 def show @layout = \"dashboard\" @dashboard = true @display = \"dashboard\" @lastaction = \"show\" @tabs = [] # 这里把 \"Default Dashboard\" 汉化了,在这个方法后面用I18n来转化 汉化代码 1、 dashboard页面的标题汉化 https://github.com/ManageIQ/manageiq/blob/euwe-1/app/views/dashboard/_widget.html.haml#L8 @@ -5,7 +5,13 @@ .card-pf .card-pf-heading %h2.card-pf-title.sortable-handle{:style => \"cursor:move\"} - = h(presenter.widget.title) + - if :\"zh-CN\" == I18n.locale + - begin + = I18n.t presenter.widget.title, raise: true + - rescue + = h(presenter.widget.title) + - else + = h(presenter.widget.title) .dropdown.dropdown-kebab-pf.pull-right https://github.com/ManageIQ/manageiq/blob/euwe-1/locale/zh_CN.yml#L7 + + \"Vendor and Guest OS Chart\": \"供应商和客户操作系统图\" + \"Guest OS Information\": \"客户操作系统信息\" + \"Hosts - Summary by Version\": \"主机 - 摘要 与 版本\" + \"Virtual Infrastructure Platforms\": \"虚拟基础设施平台\" + \"Top CPU Consumers (weekly)\": \"最高CPU使用者(每周)\" + \"Top Memory Consumers (weekly)\": \"最高内存使用者(每周)\" + \"Top Storage Consumers\": \"最高存储使用者\" + \"EVM: Recently Discovered Hosts\": \"引擎：最近发现的主机\" + \"EVM: Recently Discovered VMs\": \"引擎: 最近发现的虚拟机\" + \"Tenant Quotas\": \"租户配额\" + \"Default Dashboard\": \"默认展示板\" 2、dashboard页面 中左上角 \"Default Dashboard\" 的汉化https://github.com/ManageIQ/manageiq/blob/euwe-1/app/controllers/dashboard_controller.rb#L204 @@ -202,6 +202,16 @@ class DashboardController powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/manageiq/005-manageIQ网页部分功能代码实现.html":{"url":"doc/manageiq/005-manageIQ网页部分功能代码实现.html","title":"manageIQ网页部分功能代码实现","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 代码版本 创建一个虚拟机实例(instance) 登录后网页效果显示的代码 代码版本 https://github.com/ManageIQ/manageiq/tree/euwe-1 创建一个虚拟机实例(instance) 1.网页链接： http://localhost:3000/vm_cloud/explorer2.当输入信息后，点击 “submit”后，controller部分处理代码位置： manageiq/app/controllers/application_controller/miq_request_methods.rb elsif params[:button] == \"submit\" # Update or create the request from the workflow with the new options prov_req_submit # line:208 else 登录后网页效果显示的代码 1.在每个网页显示效果是， Rails会指定一个默认的页面模板，这个模板位置：app/views/layouts/application.html.haml这个模板里定义了网页的风格与导航栏的定义。 在这个文件里：4~12行，18~48行是网页的 head部分(登录网页后右键查看元素)。13~14，50~53行， 是网页的body部分， powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/manageiq/006-新建提供者.html":{"url":"doc/manageiq/006-新建提供者.html","title":"新建提供者","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. MIQ新增提供者方式 ## 2. 新增提供者目录 ## [TOC] 原版地址 http://note.youdao.com/noteshare?id=9428c64abd08efc359f5b7eb9bda7e28 1. MIQ新增提供者方式 MIQ在D版新增的功能就是把所有的提供者所需要用到的类文件进行了按目录分割，这样的好处就是在以后增加一个新的提供者时，不需要对其他的类文件产生任何影响。不好的地方就是，相同的代码可能会存在多份，不过可以通过抽象共通的逻辑到model中来减少重复代码。 2. 新增提供者目录 以下操作按照新增一个阿里云提供者为例来说明如何添加新的提供者。 首先需要在model下的提供者目录下新增自己要添加的提供者目录 新建一个类infra_manager.rb（名称无所谓，也可以叫aliyun_manager.rb），类里信息： 在阿里云目录下新建一个infra_manager目录（该目录必须和上一个类的名字一致），该目录中存放的文件都是这个提供者所需要使用到的类，我们可以参考vmware的目录，具体的还是要根据实际情况来决定，目前因为我还没完全做完，仅做个提示。 配置展示提供者权限 仅仅增加了提供者目录还不足够让MIQ显示咱们的新的提供者，还必须设置展示权限才可以。权限设置文件为：miq\\vmdb\\config\\permissions.yml，在文件最后一行增加新的提供者，其中有个permissions.tmpl.yml文件也许也要添加，我添加的时候这两个文件都添加了，所以不敢保证只添加一个是否会成功，但是两个都添加肯定可以成功。 fog的配置以及连接 未开始 配置workers 未开始 界面配置 未开始 自动化引擎配置 未开始 界面显示效果 powered by Gitbook文件最后修改时间： 2021-03-11 23:13:23 "},"doc/manageiq/007-manageiq各种云平台provide资料.html":{"url":"doc/manageiq/007-manageiq各种云平台provide资料.html","title":"manageiq各种云平台provide资料","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 return home 微软azure providers amazon 阿里云aliyun manageiq-providers-lenovo return home 微软azure providers https://github.com/fog/fog-azuremanageiq azure provider:https://github.com/ManageIQ/manageiq-providers-azureResource Manager 模式 - 用于在 Resource Manager 部署模型中处理 Azure 资源。若要设置此模式，请运行 azure config mode arm manageiq开发的armrest服务SDK powershell azure_CLI 中文安装文档 azure开发文档：https://docs.microsoft.com/zh-cn/azure/azure ruby开发：https://azure.microsoft.com/zh-cn/develop/ruby/https://github.com/Azure/azure-sdk-for-rubyhttps://azure.microsoft.com/zh-cn/downloads/Azure REST API Reference: https://docs.microsoft.com/zh-cn/rest/api/index对云服务的操作：URL访问资源rest： https://msdn.microsoft.com/library/en-us/Ee460812.aspxhttps://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-supported-services 服务管理 REST API 参考 Azure Active Directory介绍 中国区Azure应用程序开发说明(国内站点网址)：azure开发连接的国内网站客服提供 powershell CLI 中对虚拟的操作，获得镜像信息 个人编写的文档： azure-armrest中链接作用 azure获取TenantID, SubscriptionID, ClientID, ClientKey azure使用虚拟机生成私有镜像 amazon https://github.com/ManageIQ/manageiq-providers-amazon 阿里云aliyun https://github.com/fog/fog-aliyunhttps://rubygems.org/gems/fog-aliyunhttps://rubygems.org/gems/aliyun-apihttps://rubygems.org/gems/aliyun-sdkhttps://rubygems.org/gems/aliyun_ruby_apihttps://help.aliyun.com/document_detail/25485.html?spm=5176.doc25484.6.241.tethIg manageiq-providers-lenovo https://github.com/ManageIQ/manageiq-providers-lenovo powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/manageiq/008-manageIQ服务部署.html":{"url":"doc/manageiq/008-manageIQ服务部署.html","title":"manageIQ服务部署","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 manageiq 环境一体化虚拟机下载 # FileZilla的安装 # FileZilla的设置 ## 确认服务器能够上网 ## 服务器的代码更新 ## manageiq 环境一体化虚拟机下载 http://manageiq.org/download/在这里选好一个系统，如redhat，vmware虚拟机，这里下载好，可以直接在虚拟机中运行，环境已经搭配好。http://releases.manageiq.org/manageiq-ovirt-euwe-1.ova FileZilla的安装 服务器已经有了，此时需要把开发好的代码上传到服务器运行，使用filezilla软件可以连接服务器并修改文件。 centos系统下下载filezilla 1.在 Application Installer 软件中心搜索 filezilla，如果能搜索出来，那么可以点击安装。2.如果没有那么在终端运行命令： ## http://linux.it.net.cn/CentOS/course/2016/0401/20899.html $ sudo yum install –y filezilla FileZilla的设置 连接服务器打开软件后，输入host、username、password,port一般输入22，然后点快速连接。 软件语言设置edit -> settings -> language，然后在里面找和中文(Chinese(Simplified)(zh_CN) )、英文。 编辑.rb文件的编辑器设置编辑 -> 设置 -> 文件编辑 -> 文件格式关联，在里面添加： rb /usr/bin/gedit 确认服务器能够上网 因为需要安装ruby gem包，所需需要确认能够联网： $ ping wwww.baidu.com $ ping www.github.com $ ping bitbucket.org 如果不能上网： 配置DNS地址 http://jingyan.baidu.com/article/870c6fc32c028eb03fe4be30.html cd /etc/sysconfig/network-scripts cp ifcfg-eth0 ifcfg-eth0.backup vi ifcfg-eth0 # 修改里面DNS DNS1=221.228.255.1 $ vi /etc/resolv.conf # 在里面添加下面三行 nameserver 221.228.255.1 nameserver 114.114.114.114 nameserver 8.8.88 服务器的代码更新 使用FileZilla 输入用户名、密码、地址、端口(22)，链接，然后把代码上传上去，部分文件 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/manageiq/009-manageIQ网页图标、图片、网页导航栏风格修改.html":{"url":"doc/manageiq/009-manageIQ网页图标、图片、网页导航栏风格修改.html","title":"manageIQ网页图标、图片、网页导航栏风格修改","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. 登录首页图标的修改 2. 登录页面的中间部分的背景色修改 3. 登陆后页面上部(header)导航栏的背景色 4. 登录后右上角 关于(about)页面的风格设置 5. 登陆后，垂直导航栏的颜色设置 [TOC] 代码版本 https://github.com/ManageIQ/manageiq/tree/euwe-1 修改后的生产环境需要从新编译js文件 ###### 下面命令不管用再用： bin/update $ bin/rails evm:compile_assets 1. 登录首页图标的修改 1.查找相关信息 打开网站后，网页右键-->inspect(检查) --> select an element in the page to inspect it -->然后把鼠标放到图标那里，点击一下，就会看见定义信息， 右上角图标信息：用户名上面的图标： 右上角图标的修改 # manageiq官网镜像下载后虚拟机中代码位置 $ cd /var/www/miq/vmdb $ find ./ -name \"login-screen-logo*\" #查找图标信息 # 源代码中定义的图标 ./app/assets/images/login-screen-logo.png #源代码中修改此处就可以，图片替换 # 为了加快网页速度，生成的js共有资源的位置，网页中真实的访问图片位置， # 官网镜像中为了快速修改，可以直接修改此处 ./public/assets/login-screen-logo-cd43380036fc96964823fd8d6d7486fe9bcfcce1498daf0c41d8bc94385511da.png ./public/self_service/images/login-screen-logo.png 用户名上面的图片(manageIQ)修改 # manageiq官网镜像下载后虚拟机中代码位置 $ cd /var/www/miq/vmdb $ find ./ -name \"brand*\" #查找图标(manageIQ)位置 # 源代码中定义的图标 ./app/assets/images/brand.svg #源代码中修改此处就可以，图片替换 ./public/assets/brand-7005158295b20605eae00a080448d69a9c7b541ee3f99469b86e1bae955b0e89.svg.gz # 为了加快网页速度，生成的js共有资源的位置，网页中真实的访问图片位置，名字要一样。 ./public/assets/brand-7005158295b20605eae00a080448d69a9c7b541ee3f99469b86e1bae955b0e89.svg ./public/self_service/images/brand.svg ./public/self_service/img/brand-alt.svg ./public/self_service/img/brand.svg ./vendor/assets/bower_components/patternfly-sass/assets/images/patternfly/brand-alt.svg ./vendor/assets/bower_components/patternfly-sass/assets/images/patternfly/brand.svg 网页标题(title)更改 1.这个是文字不是图片，查找定义处： # 这里是首页登录的控制器处理部分，在这一喊显示了调用了哪部分视图 https://github.com/ManageIQ/manageiq/blob/euwe-1/app/controllers/dashboard_controller.rb#L357 # 这里是网页渲染，这一行显示了title处理部分， -->title_from_layout 这个方法返回title是什么 https://github.com/ManageIQ/manageiq/blob/euwe-1/app/views/layouts/login.html.haml#L6 # title_from_layout 方法定义处，这里用I18n来自动转换语言，在语言里写着标题 https://github.com/ManageIQ/manageiq/blob/euwe-1/app/helpers/application_helper.rb#L443 #最后，这里就是标题定义处，这个有几种语言(汉语，英语等)，别的代码版本不是这个路径，不过还是local这个目录里面， # 别的版本只要找这个local目录就好了，例如：/var/www/miq/vmdb/config/locales manageIQ/locale 2.修改标题https://github.com/ManageIQ/manageiq/blob/euwe-1/locale/zh_CN.yml zh-CN: product: name: ManageIQ # 这个是网页title名字 name_full: ManageIQ #这个是登录后右上角 问号按钮的字段 (关于页面)about copyright: \"Copyright (c) 2016 ManageIQ。由红帽赞助.\" #这个是登录后右上角 问号按钮的字段 (关于页面)about support_website: \"http://www.manageiq.org\" #这个是登录后右上角 问号按钮的字段 (关于页面)about support_website_text: \"ManageIQ.org\" #这个是登录后右上角 问号按钮的字段 (关于页面)about # 修改后 zh-CN: product: name: JasCloud name_full: JasCloud copyright: \"Copyright (c) 2017 JasCloud。由中盈安信赞助。\" support_website: \"www.jasgroup.cn\" support_website_text: \"www.jasgroup.cn\" en.yml, es.yml, fr.yml, ja.yml 也需要做相应修改。修改好后需要重启服务。 2. 登录页面的中间部分的背景色修改 文件位置：app/assets/stylesheets/login.scss app/assets/stylesheets/main.scss # app/assets/stylesheets/login.scss &.login-pf { background-color: $login-bg-color !important; # 这里设置背景色的地方 } @media (min-width: $screen-sm) { &.login-pf { background: image-url($img-bg-login-2); # 这是右下角的图片设置 background-position: 100% 100%; background-repeat: no-repeat; background-size: 30%; } } # app/assets/stylesheets/main.scss $login-bg-color: #083c5a; # 大约是在28行附近 $img-bg-login: \"bg-login.png\"; # 左上角的图片 图片位置：app/assets/images/bg-login.png $img-bg-login-2: \"bg-login-2.png\";# 右下角的图片 3. 登陆后页面上部(header)导航栏的背景色 文件位置：app/assets/stylesheets/header_background.scssapp/assets/stylesheets/main.scss # app/assets/stylesheets/header_background.scss .navbar-pf-vertical { background: image-url($img-bg-navbar); # 右边的图片 background-repeat: no-repeat; background-position: 100% 0; background-color: $navbar-pf-alt-bg-color; # 背景色设置 } # app/assets/stylesheets/main.scss # 上面的背景色设置： $navbar-pf-alt-bg-color: #0c69a5; //大约在第9行 sets backgound color of navigation bar # 上面的图片设置： $img-bg-navbar: \"navbar.png\"; //大约在第11行 sets a custom background image in the header 4. 登录后右上角 关于(about)页面的风格设置 文件位置：app/assets/stylesheets/about_modal_background.scss #app/assets/stylesheets/about_modal_background.scss .about-modal-pf { background-color: $modal-about-pf-bg-color; # 背景色的设置 background-image: image-url($modal-about-pf-bg-img); # 图片的设置 } # app/assets/stylesheets/main.scss $modal-about-pf-bg-img: \"bg-modal-about-pf.png\"; // sets background image of 'About' modal $modal-about-pf-bg-color: #083c5a; // sets background color of 'About' modal 5. 登陆后，垂直导航栏的颜色设置 这个导航栏的风格是第三方插件： # Gemfile 文件 group :ui_dependencies do # Added to Bundler.require in config/application.rb ········· gem \"patternfly-sass\", \"~>3.12.0\" # 这个是垂直导航栏的风格，大约95行附近 ········· end 垂直导航栏颜色设置源码：https://github.com/patternfly/patternfly-sass/blob/v3.12.0/assets/stylesheets/patternfly/_vertical-nav.scss manageIQ文件可设置颜色参数，变量即上面的变量： # app/assets/stylesheets/main.scss //手动添加的内容 $nav-pf-vertical-bg-color: #1770e6; //垂直导航栏第一列背景色 $nav-pf-vertical-item-border-color: #f5ed3c; //垂直导航栏第一列边栏的颜色 $nav-pf-vertical-color: #ffe015; //垂直导航栏第一列字体颜色 $nav-pf-vertical-active-bg-color: #261ac0; //垂直导航栏第一列鼠标选择按钮时候的颜色 $nav-pf-vertical-active-color: #d60116; //垂直导航栏第一列鼠标选择时,字体的颜色 $nav-pf-vertical-icon-color: #fcfcfc; //垂直导航栏第一列 图标颜色 $nav-pf-vertical-active-icon-color: #b22e23; //垂直导航栏第一列鼠标选择时,图标的颜色 $nav-pf-vertical-active-before-color: #82237b;//垂直导航栏第一列鼠标选择后,左边多出来的一条颜色 $nav-pf-vertical-secondary-color: #fff717; //垂直导航栏第二列导航标题字体颜色 //$nav-pf-vertical-secondary-bg-color: #7b22ff; //垂直导航栏第二列背景色,如果这个不设置则跟鼠标选择第一列的颜色是一样的。 $nav-pf-vertical-secondary-item-color: #d60116; //垂直导航栏第二列字体颜色, $nav-pf-vertical-secondary-active-bg-color: #696fff; //垂直导航栏第二列鼠标选择按钮时候的背景色 $nav-pf-vertical-secondary-active-color: #ffe015; //垂直导航栏第二列鼠标选择按钮时 字体的颜色 $nav-pf-vertical-secondary-indicator-color: #ff03e8; //垂直导航栏箭头颜色 $nav-pf-vertical-tertiary-bg-color: #696fff; //垂直导航栏第三列的背景色 $nav-pf-vertical-tertiary-color: #b82433; //垂直导航栏第三列标题字颜色 $nav-pf-vertical-tertiary-item-color: #db0921; //垂直导航栏第三列字体的颜色 $nav-pf-vertical-tertiary-active-bg-color: #fef9ff; //垂直导航栏第三列鼠标选择时的背景色 $nav-pf-vertical-tertiary-active-color: #000000; //垂直导航栏第三列鼠标选择时的 字体颜色 powered by Gitbook文件最后修改时间： 2021-03-11 23:20:36 "},"doc/manageiq/010-开发manageiq遇见的问题、错误解决.html":{"url":"doc/manageiq/010-开发manageiq遇见的问题、错误解决.html","title":"开发manageiq遇见的问题、错误解决","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. 运行bin/setup命令发生错误 2. 修改官方虚拟机中的.js文件不起作用 3. manageiq Gemfile 文件加载的不止一个 4. bin/setup:26: warning: Insecure world writable dir /home/yu in PATH, mode 040777 5. bundle install error:无法打开 .git/FETCH_HEAD：???? 6. gem install pg -v '0.18.4' error 7. Error caught: [ActionView::Template::Error] couldn't find file 'jquery' with type 'application/javascript' 8. Failed to instantiate module ManageIQ.toolbar due to:(头部工具栏消失) 9. run /opt/manageiq/manageiq/tools/ldap_ping.rb from command line [TOC] 1. 运行bin/setup命令发生错误 当下载manageiq后运行： [manageiq]$ bin/setup == Seeding database == ActionCable version is 5.0.1 or newer, please see if we still need this patch: /home/yulilong/tmp/manageiq2016-12-30/config/initializers/action_cable_patch.rb! ** Using session_store: ActionDispatch::Session::MemCacheStore rails aborted! ActiveModel::MissingAttributeError: can't write unknown attribute `region_number` /home/yulilong/.rvm/gems/ruby-2.3.0/gems/activerecord-5.0.1/lib/active_record/attribute.rb:182:in `with_value_from_database' /home/yulilong/.rvm/gems/ruby-2.3.0/gems/activerecord-5.0.1/lib/active_record/attribute.rb:63:in `forgetting_assignment' /home/yulilong/.rvm/gems/ruby-2.3.0/gems/activesupport-5.0.1/lib/active_support/core_ext/hash/transform_values.rb:16:in `block in transform_values' /home/yulilong/.rvm/gems/ruby-2.3.0/gems/activesupport-5.0.1/lib/active_support/core_ext/hash/transform_values.rb:15:in `each' /home/yulilong/.rvm/gems/ruby-2.3.0/gems/activesupport-5.0.1/lib/active_support/core_ext/hash/transform_values.rb:15:in `transform_values' /home/yulilong/.rvm/gems/ruby-2.3.0/gems/activerecord-5.0.1/lib/active_record/attribute_set/builder.rb:26:in `transform_values' 查看rails版本： $ rails -v Rails 5.0.0.1 在rails 版本是 5.0.0.1下，解决方法： 打开Gemfile文件，修改如下： -gem \"rails\", \"~>5.0.0\", \">= 5.0.0.1\" +gem \"rails\", \"~>5.0.0\", \">= 5.0.0.1\", \" 保存后，删除Gemfile.lock文件，然后从新运行命令即可解决问题。 2. 修改官方虚拟机中的.js文件不起作用 下载： http://releases.manageiq.org/manageiq-ovirt-euwe-1-rc2.ova运行这个虚拟机后，修.rb文件时有效的，但是修改.js文件时不起作用的，经查找，虚拟机中.js文件已经编译了， 网页访问的资源(/var/www/miq/vmdb/public/assets). .js文件编译后都放在这个文件中了。 如果修改了.js文件，那么在虚拟机中运行: # bin/update $ bin/rails evm:compile_assets 3. manageiq Gemfile 文件加载的不止一个 在根目录的Gemfile文件里面： # Load other additional Gemfiles eval_gemfile(File.expand_path(\"gems/pending/Gemfile\", __dir__)) Dir.glob(\"bundler.d/*.rb\").each { |f| eval_gemfile(File.expand_path(f, __dir__)) } 4. bin/setup:26: warning: Insecure world writable dir /home/yu in PATH, mode 040777 $ sudo chmod go-w /home/yulilong 5. bundle install error:无法打开 .git/FETCH_HEAD：???? # https://github.com/Homebrew/legacy-homebrew/issues/43471 # centos 7.2的解决方案(亲测有效果) sudo chown -R $(whoami):root /usr/local && sudo chmod -R g+rwx /usr/local # Mac苹果系统的解决方式(没有试过) sudo chown -R $(whoami):admin /usr/local && sudo chmod -R g+rwx /usr/local 6. gem install pg -v '0.18.4' error descriptionERROR: Error installing pg: ERROR: Failed to build gem native extension. ..... ..... ..... To see why this extension failed to compile, please check the mkmf.log which can be found here: solution:http://www.faqoverflow.com/serverfault/316703.html```bash $ sudo yum install postgresql-devel If you still encounter issues with pg_config, you may need to add it to your PATH, e.g.: $ export PATH=$PATH:/usr/pgsql-x.x/bin where x.x is your version, such as /usr/pgsql-9.2./bin. ![](./img/023-manageiq.png) ## 7. Error caught: [ActionView::Template::Error] couldn't find file 'jquery' with type 'application/javascript' ![](./img/024-manageiq.png) 解决方法： ```bash # 打开程序根目录bower.json,大约58到63行， \"resolutions\": { \"patternfly-bootstrap-treeview\": \"~2.1.1\", \"moment\": \">=2.10.5\", \"d3\": \"~3.5.0\", \"jquery\": \">1.8.*\" # 改成\"jquery\": \">=1.7.1\"，如果还出错，就把这一行删除然后在运行 } 把\"jquery\": \">1.8.*\" 改成\"jquery\": \">=1.7.1\" # 然后运行下面命令： $ bower install # 如果这个命令运行后没有什么输出，那么运行 bower update 后再次运行这个命令 # 如果还是没有反应就看看是不是代理失效了，这个命令需要代理翻墙才可以，确认代理后从新运行这个命令 #或者使用下面命令 $ bin/update 8. Failed to instantiate module ManageIQ.toolbar due to:(头部工具栏消失) 解决方法： # https://github.com/ManageIQ/manageiq/pull/13750 # http://talk.manageiq.org/t/failed-to-instantiate-module-manageiq-toolbar-due-to/2185/3 # 打开程序根目录bower.json,大约58到63行， \"dependencies\": { \"angular\": \"~1.5.8\", \"angular-animate\": \"~1.5.8\", ········ \"manageiq-ui-components\": \"~0.0.9\", # 这里改成\"manageiq-ui-components\": \"0.0.11\", ······· } 把\"manageiq-ui-components\": \"~0.0.9\", 改成 \"manageiq-ui-components\": \"0.0.11\", # 然后运行下面命令： $ bower update $ bower install # 如果没有反应就看看是不是代理失效了，这个命令需要代理翻墙才可以，确认代理后从新运行这个命令 #或者使用下面命令 $ bin/update 9. run /opt/manageiq/manageiq/tools/ldap_ping.rb from command line $ bundle exec rails r tools/ldap_ping.rb powered by Gitbook文件最后修改时间： 2021-03-11 23:27:48 "},"doc/manageiq/011-添加新的Providers代码开发.html":{"url":"doc/manageiq/011-添加新的Providers代码开发.html","title":"添加新的Providers代码开发","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. 添加一个新的providers代码目录 1.1 添加页面validate按钮可用设置 2. 添加work 2.1 添加 ManageIQ::Providers::Aliyun::CloudManager::RefreshWorker 2.2 EVM CloudManager 启用监听 2.3 ManageIQ/manageiq/config/settings.yml 2.4 manageiq/app/models/miqserver/workermanagement/monitor/class_names.rb 2.5 providers中添加代码 3. aliyun providers 读取信息 4. 添加自动监视 5. 代码编写 6. 套餐(Flavors) 7. 可用区(Availability Zones) 8. 添加ManageIQ::Providers::Aliyun::NetworkManager::RefreshWorker ## 9. EVM NetworkManager 启用监听 9.1 ManageIQ/manageiq/config/settings.yml 9.2 manageiq/app/models/miqserver/workermanagement/monitor/class_names.rb 9.3 添加 networkmanager 图标 9.4 NetworkManager代码 9.5 添加安全组(security_groups) 9.6 添加实例(Instance) 9.7 添加实例的开机、关机、重启功能 [TOC] 1. 添加一个新的providers代码目录 1.1 添加页面validate按钮可用设置 manageiq/app/assets/javascripts/controllers/ems_common/ems_common_form_controller.js 在191行 附近如下代码处添加一行代码（$scope.emsCommonModel.emstype == \"aliyun\" ||） #!js $scope.isBasicInfoValid = function() { if(($scope.currentTab == \"default\" && $scope.emsCommonModel.emstype != \"azure\") && ($scope.emsCommonModel.emstype == \"ec2\" || $scope.emsCommonModel.emstype == \"aliyun\" || $scope.emsCommonModel.emstype == \"openstack\" && $scope.emsCommonModel.default_hostname || $scope.emsCommonModel.emstype == \"scvmm\" && $scope.emsCommonModel.default_hostname || $scope.emsCommonModel.emstype == \"openstack_infra\" && $scope.emsCommonModel.default_hostname || $scope.emsCommonModel.emstype == \"nuage_network\" && $scope.emsCommonModel.default_hostname || $scope.emsCommonModel.emstype == \"rhevm\" && $scope.emsCommonModel.default_hostname || $scope.emsCommonModel.emstype == \"vmwarews\" && $scope.emsCommonModel.default_hostname 2. 添加work 2.1 添加 ManageIQ::Providers::Aliyun::CloudManager::RefreshWorker 2.2 EVM CloudManager 启用监听 2.3 ManageIQ/manageiq/config/settings.yml https://github.com/ManageIQ/manageiq/blob/euwe-1-rc2/config/settings.yml#L1258在这个配置文件里面添加：:ems_metrics_collector_worker_aliyun: {} https://github.com/ManageIQ/manageiq/blob/euwe-1-rc2/config/settings.yml#L1295添加如下代码：:ems_refresh_worker_aliyun: {} 2.4 manageiq/app/models/miq_server/worker_management/monitor/class_names.rb 添加代码：ManageIQ::Providers::Aliyun::CloudManager::MetricsCollectorWorkerManageIQ::Providers::Aliyun::CloudManager::RefreshWorker 2.5 providers中添加代码 可以参考其他providers，需要添加如下几个文件：manageiq-providers-aliyun/app/models/manageiq/providers/aliyun/cloud_manager/metrics_collector_worker/runner.rb manageiq-providers-aliyun/app/models/manageiq/providers/aliyun/cloud_manager/metrics_collector_worker.rb manageiq-providers-aliyun/app/models/manageiq/providers/aliyun/cloud_manager/refresh_worker.rb manageiq-providers-aliyun/app/models/manageiq/providers/aliyun/cloud_manager/refresher.rb 3. aliyun providers 读取信息 在显示套餐详细信息页面中添加aliyun providers 图标 (http://localhost:3000/flavor/show/15)### 图标存放位置：manageiq/app/assets/images/100 图片名字：vendor-aliyun.png 4. 添加自动监视 manageiq/lib/miq_automation_engine/service_models 在运行我worker时候，查看evm.log文件的时候发现如下错误， Error: [uninitialized constant MiqAeMethodService::MiqAeServiceManageIQ_Providers_Aliyun_CloudManager] [NameError]: uninitialized constant MiqAeMethodService::MiqAeServiceManageIQ_Providers_Aliyun_CloudManager Method:[rescue in deliver] 参考其他的provider的写法，把aliyun相关的类添加上，一个类一个文件：MiqAeServiceManageIQ_Providers_Aliyun_CloudManager在里面每个provider都有很多类，写到哪个类的时候可以手动添加上。 5. 代码编写 manageiq-providers-aliyun/app/models/manageiq/providers/aliyun/cloud_manager/refresher.rb这个文件是provider worker工作的入口，这个文件里面先搜集信息，然后保存信息，相关写法可参考amazon、openstack providers的写法 def parse_legacy_inventory(ems) # 这个方法是搜集云服务的一些信息（套餐、可用区、安全组、镜像、实例等） def save_inventory(ems, _targets, hashes) # 这个方法保存搜集到的信息，2中保存方法 manageiq-providers-aliyun/app/models/manageiq/providers/aliyun/cloud_manager/refresh_parser.rb这个文件是搜集信息的具体代码定义处。 def ems_inv_to_hashes #这里就是每个信息的搜集处 6. 套餐(Flavors) manageiq-providers-aliyun/app/models/manageiq/providers/aliyun/cloud_manager/refresh_parser.rb def get_flavors # 具体实现参考amazon、openstack providers的写法 添加文件,可参考amazon、openstack providers的写法manageiq-providers-aliyun/app/models/manageiq/providers/aliyun/cloud_manager/flavor.rb添加类：manageiq/lib/miq_automation_engine/service_modelsMiqAeServiceManageIQ_Providers_Aliyun_CloudManager_Flavor 7. 可用区(Availability Zones) app/models/manageiq/providers/aliyun/cloud_manager/refresh_parser.rb def get_availability_zones # 具体实现参考amazon、openstack providers的写法 添加文件,可参考amazon、openstack providers的写法app/models/manageiq/providers/aliyun/cloud_manager/availability_zone.rb添加类：manageiq/lib/miq_automation_engine/service_modelsMiqAeServiceManageIQ_Providers_Aliyun_CloudManager_AvailabilityZone 安全组是在NetworkManager 模块里面的，所以先提阿加 NetworkManager 8. 添加ManageIQ::Providers::Aliyun::NetworkManager::RefreshWorker 9. EVM NetworkManager 启用监听 9.1 ManageIQ/manageiq/config/settings.yml 这里与上边的设置一样，在相关位置添加如下代码(大约是第1370行附近)： :ems_refresh_worker_aliyun_network: {} 9.2 manageiq/app/models/miq_server/worker_management/monitor/class_names.rb 在2个数组中（MONITOR_CLASS_NAMES、MONITOR_CLASS_NAMES_IN_KILL_ORDER）添加如下代码： ManageIQ::Providers::Aliyun::NetworkManager::RefreshWorker 9.3 添加 networkmanager 图标 manageiq/app/assets/images/svg添加一个图片，名字： vendor-aliyun_network.svgmanageiq/app/assets/images/100添加一个图片，名字： vendor-aliyun_network.png 9.4 NetworkManager代码 app/models/manageiq/providers/aliyun/network_manager.rbapp/models/manageiq/providers/aliyun/network_manager/refresher.rbapp/models/manageiq/providers/aliyun/network_manager/refresh_worker.rbapp/models/manageiq/providers/aliyun/network_manager/refresh_parser.rbapp/models/manageiq/providers/aliyun/network_manager/metrics_collector_worker.rbapp/models/manageiq/providers/aliyun/network_manager/refresh_worker/runner.rbapp/models/manageiq/providers/aliyun/network_manager/metrics_collector_worker/runner.rb 可以看到，Aliyun::NetworkManager 与 Aliyun::CloudManager 文件、代码结构差不多。具体实现也是一样的。 9.5 添加安全组(security_groups) app/models/manageiq/providers/aliyun/network_manager/refresh_parser.rb def get_availability_zones # 具体实现参考amazon、openstack providers的写法 添加文件,可参考amazon、openstack providers的写法app/models/manageiq/providers/aliyun/network_manager/security_group.rb添加类：manageiq/lib/miq_automation_engine/service_modelsMiqAeServiceManageIQ_Providers_Aliyun_NetworkManager_SecurityGroup 9.6 添加实例(Instance) app/models/manageiq/providers/aliyun/network_manager/refresh_parser.rb get_instances # 具体实现参考amazon、openstack providers的写法 添加文件,可参考amazon、openstack providers的写法app/models/manageiq/providers/aliyun/cloud_manager/vm.rb 添加类：manageiq/lib/miq_automation_engine/service_modelsMiqAeServiceManageIQ_Providers_Aliyun_CloudManager_Vm 添加方法： app/models/manageiq/providers/aliyun/cloud_manager/refresher.rb def post_process_refresh_classes #如果没有这个方法，vm.rb将不能执行 [::Vm] end 这里也添加一下：db/fixtures/miq_searches.yml # line:43 -attributes: name: default_Platform / Aliyun description: Platform / Aliyun filter: !ruby/object:MiqExpression exp: \"=\": field: Vm-type value: ManageIQ::Providers::Aliyun::CloudManager::Vm search_type: default search_key: _hidden_ db: Vm - attributes: # line:1020 name: default_Platform / Aliyun description: Platform / Aliyun filter: !ruby/object:MiqExpression exp: \"=\": field: VmCloud-type value: ManageIQ::Providers::Aliyun::CloudManager::Vm search_type: default search_key: _hidden_ db: ManageIQ::Providers::CloudManager::Vm 数据库中，vms表 vendor字段的aliyun支持：app/models/vm_or_template.rb VENDOR_TYPES = { # 如果没有这个，数据库将不能存储实例，数据验证失败 \"google\" => \"Google\", \"aliyun\" => \"Aliyun\", \"unknown\" => \"Unknown\"} 9.7 添加实例的开机、关机、重启功能 当在网页点击开机后，rails 会给evm 服务发送消息，由EVM 服务来完成的， 添加电源操作Operations模块：app/models/manageiq/providers/aliyun/cloud_manager/vm/operations.rb module ManageIQ::Providers::Aliyun::CloudManager::Vm::Operations extend ActiveSupport::Concern include_concern 'Guest' include_concern 'Power' end 添加Guest模块，这里是重启服务器的实现部分app/models/manageiq/providers/aliyun/cloud_manager/vm/operations/guest.rb module ManageIQ::Providers::Aliyun::CloudManager::Vm::Operations::Guest extend ActiveSupport::Concern included do supports :reboot_guest do unsupported_reason_add(:reboot_guest, unsupported_reason(:control)) unless supports_control? unsupported_reason_add(:reboot_guest, _(\"The VM is not powered on\")) unless current_state == \"on\" end end def raw_reboot_guest with_provider_connection { |connection| parameters = {:InstanceId => ems_ref} connection.RebootInstance(parameters) # retrun {\"RequestId\"=>\"9585CF9B-9049-41A1-B42B-BE3867C26AAB\"} } # Temporarily update state for quick UI response until refresh comes along self.update_attributes!(:raw_power_state => \"reboot\") # show state as suspended end end 添加Power模块，这里是开机、关机实现部分app/models/manageiq/providers/aliyun/cloud_manager/vm/operations/power.rb``` module ManageIQ::Providers::Aliyun::CloudManager::Vm::Operations::Power extend ActiveSupport::Concern def raw_start with_provider_connection { |connection| parameters = {:InstanceId => ems_ref} connection.StartInstance(parameters) } Temporarily update state for quick UI response until refresh comes along self.update_attributes!(:raw_power_state => \"powering_up\") end def raw_stop with_provider_connection { |connection| parameters = {:InstanceId => ems_ref} connection.StopInstance(parameters) } Temporarily update state for quick UI response until refresh comes along self.update_attributes!(:raw_power_state => \"shutting_down\") end end * 最后在vm类中添加Operations的引用 app/models/manageiq/providers/aliyun/cloud_manager/vm.rb include_concern 'Operations' ``` powered by Gitbook文件最后修改时间： 2021-03-12 08:48:14 "},"doc/manageiq/012-centos7,rvm,ruby,gems,rails,pqadmin3,rubymine,isntall.html":{"url":"doc/manageiq/012-centos7,rvm,ruby,gems,rails,pqadmin3,rubymine,isntall.html","title":"centos7,rvm,ruby,gems,rails,pqadmin3,rubymine,isntall","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. rvm ruby RubyGems Rails isntall 2. 安装 pqadmin3 3. install rubymine [TOC] 注意：要按照顺序安装 1. rvm ruby RubyGems Rails isntall https://www.digitalocean.com/community/tutorials/how-to-install-ruby-on-rails-on-centos-6-with-rvm rvm install:$ sudo yum update $ sudo yum install curl $ curl -L get.rvm.io | bash -s stable 如果提示缺少密钥，那么按照提示安装密钥 # If you ran the installer as root, run: $ source /usr/local/rvm/rvm.sh # If you installed it through a user with access to sudo: $ source ~/.rvm/rvm.sh $ source ~/.profile $ rvm -v 如果出现版本，那么说明安装成功。 ruby install: $ rvm list known 选一个版本 $ rvm install 2.3.0 $ rvm use 2.3.0 --default $ echo '[[ -s \"$HOME/.rvm/scripts/rvm\" ]] && . \"$HOME/.rvm/scripts/rvm\"' >>~/.bashrc $ source ~/.bashrc $ ruby -v 如果出现版本，那么说明安装成功。 ps: /etc/profile:此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置. /etc/bashrc:为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取. ~/.bash_profile:每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件. ~/.bashrc:该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时该文件被读取. ~/.bash_logout:当每次退出系统(退出bash shell)时,执行该文件. Install RubyGems: $ rvm rubygems current $ gem -v 如果出现版本，那么说明安装成功。 Install Rails$ gem install rails $ rails -v 如果出现版本，那么说明安装成功。 2. 安装 pqadmin3 这里首先需要系统中已经安装了postgres，如果没有安装请先安装。 查看linux中postgres 版本$ psql --version PostgreSQL是以加州大学伯克利分校计算机系开发的 POSTGRES，现在已经更名为PostgreSQL，版本 4.2为基础的对象关系型数据库管理系统（ORDBMS）。PostgreSQL支持大部分 SQL标准并且提供了许多其他现代特性：复杂查询、外键、触发器、视图、事务完整性、MVCC。同样，PostgreSQL 可以用许多方法扩展，比如， 通过增加新的数据类型、函数、操作符、聚集函数、索引。免费使用、修改、和分发 PostgreSQL，不管是私用、商用、还是学术研究使用。$ su postgres bash-4.2$ psql postgres=# \\du $ sudo find / -name postgresql.conf 注： 1.如果postgres 没有设置密码则用如下命令设置： $ sudo passwd postgres 2.如果psql notfound ，则 scl enable rh-postgresql94 bash，这个由于postgres升级导致的，http://manageiq.org/docs/guides/developer_setup/postgresql_software_collection centos7.2安装 pgadmin3https://yum.postgresql.org/http://www.voidcn.com/blog/houzhizhen/article/p-4388378.html $ wget http://ftp.riken.jp/Linux/fedora/epel/6/x86_64/epel-release-6-8.noarch.rpm $ sudo rpm -ivh epel-release-6-8.noarch.rpm $ sudo yum install pgadmin3 修改数据库配置文件，允许连接 $ sudo vi /var/opt/rh/rh-postgresql94/lib/pgsql/data/pg_hba.conf 找到下面的内容： # IPv4 local connections: host all all 127.0.0.1/32 ident # IPv6 local connections: host all all ::1/128 ident 把ident修改为 trust 并在下面添加一行： host all all 192.168.0.0/24 trust 保存后重起数据库： $ sudo systemctl restart rh-postgresql94-postgresql 查看数据库的运行：$ lsof -i:5432 3. install rubymine 如果公司对版权有要求，请公司购买激活码，这时候请安装最新版。官网地址：https://www.jetbrains.com/ruby/ 1. rubymine 最好是7.1.4版本的，这个网络上有激活码，此方法不建议。 个人网盘下载： 链接: https://pan.baidu.com/s/1o8PgQ50 密码: mk2q 2.下载后解压，进入bin目录，运行里面的rubymine.sh 即可安装。 使用中的问题： 3.rubymine安装后找不到ruby解释器位置： http://stackoverflow.com/questions/17950288/rubymine-cant-find-sdk-where-is-it * Windows - d:\\dev\\Ruby19\\bin\\ruby.exe * Mac Brew - /usr/local/Cellar/ruby/2.0.0-p247/bin/ruby * Ruby Version Manager - /Users//.rvm/rubies/ruby-1.9.3-p327/bin/ruby * Linux/Mac Default - /usr/bin/ruby powered by Gitbook文件最后修改时间： 2021-03-12 08:57:02 "},"doc/manageiq/azure/001-azure获取TenantID、SubscriptionID、ClientID、ClientKey.html":{"url":"doc/manageiq/azure/001-azure获取TenantID、SubscriptionID、ClientID、ClientKey.html","title":"azure获取TenantID、SubscriptionID、ClientID、ClientKey","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 return home overview ## powershell install 微软国内帐号获得Tenant ID, Subscription ID, Client ID, Client Key ## return home overview 在获得软件开发帐号之前，需要准备的工作： 有azure国内国外的服务器帐号。 有订阅ID，这个需要自己去申请订阅ID，只有试用的才免费，其他都是收费的。 powershell工具，根据系统的不同安装也不同，具体见下面的教程。 powershell install 使用教程：https://www.azure.cn/documentation/articles/powershell-install-configure/安装教程：https://github.com/PowerShell/PowerShellhttps://github.com/PowerShell/azure-powershell里面有各种系统的安装教程，下面以centos linux 为例说明。 # install $ sudo yum install https://github.com/PowerShell/PowerShell/releases/download/v6.0.0-alpha.14/powershell-6.0.0_alpha.14-1.el7.centos.x86_64.rpm # Uninstallation $ sudo yum remove powershell # run $ powershell # run PS /home/user_name> exit #exit powershell install powershell Azure Modulehttp://www.cnblogs.com/hengwei/p/5804139.html $ su root #这个要在root用户权限下安装才有效，普通用户安装失败 $ mkdir -p /usr/local/share/powershell/Modules #创建PowerShell Moudle的安装目录 $ powershell # 进入PowerShell环境 # 安装Azure包 PS user_name>Install-Package -Name AzureRM.NetCore.Preview -Source https://www.powershellgallery.com/api/v2 -ProviderName NuGet -ExcludeVersion -Destination /usr/local/share/powershell/Modules # Import Azure包 PS user_name> Import-Module AzureRM.NetCore.Preview 微软国内帐号获得Tenant ID, Subscription ID, Client ID, Client Key azure中国的获得``` [yu@localhost ~]$ powershell PowerShell Copyright (C) 2016 Microsoft Corporation. All rights reserved. PS /home/yu> Login-AzureRmAccount -EnvironmentName AzureChinaCloudVERBOSE: To sign in, use a web browser to open the page https://aka.ms/deviceloginchina and enter the code A2LExxxxx to authenticate. 这里打开这个连接，然后输入后面的代码，之后输入帐号，密码后就会出现下面的信息。 TenantID，SubscriptionID在下面 Environment : AzureChinaCloud Account : xxxxxxxxxxxx@jasgroup.partner.onmschina.cn TenantId : e6e48f7d-3248-4a18-8ff0-xxxxxxxxxxxx SubscriptionId : 4b1b759a-1958-412a-90ec-xxxxxxxxxxxx SubscriptionName : Windows Azure 企业 CurrentStorageAccount : Set-AzureRmContext -SubscriptionId 4b1b759a-1958-412a-90ec-xxxxxxxxxxxx $azureAdApplication = New-AzureRmADApplication -DisplayName \"webapp01\" -HomePage \"https://www.webapp01.xxxxxxxxxxxx.cn\" -IdentifierUris \"https://www.xxxxxxxxxxxx.org/webapp01\" -Password \"cloud@1qaz@xxx\" $azureAdApplication ClientKey: 就是上面设置的密码 cloud@1qaz@xxx ClientID : 就是下面的ApplicationId DisplayName : webapp01 ObjectId : 201a9648-6b80-40ce-8b7c-xxxxxxxxxxxx IdentifierUris : {https://www.xxxxxxxxxxxx.org/webapp01} HomePage : https://www.webapp01.xxxxxxxxxxxx.cn Type : Application ApplicationId : 409a871d-b24f-4bef-ac8f-xxxxxxxxxxxx AvailableToOtherTenants : False AppPermissions : ReplyUrls : {} New-AzureRmADServicePrincipal -ApplicationId $azureAdApplication.ApplicationId DisplayName Type ObjectId webapp01 ServicePrincipal ee14f618-e3b2-466b-9ff7-82xxxxxxxxxxx 给这个app设置相应的 订阅ID权限 New-AzureRmRoleAssignment -RoleDefinitionName Reader -ServicePrincipalName $azureAdApplication.ApplicationId RoleAssignmentId : /subscriptions/4b1b759a-1958-412a-90ec-xxxxxxxxxxxx/providers/Microsoft.Authorization/roleAssignments/ae74b507-19e3-4e0a-8e84-xxxxxxxxxxxx Scope : /subscriptions/4b1b759a-1958-412a-90ec-xxxxxxxxxxxx DisplayName : webapp01 SignInName : RoleDefinitionName : Reader RoleDefinitionId : acdd72a7-3385-48ef-bd42-xxxxxxxxxxxx ObjectId : ee14f618-e3b2-466b-9ff7-xxxxxxxxxxxx ObjectType : ServicePrincipal Get-AzureRmRoleAssignment RoleAssignmentId : /subscriptions/4b1b759a-1958-412a-90ec-xxxxxxxxxxxx/providers/Microsoft.Authorization/roleAssignments/ae74b507-19e3-4e0a-8e84-xxxxxxxxxxxx Scope : /subscriptions/4b1b759a-1958-412a-90ec-xxxxxxxxxxxx DisplayName : webapp01 SignInName : RoleDefinitionName : Reader RoleDefinitionId : acdd72a7-3385-48ef-bd42-xxxxxxxxxxxx ObjectId : ee14f618-e3b2-466b-9ff7-xxxxxxxxxxxx ObjectType : ServicePrincipal * azure国外获得 PS C:\\Users\\xxxx> Login-AzureRmAccount VERBOSE: To sign in, use a web browser to open the page https://aka.ms/devicelogin and enter the code GTMMSNYNX to authenticate. 这里打开这个连接，然后输入后面的代码，之后输入帐号，密码后就会出现下面的信息。 TenantID，SubscriptionID在下面 Environment : AzureCloud Account : kylin_fedora@hotmail.com TenantId : 73931c80-2096-4efa-a21c-xxxxxxxxxxxx SubscriptionId : 3b22ed16-6255-4eb4-b808-xxxxxxxxxxxx SubscriptionName : 即用即付 CurrentStorageAccount : PS C:\\Users\\xxxx> Set-AzureRmContext -SubscriptionId 3b22ed16-6255-4eb4-b808-xxxxxxxxxxxx PS C:\\Users\\xxxx> $azureAdApplication = New-AzureRmADApplication -DisplayName \"webapp01\" -HomePage \"https://www.webapp01.xxxxxxxxxxxx.cn\" -IdentifierUris \"https://www.xxxxxxxxxxxx.org/webapp01\" -Password \"cloud@1qaz@xxx\" PS C:\\Users\\xxxx> $azureAdApplication ClientKey: 就是上面设置的密码 cloud@1qaz@xxx ClientID : 就是下面的ApplicationId DisplayName : webapp01 ObjectId : f31dc940-54af-49be-9c17-xxxxxxxxxxxx IdentifierUris : {https://www.xxxxxxxxxxxx.org/webapp01} HomePage : https://www.webapp01.xxxxxxxxxxxx.cn Type : Application ApplicationId : 8ba1064d-d53c-4ad3-82e2-xxxxxxxxxxxx AvailableToOtherTenants : False AppPermissions : ReplyUrls : {} PS C:\\Users\\kylin> New-AzureRmADServicePrincipal -ApplicationId $azureAdApplication.ApplicationId DisplayName Type ObjectId webapp01 ServicePrincipal 1757c1ee-12bb-4e62-9ef4-xxxxxxxxxxxx 给这个app设置相应的 订阅ID权限 PS C:\\Users\\kylin> New-AzureRmRoleAssignment -RoleDefinitionName Reader -ServicePrincipalName $azureAdApplication.ApplicationId RoleAssignmentId : /subscriptions/3b22ed16-6255-4eb4-b808-xxxxxxxxxxxx/providers/Microsoft.Authorization/roleAssignments/fc911348-23cc-4329-bbc4-xxxxxxxxxxxx Scope : /subscriptions/3b22ed16-6255-4eb4-b808-xxxxxxxxxxxx DisplayName : webapp01 SignInName : RoleDefinitionName : Reader RoleDefinitionId : acdd72a7-3385-48ef-bd42-xxxxxxxxxxxx ObjectId : 1757c1ee-12bb-4e62-9ef4-xxxxxxxxxxxx ObjectType : ServicePrincipal PS C:\\Users\\kylin> Get-AzureRmRoleAssignment RoleAssignmentId : /subscriptions/3b22ed16-6255-4eb4-b808-xxxxxxxxxxxx/providers/Microsoft.Authorization/roleAssignments/fc911348-23cc-4329-bbc4-xxxxxxxxxxxx Scope : /subscriptions/3b22ed16-6255-4eb4-b808-xxxxxxxxxxxx DisplayName : webapp01 SignInName : RoleDefinitionName : Reader RoleDefinitionId : acdd72a7-3385-48ef-bd42-xxxxxxxxxxxx ObjectId : 1757c1ee-12bb-4e62-9ef4-xxxxxxxxxxxx ObjectType : ServicePrincipal ``` 赋予应用ID操作订阅ID权限的命令: Owner has full access to all resources including the right to delegate access to others.Contributor can create and manage all types of Azure resources but can’t grant access to others.Reader can view existing Azure resources. powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/manageiq/azure/002-azure开发连接的国内网站.html":{"url":"doc/manageiq/azure/002-azure开发连接的国内网站.html","title":"azure开发连接的国内网站","keywords":"","body":" Name : AzureChinaCloud EnableAdfsAuthentication : False ActiveDirectoryServiceEndpointResourceId : https://management.core.chinacloudapi.cn/ AdTenant : GalleryUrl : https://gallery.chinacloudapi.cn/ ManagementPortalUrl : http://go.microsoft.com/fwlink/?LinkId=301902 ServiceManagementUrl : https://management.core.chinacloudapi.cn/ PublishSettingsFileUrl : http://go.microsoft.com/fwlink/?LinkID=301776 ResourceManagerUrl : https://management.chinacloudapi.cn/ SqlDatabaseDnsSuffix : .database.chinacloudapi.cn StorageEndpointSuffix : core.chinacloudapi.cn ActiveDirectoryAuthority : https://login.chinacloudapi.cn/ GraphUrl : https://graph.chinacloudapi.cn/ TrafficManagerDnsSuffix : trafficmanager.cn AzureKeyVaultDnsSuffix : vault.azure.cn AzureKeyVaultServiceEndpointResourceId : https://vault.azure.cn powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/manageiq/azure/003-azure-armrest中链接作用.html":{"url":"doc/manageiq/azure/003-azure-armrest中链接作用.html","title":"azure-armrest中链接作用","keywords":"","body":" 获得订阅下面所有Storage accounts信息https://management.chinacloudapi.cn/subscriptions/4b1b759a-1958-412a-90ec-d9a4959ad8bc/providers/Microsoft.Storage/storageAccounts?api-version=2016-05-01返回信息： {\"value\":[{\"id\":\"/subscriptions/4b1b759a-1958-412a-90ec-d9a4959ad8bc/resourceGroups/test/providers/Microsoft.Storage/storageAccounts/testdiag563\",\"kind\":\"Storage\",\"location\":\"chinanorth\",\"name\":\"testdiag563\",\"properties\":{\"creationTime\":\"2017-01-05T02:23:12.5759270Z\",\"primaryEndpoints\":{\"blob\":\"https://testdiag563.blob.core.chinacloudapi.cn/\",\"file\":\"https://testdiag563.file.core.chinacloudapi.cn/\",\"queue\":\"https://testdiag563.queue.core.chinacloudapi.cn/\",\"table\":\"https://testdiag563.table.core.chinacloudapi.cn/\"},\"primaryLocation\":\"chinanorth\",\"provisioningState\":\"Succeeded\",\"statusOfPrimary\":\"available\"},\"sku\":{\"name\":\"Standard_LRS\",\"tier\":\"Standard\"}, 对应的网站信息： 获取storageAccounts/testdiag563下key信息https://management.chinacloudapi.cn/subscriptions/4b1b759a-1958-412a-90ec-d9a4959ad8bc/resourceGroups/test/providers/Microsoft.Storage/storageAccounts/testdiag563/listKeys?api-version=2016-05-01返回信息： NKxXLEqWH80FIReivSMGgNb8vwUHDl47UkeZ1Xm3LfPIazV+FhtRmTt56rTsy7EjhA9dVh0H+YrB5nZxBigMww== 这个应该查询存储账户下面的信息，知道后更新{:url=>\"https://testvmdisks334.blob.core.chinacloudapi.cn/?comp=list\", :headers=>{\"Content-Type\"=>\"\", \"x-ms-date\"=>\"Tue, 24 Jan 2017 01:35:14 GMT\", \"x-ms-version\"=>\"2015-12-11\", :auth_string=>true, \"content-type\"=>\"\", \"auth_string\"=>true, \"Authorization\"=>\"SharedKey testvmdisks334:0KTn90jFVVekdTyW/C4nMlw7wCditXSc7j+VFlfxSBU=\"}, :proxy=>nil, :ssl_version=>\"TLSv1\", :ssl_verify=>nil, :method=>:get} {:url=>\"https://testvmdisks334.blob.core.chinacloudapi.cn/vhds?restype=container&comp=list\", :headers=>{\"Content-Type\"=>\"\", \"x-ms-date\"=>\"Tue, 24 Jan 2017 01:35:14 GMT\", \"x-ms-version\"=>\"2015-12-11\", :auth_string=>true, \"content-type\"=>\"\", \"auth_string\"=>true, \"Authorization\"=>\"SharedKey testvmdisks334:2CRLCongUiRYOIUI6+DRJSuPDDLUDE0DQ3MiCkBg8us=\"}, :proxy=>nil, :ssl_version=>\"TLSv1\", :ssl_verify=>nil, :method=>:get} 返回结果： #> 这个应该是 Blob 服务信息，以后更新： {:url=>\"https://testvmdisks334.blob.core.chinacloudapi.cn/vhds/centos7-base20170104130639.vhd\", :headers=>{\"Content-Type\"=>\"\", \"x-ms-date\"=>\"Tue, 24 Jan 2017 01:35:14 GMT\", \"x-ms-version\"=>\"2015-12-11\", :auth_string=>true, :verb=>\"HEAD\", \"content-type\"=>\"\", \"auth_string\"=>true, \"verb\"=>\"HEAD\", \"Authorization\"=>\"SharedKey testvmdisks334:Z6j2M4pt8v+S7AvzgRL98a6bQMAdHglPp49/A+gNn+E=\"}, :proxy=>nil, :ssl_version=>\"TLSv1\", :ssl_verify=>nil, :method=>:head} 返回结果： # powered by Gitbook文件最后修改时间： 2021-03-12 09:01:20 "},"doc/manageiq/azure/004-azure使用虚拟机生成私有镜像.html":{"url":"doc/manageiq/azure/004-azure使用虚拟机生成私有镜像.html","title":"azure使用虚拟机生成私有镜像","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. overview 2. 开始生成私有镜像 3. 通过私有镜像来创建虚拟机 [TOC] 1. overview 这么做的目的 1.用于manageiq里面azure的获取镜像信息，manageiq里面 auzre provider 获取镜像是从 存储账户中获得镜像信息，不是获得共有的镜像。2.共有的镜像信息很多，在这里存储后可以快速找到自己想要的镜像信息。 需要提前准备的事情 1.在共有镜像中要到需要的镜像，使用此镜像创建一个最小的资源的（花钱最少），镜像生成后这个虚拟机就不能使用了，需要释放掉。2.powershell 软件已经安装好了，如果没有安装好，安装教程：https://www.azure.cn/documentation/articles/powershell-install-configure/3.目前的操作是基于微软中国区的操作，门户预览：https://portal.azure.cn ，本文当的操作是在2017-02-13之前操作的。 生成的私有镜像在存储账户中 2. 开始生成私有镜像 1.创建虚拟机后关机https://portal.azure.cn， 打开这个网站后选择虚拟机(Virtual machines) -> 新加一个虚拟机(add) -> 选择需要的镜像后下一步(create)，配置好CPU，内存大小，等资源信息后，生成虚拟机，稍等一会，虚拟机生成成功后，进入这个虚拟机中，选择停止这个虚拟机。 2.通用化对一台ARM的windows虚拟机执行sysprep【linux waagent -deprovision】，成功配置后，从管理门户关机以便释放资源windows虚拟机初始化教程： https://www.azure.cn/documentation/articles/virtual-machines-windows-generalize-vhd/linux虚拟机初始化： 1.azure.cn打开这个虚拟机，然后点击连接会出来一个ssh连接 终端开大连接进去 $ sudo su - $ waagent -deprovision 3.powershell login azure $ powershell PS C:\\Users\\kyxxx> Login-AzureRmAccount -EnvironmentName AzureChinaCloud # 输入帐号密码后会显示下面信息 Environment : AzureChinaCloud Account : admin@xxxxxp.xxxxxx.onmschina.cn TenantId : exxxxxxd-xxx8-4xxx-xxx0-xxxxxxxxxx48 SubscriptionId : 4xxxxxxa-xxx8-4xxx-xxxc-xxxxxxxxxx48 SubscriptionName : Windows Azure 企业 CurrentStorageAccount : 4.对该虚拟机执行Generalized标记 # test-vm : 资源组(Resource group) # centos7ExtractIamge: 虚拟机名字(Computer name) PS C:\\Users\\kyxxx>Set-AzureRmVM -ResourceGroupName test-vm -Name centos7ExtractIamge -Generalized # 操作成功后会显示下面信息 OperationId : Status : StartTime : EndTime : Error : 执行完以上步骤，该虚拟机就无法启动了. 5.开始生成镜像 PS C:\\Users\\kyxxx> Save-AzureRmVMImage -ResourceGroupName test-vm -VMName centos7ExtractIamge -DestinationContainerName \"imagetest\" -VHDNamePrefix \"centos7.2\" # test-vm : 资源组(Resource group) # centos7ExtractIamge: 虚拟机名字(Computer name) # \"imagetest\" : 目标容器名字，这个在生成镜像的.json文件里面有显示 # \"centos7.2\" : VHD名字前缀 centos7.2-osDisk.feb1809f-ff7d-42cc-861b-baa6c090c77e.vhd # \"image\": { # \"uri\": #\"https://testvmdisks334.blob.core.chinacloudapi.cn/system/Microsoft.Compute/Images/imagetest/ # centos7.2-osDisk.feb1809f-ff7d-42cc-861b-baa6c090c77e.vhd\" # }, # 操作成功后会显示下面信息 OperationId : Status : Succeeded StartTime : 2017/2/8 星期三 16:36:33 EndTime : 2017/2/8 星期三 16:36:33 Error : 6.删除虚拟机，然后跑路 3. 通过私有镜像来创建虚拟机 下面没有实际操作，有问题找微软客服。 执行完以上操作后，源虚拟机使用的存储账号中出现一下container，里面包含操作系统vhd文件及json文件【可用于后期部署，该json文件中没有对nic的定义。后期需要进行定义】 使用刚刚的json模板及镜像vhd文件进行创建，并且成功创建 后期对json文件中的以下信息进行修改，再通过该镜像成功创建第二台虚拟机 \"vhd\": { \"uri\": \"https://jackrmdisks943.blob.core.chinacloudapi.cn/vmcontainerdce4465c-1f58-4159-a405-d43b751b566d/osDisk.dce4465c-test.vhd\" }, powered by Gitbook文件最后修改时间： 2021-03-12 09:05:16 "},"doc/面试题/001-js.html":{"url":"doc/面试题/001-js.html","title":"JS","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. 浏览器输入url到页面最后呈现 有哪些过程？ 2. 浏览器渲染页面流程 3. ES6新特性 4. 手写函数防抖和函数节流 4.1 函数防抖 4.2 函数节流 5. 这段代码里的 this 是什么？ 6. 数组去重 7. 实现继承 8. typeof和instanceof区别 9. 对象的深拷贝方法实现 10. 手动实现一个new方法 11. 箭头函数和普通函数区别，箭头函数可以当构造函数用吗？ [TOC] 1. 浏览器输入url到页面最后呈现 有哪些过程？ 用户输入URL地址 浏览器解析URL解析出主机名 浏览器将主机名转换成服务器ip地址（浏览器先查找本地DNS缓存列表 没有的话 再向浏览器默认的DNS服务器发送查询请求 同时缓存） 浏览器将端口号从URL中解析出来 浏览器建立一条与目标Web服务器的TCP连接（三次握手） 浏览器向服务器发送一条HTTP请求报文 服务器向浏览器返回一条HTTP响应报文 关闭连接 浏览器解析文档 如果文档中有资源 重复6 7 8 动作 直至资源全部加载完毕 2. 浏览器渲染页面流程 解析HTML生成DOM树。 解析CSS生成CSSOM规则树。 将DOM树与CSSOM规则树合并在一起生成渲染树。 遍历渲染树开始布局，计算每个节点的位置大小信息。 将渲染树每个节点绘制到屏幕。 https://segmentfault.com/a/1190000010298038 https://juejin.im/post/5a8e242c5188257a6b060000 3. ES6新特性 https://fangyinghang.com/es-6-tutorials/ 1、作用域：块级作用域、let、const： 块作用域： var a = 1; { var a = 3; } console.log(a) // 1 2、箭头函数 sum = (a, b) => a + b nums.forEach( v => { console.log(v) }) 词法 this 3、参数处理 默认参数值 function multiply(a, b = 1) { return a * b; } 剩余参数：允许我们将一个不定数量的参数表示为一个数组 function sum(...theArgs) { return theArgs.reduce((previous, current) => { return previous + current; }); } console.log(sum(1, 2, 3)); // expected output: 6 展开运算符：将数组表达式或者string在语法层面展开 function sum(x, y, z) { return x + y + z; } const numbers = [1, 2, 3]; console.log(sum(...numbers)); // expected output: 6 4、模板字面量 多行字符串 console.log(`string text line 1 string text line 2`); 插入表达式 var a = 5; var b = 10; console.log('Fifteen is ' + (a + b) + ' and\\nnot ' + (2 * a + b) + '.'); // \"Fifteen is 15 and // not 20.\" 4. 手写函数防抖和函数节流 防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（参数wait）调用函数。 4.1 函数防抖 防抖（用户停止点击后才执行）： // 创建一个防抖函数，它返回一个新的函数，该新函数在指定的 time 时间后执行 fn function debounce(fn, time = 1000) { let timerId = null; // 保存定时器的引用 return function(...args) { const context = this; // 保存当前的 this 上下文 if (timerId) clearTimeout(timerId); timerId = setTimeout(() => { fn.apply(context, args); }, time); }; } const debounced = debounce(()=>console.log('hi')) debounced() debounced() 4.2 函数节流 节流（函数执行一次后，有冷却时间）： function throttle(fn, delay){ let canUse = true // 设置一个开关，执行一次后，一段时间后再打开 return function(...args){ const context = this; // 保存当前的 this 上下文 if(canUse){ fn.apply(context, args) canUse = false setTimeout(()=>{canUse = true}, delay) } } } const throttled = throttle(()=>console.log('hi')) throttled() throttled() 5. 这段代码里的 this 是什么？ fn() this => window/global， 函数里的this就是外面的this obj.fn() this => obj fn.call(xx) this => xx fn.apply(xx) this => xx fn.bind(xx) this => xx new Fn() this => 新的对象 fn = ()=> {} this => 外面的 this 关于this的具体讲解：https://zhuanlan.zhihu.com/p/23804247 6. 数组去重 数组的indexOf：返回给定元素在数组中第一次出现的位置的角标，如果没有出现则返回-1 1、利用indexOf去查找新数组是否没有这个值，遍历数组法： var arr = [2, 2, 3, 4, 5, 3, 5, 7]; for (var i = 0, newArr = [], len = arr.length; i 2、数组下标判断法： var arr = [7, 7, 7, 7, 2, 2, 3, 4, 5, 3, 5, 7]; var newArr = [] for (var i = 0; i 3、ES6简化版： var arr = [2, 2, 3, 4, 5, 3, 5, 7, 7, 7, 7, 8, 8]; var newArr = [...new Set(arr)]; console.log(newArr); var newArr = Array.from(new Set(arr)); console.log(newArr); 4、利用对象的属性不会重复这一特性，首先创建一个空对象，然后用 for 循环遍历，来校验数组元素是否重复。 var arr = [7, 7, 7, 7, 2, 2, 3, 4, 5, 3, 5, 7]; var newArr = [] var obj = {} for (var i = 0; i 数组是对象，根据对象某个属性去重 var arr = [{name: 'jack'}, {name: 'jack'}, {name: 'tom'}, {name: 'tom'}] var newArr = [] arr.forEach((item) => { if (newArr.every(e => e.name !== item.name)) { newArr.push(item) } }) console.log('newArr: ', newArr) 7. 实现继承 原型：每个构造函数都有一个prototype属性，这个属性指向一个对象，这个对象称为原型对象。 原型链：由于原型对象也是对象，所以原型对象也有自己的原型对象，因此形成了原型链，而所有对象原型链最终都会指向Object的原型。 原型对象的constuctor属性：默认指向prototype对象所在的构造函数。 constuctor作用：1、可以知道实例对象是哪一个构造函数创建的。2、可以通过实例对象的constructor属性新建另一个实例对象。 ES5继承分成两步实现： 第一步、是在子类的构造函数中，调用父类的构造函数。目的是让子类实例继承父类实例的属性和方法。 第二步、是让子类的原型指向父类的原型，目的是让子类继承父类原型上的属性和方法。 注意：不能让子类的原型直接等于父类原型，如果这样做那么子类原型和父类原型是同一个对象，那么子类在原型上添加方法，父类原型也修改了，导致父类对象也能获取到这个方法。 function Animal(color){ this.color = color } Animal.prototype.move = function(){} // 第一步：子类构造函数调用父类构造函数 function Dog(color, name){ Animal.call(this, color) // 或者 Animal.apply(this, arguments) this.name = name } // 第二步：子类的原型指向父类的原型。Dog.prototype = Animal.prototype function f(){} f.prototye = Animal.prototype Dog.prototype = new f() Dog.prototype.constuctor = Dog Dog.prototype.say = function(){ console.log('汪')} var dog = new Dog('黄色','阿黄'); ES6实现： class Animal{ constructor(color){ this.color = color } move(){} } class Dog extends Animal{ constructor(color, name){ super(color) this.name = name } say(){} } 8. typeof和instanceof区别 关于typeof typeof一元运算符，用来获取一个变量或者表达式的类型，typeof一般只能返回如下几个结果： number,boolean,string,function（函数）,object（NULL,数组，对象）,undefined。 var a = [34,4,3,54], b = 34, c = 'adsfas', d = function(){console.log('我是函数')}, e = true, f = null, g; console.log(typeof(a));//object console.log(typeof(b));//number console.log(typeof(c));//string console.log(typeof(d));//function console.log(typeof(e));//boolean console.log(typeof(f));//object console.log(typeof(g));//undefined 关于instanceof 语法：object instanceof constructor 说明：instanceof 运算符用来检测 constructor.prototype是否存在于参数 object 的原型链上 参数说明： object：某个实例对象，如果不是对象则返回false constructor：某个构造函数，如果不是函数则抛出typeError https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof instance中文翻译为实例，因此instanceof判断该对象是谁的实例，同时我们也就知道instanceof是对象运算符。 这里的实例就牵扯到了对象的继承，它的判断就是根据原型链进行搜寻，在对象obj1的原型链上如果存在另一个对象obj2的原型属性，那么表达式（obj1 instanceof obj2）返回值为true；否则返回false。 var a = new Array(); var b = new Object(); var c = new RegExp(); var d = function(){}; var e = new d(); var f = new String(); console.log(a instanceof Array); // true console.log(a instanceof Object); // true console.log(b instanceof Object); // true console.log(c instanceof RegExp); // true console.log(c instanceof Object); // true console.log(d instanceof Function); // true console.log(d instanceof Object); // true console.log(e instanceof d); // true console.log(f instanceof String); // true // 左边不是对象，返回false console.log('12313' instanceof String) // false // 右边不是构造函数，报错 console.log(f instanceof f) // Uncaught TypeError: Right-hand side of 'instanceof' is not an object 两者的区别： typeof判断所有变量的类型，返回值有number，boolean，string，function，object，undefined。 typeof对于丰富的对象实例，只能返回\"object\"字符串。 instanceof用来判断对象，代码形式为obj1 instanceof obj2（obj1是否是obj2的实例），obj2必须为构造函数，否则会报错！其返回值为布尔值。 instanceof可以对不同的对象实例进行判断，判断方法是根据对象的原型链依次向下查询，如果obj2的原型属性存在obj1的原型链上，（obj1 instanceof obj2）值为true。 9. 对象的深拷贝方法实现 function deepClone(obj) { var newObj = {} for (var key in obj) { // 如果是自身属性 if (Object.hasOwnProperty.call(obj, key)) { if (Array.isArray(obj[key])) { // 判断是数组，需要单独处理 newObj[key] = obj[key].concat() } else if (typeof obj[key] === 'object') { // 属性是对象，提柜调用 newObj[key] = deepClone(obj[key]) } else { // 原始值和函数直接复制 newObj[key] = obj[key] } } } return newObj } var obj = { func: function() { console.log('hello') }, arr: [1, 2, 3, 4, 5], subObj: { name: 'jack', }, age: 12, } var newObj = deppClone(obj) console.log('newObj: ', newObj) 10. 手动实现一个new方法 在《JavaScript模式》这本书中，new的过程说的比较直白，当我们new一个构造器，主要有三步： 1、创建一个空对象，将它的引用赋给 this，继承函数的原型。2、通过 this 将属性和方法添加至这个对象3、最后返回 this 指向的新对象，也就是实例（如果没有手动返回其他的对象） 所以实现一个new分以下几步： 1、创建一个空对象。 2、将空对象的原型设置成构造函数的原型。 3、使用call方法执行构造函数绑定空对象，初始化这个对象。 4、返回这个新建对象 function createNewObj(func) { // 创建一个空的对象 var obj = {} // 设置空对象的原型，指向构造函数的原型链 Object.SetPrototypeOf(obj, func.prototype) // 或者： obj.__proto__ = func.prototype // 执行构造函数使用call方法绑定空对象，初始化这个对象。 func.call(obj) // 返回这个新建对象 return obj } 11. 箭头函数和普通函数区别，箭头函数可以当构造函数用吗？ 区别： 1、写法不同，箭头函数使用箭头定义，写法简洁。 普通函数使用function定义。 2、箭头函数都是匿名函数，而普通函数既可以是匿名函数，也可以是具名函数。 3、this指向不同，箭头函数没有this，在声明的时候，捕获上下文的this供自己使用，一旦确定不会再变化。在普通函数中，this指向调用自己的对象，如果用在构造函数，this指向创建的对象实例。普通函数可以使用call，apply，bind改变this的指向。 4、箭头函数没有arguments（实参列表，类数组对象），每一个普通函数在调用后都有一个arguments对象，用来存储实际传递的参数。 5、箭头函数不能作为构造函数来使用，普通函数可以用作构造函数，一次来创建一个对象的实例。 6、箭头函数没有原型，而普通函数有。 箭头函数不能当构造函数使用new原因： 1、箭头函数没有原型prototype，new方法需要函数有原型指向创建的对象。 2、箭头函数没有this，new方法需要函数内部this指向新建的对象，然后设置新对象 更多内容： https://blog.csdn.net/weixin_43288600/article/details/135197555 powered by Gitbook文件最后修改时间： 2024-08-15 12:00:18 "},"doc/面试题/002-css.html":{"url":"doc/面试题/002-css.html","title":"CSS","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 CSS部分 1. IE盒模型和标准盒模型 2. px、em、rem区别 3. 实现左、中、右三列布局 [TOC] CSS部分 1. IE盒模型和标准盒模型 可使用CSS属性来切换IE盒模型和标准盒模型： box-sizing:border-box || content-box || inherit 当使用content-box时：页面将采用标准模式来解析计算，content-box也是默认模式 当使用border-box时，页面将采用怪异模式解析计算，怪异模式也称为IE模式 当使用inherit时：页面将从父元素继承box-sizing的值 参考资料：https://www.jianshu.com/p/cc2bc404269b 2. px、em、rem区别 px是固定的像素，一旦设置了就无法因为适应页面大小而改变。 em和rem相对于px更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局。 对于em和rem的区别一句话概括：em相对于父元素，rem相对于根元素。 chrome设置的最小字体大小为12px，意思就是说低于12px的字体大小会被默认为12px，当然这一尬境可以由css3解决，这里就不多说了。 em 子元素字体大小的em是相对于父元素字体大小 元素的width/height/padding/margin用em的话是相对于该元素的font-size rem rem是全部的长度都相对于根元素，根元素是谁？元素。通常做法是给html元素设置一个字体大小，然后其他元素的长度单位就为rem。 3. 实现左、中、右三列布局 实现一个左、中、右三列布局，两边宽度固定，中间自适应 使用绝对定位： .father { position: relative; height: 400px; } .father > div { border: 1px solid; position: absolute; height: 100%; top: 0; } .son1 { left: 0; width: 200px; } .son2 { left: 200px; right: 200px; background-color: rgba(33, 33, 186, 0.2); } .son3 { right: 0; width: 200px; } 左边 中间中间中间中中间 右边 使用float: .father { height: 400px; } .father > div { border: 1px solid; height: 100%; box-sizing: border-box; } .son1 { float: left; width: 200px; } .son2 { background-color: rgba(33, 33, 186, 0.2); margin: 0 200px; } .son3 { float: right; width: 200px; } 左边 右边 中间中间中间中中间 参考资料：css中单位em和rem的区别 powered by Gitbook文件最后修改时间： 2020-04-24 15:05:49 "},"doc/面试题/003-面试问过的问题.html":{"url":"doc/面试题/003-面试问过的问题.html","title":"问过的问题","keywords":"","body":" webpack打包工具如何只打包代码用到的包。 问了一些后端数据库知识。 什么情况下页面会重绘？ 如何设置页面缓存？ 前端跨页面通信，你知道哪些方法？面试官提到了Service Worker 什么是跨域，工作中如何实现跨域。 ES6新增的异步方法有哪些。 浏览器输入url到页面最后呈现 有哪些过程？ 浏览器发一个请求前会做什么？option方法 HTTP状态码有哪些？ 2020: 自己实现一个Promise 箭头函数和普通函数区别 react中setState什么时候同步执行，什么时候异步执行 CSS中隐藏元素样式的display:none, visibility:hidden, opacity: 0 区别 JS事件循环，宏任务、微任务优先级 对象的深拷贝的实现 typeof和instanceof区别 this说一下 普通函数和箭头函数区别？ powered by Gitbook文件最后修改时间： 2020-04-21 15:53:53 "},"doc/面试题/004-JavaScript中各种源码实现.html":{"url":"doc/面试题/004-JavaScript中各种源码实现.html","title":"JavaScript中各种源码实现","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 JavaScript中各种源码实现 1. 实现一个new操作符 2. 实现一个Array.isArray 3. 实现一个Object.create()方法 4. 实现一个EventEmitter 5. 实现一个Array.prototype.reduce 6. 实现一个call或apply 7. 实现一个Function.prototype.bind 8. 实现一个JS函数柯里化 9. 手写防抖(Debouncing)和节流(Throttling) 9.1 防抖 9.2节流 10. 手写一个JS深拷贝 11. 实现一个instanceOf 12.实现原型链继承 13. 实现一个async/await 14. 实现一个Array.prototype.flat()函数 15. 实现一个事件代理 16. 实现一个双向绑定 17. 实现一个Array.prototype.map() 参考资料 [TOC] JavaScript中各种源码实现 本文转载整理自：https://zhuanlan.zhihu.com/p/108289604 1. 实现一个new操作符 我们首先知道new做了什么： 创建一个空的简单JavaScript对象（即{}）； 链接该对象（即设置该对象的构造函数）到另一个对象 ； 将步骤（1）新创建的对象作为this的上下文 ； 如果该函数没有返回对象，则返回this。 知道new做了什么，接下来我们就来实现它 function create(Con, ...args){ // 创建一个空的对象 this.obj = {}; // 将空对象指向构造函数的原型链 Object.setPrototypeOf(this.obj, Con.prototype); // obj绑定到构造函数上，便可以访问构造函数中的属性，即this.obj.Con(args) let result = Con.apply(this.obj, args); // 如果返回的result是一个对象则返回 // new方法失效，否则返回obj return result instanceof Object ? result : this.obj; } 2. 实现一个Array.isArray 思路很简单，就是利用Object.prototype.toString Array.myIsArray = function(o) { return Object.prototype.toString.call(Object(o)) === '[object Array]'; }; 3. 实现一个Object.create()方法 function create = function (o) { var F = function () {}; F.prototype = o; return new F(); }; 4. 实现一个EventEmitter 真实经历，最近在字节跳动的面试中就被面试官问到了，让我手写实现一个简单的Event类。 class Event { constructor () { // 储存事件的数据结构 // 为查找迅速， 使用对象（字典） this._cache = {} } // 绑定 on(type, callback) { // 为了按类查找方便和节省空间 // 将同一类型事件放到一个数组中 // 这里的数组是队列， 遵循先进先出 // 即新绑定的事件先触发 let fns = (this._cache[type] = this._cache[type] || []) if(fns.indexOf(callback) === -1) { fns.push(callback) } return this } // 解绑 off (type, callback) { let fns = this._cache[type] if(Array.isArray(fns)) { if(callback) { let index = fns.indexOf(callback) if(index !== -1) { fns.splice(index, 1) } } else { // 全部清空 fns.length = 0 } } return this } // 触发emit trigger(type, data) { let fns = this._cache[type] if(Array.isArray(fns)) { fns.forEach((fn) => { fn(data) }) } return this } // 一次性绑定 once(type, callback) { let wrapFun = () => { callback.call(this); this.off(type, callback); }; this.on(wrapFun, callback); return this; } } let e = new Event() e.on('click',function(){ console.log('on') }) // e.trigger('click', '666') console.log(e) 5. 实现一个Array.prototype.reduce 首先观察一下Array.prototype.reduce语法 Array.prototype.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue]) 然后就可以动手实现了： Array.prototype.myReduce = function(callback, initialValue) { let accumulator = initialValue ? initialValue : this[0]; for (let i = initialValue ? 0 : 1; i { acc += val; return acc; }, 5); console.log(sum); // 15 6. 实现一个call或apply 先来看一个call实例，看看call到底做了什么： let foo = { value: 1 }; function bar() { console.log(this.value); } bar.call(foo); // 1 从代码的执行结果，我们可以看到，call首先改变了this的指向，使函数的this指向了foo,然后使bar函数执行了。 总结一下： call改变函数this指向 调用函数 思考一下：我们如何实现上面的效果呢？代码改造如下： Function.prototype.myCall = function(context) { context = context || window; //将函数挂载到对象的fn属性上 context.fn = this; //处理传入的参数 const args = [...arguments].slice(1); //通过对象的属性调用该方法 const result = context.fn(...args); //删除该属性 delete context.fn; return result }; 我们看一下上面的代码： 首先我们对参数context做了兼容处理，不传值，context默认值为window； 然后我们将函数挂载到context上面,context.fn = this； 处理参数，将传入myCall的参数截取，去除第一位，然后转为数组； 调用context.fn，此时fn的this指向context； 删除对象上的属性 delete context.fn； 将结果返回。 以此类推，我们顺便实现一下apply，唯一不同的是参数的处理,代码如下： Function.prototype.myApply = function(context) { context = context || window context.fn = this let result // myApply的参数形式为(obj,[arg1,arg2,arg3]); // 所以myApply的第二个参数为[arg1,arg2,arg3] // 这里我们用扩展运算符来处理一下参数的传入方式 if (arguments[1]) { result = context.fn(…arguments[1]) } else { result = context.fn() } delete context.fn; return result }; 以上便是call和apply的模拟实现，唯一不同的是对参数的处理方式。 7. 实现一个Function.prototype.bind function Person(){ this.name=\"zs\"; this.age=18; this.gender=\"男\" } let obj={ hobby:\"看书\" } // 将构造函数的this绑定为obj let changePerson = Person.bind(obj); // 直接调用构造函数,函数会操作obj对象,给其添加三个属性; changePerson(); // 1、输出obj console.log(obj); // 用改变了this指向的构造函数,new一个实例出来 let p = new changePerson(); // 2、输出obj console.log(p); 仔细观察上面的代码，再看输出结果。 我们对Person类使用了bind将其this指向obj，得到了changeperson函数，此处如果我们直接调用changeperson会改变obj，若用new调用changeperson会得到实例 p,并且其proto指向Person,我们发现bind失效了。 我们得到结论：用bind改变了this指向的函数，如果用new操作符来调用，bind将会失效。 这个对象就是这个构造函数的实例，那么只要在函数内部执行 this instanceof 构造函数 来判断其结果是否为true，就能判断函数是否是通过new操作符来调用了，若结果为true则是用new操作符调用的，代码修正如下： // bind实现 Function.prototype.mybind = function(){ // 1、保存函数 let _this = this; // 2、保存目标对象 let context = arguments[0]||window; // 3、保存目标对象之外的参数,将其转化为数组; let rest = Array.prototype.slice.call(arguments,1); // 4、返回一个待执行的函数 return function F(){ // 5、将二次传递的参数转化为数组; let rest2 = Array.prototype.slice.call(arguments) if(this instanceof F){ // 6、若是用new操作符调用,则直接用new 调用原函数,并用扩展运算符传递参数 return new _this(...rest2) }else{ //7、用apply调用第一步保存的函数，并绑定this，传递合并的参数数组，即context._this(rest.concat(rest2)) _this.apply(context,rest.concat(rest2)); } } }; 8. 实现一个JS函数柯里化 Currying的概念其实并不复杂，用通俗易懂的话说：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。 function progressCurrying(fn, args) { let _this = this let len = fn.length; let args = args || []; return function() { let _args = Array.prototype.slice.call(arguments); Array.prototype.push.apply(args, _args); // 如果参数个数小于最初的fn.length，则递归调用，继续收集参数 if (_args.length 9. 手写防抖(Debouncing)和节流(Throttling) 9.1 防抖 防抖函数 onscroll 结束时触发一次，延迟执行 function debounce(func, wait) { let timeout; return function() { let context = this; // 指向全局 let args = arguments; if (timeout) { clearTimeout(timeout); } timeout = setTimeout(() => { func.apply(context, args); // context.func(args) }, wait); }; } // 使用 window.onscroll = debounce(function() { console.log('debounce'); }, 1000); 9.2节流 节流函数 onscroll 时，每隔一段时间触发一次，像水滴一样 function throttle(fn, delay) { let prevTime = Date.now(); return function() { let curTime = Date.now(); if (curTime - prevTime > delay) { fn.apply(this, arguments); prevTime = curTime; } }; } // 使用 var throtteScroll = throttle(function() { console.log('throtte'); }, 1000); window.onscroll = throtteScroll; 10. 手写一个JS深拷贝 乞丐版 JSON.parse(JSON.stringfy)); 非常简单，但缺陷也很明显，比如拷贝其他引用类型、拷贝函数、循环引用等情况。 基础版 function clone(target){ if(typeof target === 'object'){ let cloneTarget = {}; for(const key in target){ cloneTarget[key] = clone(target[key]) } return cloneTarget; } else { return target } } 写到这里已经可以帮助你应付一些面试官考察你的递归解决问题的能力。但是显然，这个深拷贝函数还是有一些问题。 一个比较完整的深拷贝函数，需要同时考虑对象和数组，考虑循环引用： function clone(target, map = new WeakMap()) { if(typeof target === 'object'){ let cloneTarget = Array.isArray(target) ? [] : {}; if(map.get(target)) { return target; } map.set(target, cloneTarget); for(const key in target) { cloneTarget[key] = clone(target[key], map) } return cloneTarget; } else { return target; } } 11. 实现一个instanceOf 原理： L.proto 是不是等于 R.prototype，不等于再找 L.proto.proto 直到 proto 为 null // L 表示左表达式，R 表示右表达式 function instance_of(L, R) { var O = R.prototype; L = L.__proto__; while (true) { if (L === null){ return false; } // 这里重点：当 O 严格等于 L 时，返回 true if (O === L) { return true; } L = L.__proto__; } } 12.实现原型链继承 function myExtend(C, P) { var F = function(){}; F.prototype = P.prototype; C.prototype = new F(); C.prototype.constructor = C; C.super = P.prototype; } 13. 实现一个async/await 原理 就是利用 generator（生成器）分割代码片段。然后我们使用一个函数让其自迭代，每一个yield 用 promise 包裹起来。执行下一步的时机由 promise 来控制 实现 function _asyncToGenerator(fn) { return function() { var self = this, args = arguments; // 将返回值promise化 return new Promise(function(resolve, reject) { // 获取迭代器实例 var gen = fn.apply(self, args); // 执行下一步 function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'next', value); } // 抛出异常 function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, 'throw', err); } // 第一次触发 _next(undefined); }); }; } 14. 实现一个Array.prototype.flat()函数 最近字节跳动的前端面试中也被面试官问到，要求手写实现。 Array.prototype.myFlat = function(num = 1) { if (Array.isArray(this)) { let arr = []; if (!Number(num) || Number(num) { if(Array.isArray(item)){ let count = num arr = arr.concat(item.myFlat(--count)) } else { arr.push(item) } }); return arr; } else { throw tihs + \".flat is not a function\"; } }; 15. 实现一个事件代理 这个问题一般还会让你讲一讲事件冒泡和事件捕获机制 red yellow blue green black white (function () { var color_list = document.getElementById('color-list'); color_list.addEventListener('click', showColor, true); function showColor(e) { var x = e.target; if (x.nodeName.toLowerCase() === 'li') { alert(x.innerHTML); } } })(); 16. 实现一个双向绑定 Vue 2.x的Object.defineProperty版本 // 数据 const data = { text: 'default' }; const input = document.getElementById('input'); const span = document.getElementById('span'); // 数据劫持 Object.defineProperty(data, 'text', { // 数据变化 —> 修改视图 set(newVal) { input.value = newVal; span.innerHTML = newVal; } }); // 视图更改 --> 数据变化 input.addEventListener('keyup', function(e) { data.text = e.target.value; }); Vue 3.x的proxy 版本 // 数据 const data = { text: 'default' }; const input = document.getElementById('input'); const span = document.getElementById('span'); // 数据劫持 const handler = { set(target, key, value) { target[key] = value; // 数据变化 —> 修改视图 input.value = value; span.innerHTML = value; return value; } }; const proxy = new Proxy(data, handler); // 视图更改 --> 数据变化 input.addEventListener('keyup', function(e) { proxy.text = e.target.value; }); 思考：Vue双向绑定的实现，使用 ES6 的 Proxy 相比 Object.defineProperty 有什么优势？ 17. 实现一个Array.prototype.map() 先看看reduce和map的使用方法 let new_array = arr.map(function callback(currentValue[, index[,array) {}[, thisArg]) let result = arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue]) 先用for循环实现： Array.prototype.myMap = function(callback, thisArg) { let arr = []; for (let i = 0; i 再用reduce实现 Array.prototype.myMap2 = function(callback, thisArg) { let result = this.reduce((accumulator, currentValue, index, array) => { accumulator.push(callback.call(thisArg, currentValue, index, array)); return accumulator; }, []); return result; }; 参考资料 JavaScript中各种源码实现 powered by Gitbook文件最后修改时间： 2020-04-20 22:53:36 "},"doc/面试题/005-面试资料.html":{"url":"doc/面试题/005-面试资料.html","title":"面试资料整理","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 1. JS部分 2. CSS部分 [TOC] 1. JS部分 【吐血整理】前端面试全攻略，为您保驾护航，🤑金三银四🤑不在话下 下面是上面整理出来的： 看完这几道 JavaScript 面试题，让你与考官对答如流（下） 7个简单但棘手的JavaScript面试问题 2. CSS部分 104道 CSS 面试题，助你查漏补缺 powered by Gitbook文件最后修改时间： 2020-04-23 21:39:11 "},"doc/面试题/006-JS答过的笔试题.html":{"url":"doc/面试题/006-JS答过的笔试题.html","title":"JS答过的笔试题","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 答过的笔试题 1. 写出打印的值 1.1 变量定义提升 1.2 箭头函数绑定问题 1.3 var变量for循环输出问题 1.4 async异步函数问题 1.5 setTimeout和async 1.6 let变量不会绑定到window上 2. 写出几个vue或react常用的声明周期狗子函数 3. 写一个递归方法，把数组[1,2,[3,[4,5],6],7]，变成一维数组[1,2,3,4,5,6,7] 4. 字符串相邻字符去重aaabbdebb=abdeb 5. get1by2list334android7删除偶数和`` 6.不用循环语句和迭代器实现0到1000数组赋值 7. JSON格式的树状结构生成一个dom树 8. ['1', '2', '3'].map(parseInt)结果是啥？为什么？ [TOC] 答过的笔试题 1. 写出打印的值 1.1 变量定义提升 console.log(a); // 1 function a() {} var a = 5; function b() { console.log(a); // 2 var a = 3; console.log(a); // 3 } b(); // 输出结果： // function a() {} // undefined // 3 1、第一个console：全局中，函数声明会提升，变量定义会提升，当发现一个变量已经定义后，便不在提升，所以第一个输出了函数定义。 2、在函数内部，变量定义也会提升到函数内部的顶部，此时的值还是undefined，由于函数内部已经定义变量a，便不会去全局对象中查找，所以输出undefined。 3、变量a已经赋值为3，所以输出3 1.2 箭头函数绑定问题 var c = (v) => { console.log(this.name) console.log(v) } var d = {name: 1} c.call(d, 2) // 输出结果： // undefined // node里面输出是undefined， Chrome终端里面输出的是空 // 2 1.3 var变量for循环输出问题 for(var i = 0; i 上面代码修改成输出1 2 3 4 5 第一个解决办法：在for循环里面定义一个临时变量，然后打印这个临时变量。 for(var i = 0; i 第二种解决办法：setTimeout方法使用立即执行函数包裹上，传一个变量 for(var i = 0; i 如果代码最后一行不用输出i，for循环中定义的i使用let来声明，可以实现循环打印1到0. 1.4 async异步函数问题 async function async1() { console.log('1') await async2() console.log('2') } async function async2() { console.log('3') } console.log('4') setTimeout(() => { console.log('5') },0) async1() new Promise((resolve) => { console.log('6') resolve() }).then(() => { console.log('7') }) console.log('8') // 输出结果： // 4、1、3、6、8、2、7、5 执行过程： 第一步：执行同步：1、输出4、setTimeout回调放入回调队列，2、执行async1()，输出1，执行async2()，输出3，返回一个Promise，async1()函数的await处处于Promise的then，放入回调队列等待执行。3、执行new Promise输出6，then放入回调队列。执行console.log('8')，输出8。总体输出：4、1、3、6、8 第二步：开始去回调队列执行可执行的回调： 是否有可执行的微任务(主要是Promise)，有的话取出所有微任务执行，发现有2个，执行async1()中的微任务输出2，执行new Promise()回调，输出7。没有可执行的微任务了，结束微任务。 取出一个宏任务，发现有一个setTimeout，取出执行，输出5. 1.5 setTimeout和async console.log(1) setTimeout(() => {console.log('2')},1000) // 第一个setTimeout回调 async function fn() { console.log('3'); setTimeout(() => {console.log('4')},20) // 第二个setTimeout回调 } async function run() { console.log('5'); await fn() console.log('6'); } run() var time = (new Date()).getTime() // 等待150毫秒 while(true) { if (time + 150 { // 三个setTimeout回调 console.log('7'); new Promise((resolve) => { console.log('8') resolve() }).then(() => { console.log('9') }) },0) console.log('10') // 输出结果： // 1、5、3、10、6、4、7、8、9、2 执行过程： 1、执行一个宏任务(同步任务): 执行console输出1，执行run()异步函数，执行console输出5，执行函数fn()，执行console输出3，一个setTimeout放入回调队列，fn()函数执行完毕，await等待到一个Promise回调，放入到回调队列，run()执行完毕，等待状态。while循环，消耗了150毫秒，接着执行，遇到一个setTimeout放到回调队列，执行console输出10. 第一个宏任务执行结束，输出：1、5、3、10。此时回调队列有3个setTimeout回调。 2、查看是否有微任务可执行，经查找，没有，忽略。 3、执行一个宏任务，有一个setTimeout可执行，执行console输出4。 4、查看是否有微任务，没有，执行一个宏任务，发现有一个可执行的，执行：执行console输出7，执行new Promise,执行console输出8，一个微任务放到回调队列。 5、查看是否有微任务可执行，经查找有一个可以执行，执行微任务：执行console输出9。 6、执行一个宏任务，有一个可以执行了，执行console输出2. 7、执行结束。 1.6 let变量不会绑定到window上 let obj = { foo: function() { console.log(this.bar) }, bar: 1 } let foo = obj.foo; let bar = 2; obj.foo() // 1 foo() // undefined 由于foo方法中输出this.bar，全局中，使用let声明的bar不会绑定到window上面，所以单独调用foo方法中，输出undefined。 2. 写出几个vue或react常用的声明周期狗子函数 挂载阶段 constructor：初始化构造函数 static getDerivedStateFromProps：调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用 render()：渲染的html元素，react类组件唯一必须实现的方法 componentDidMount()：会在组件挂载后（插入 DOM 树中）立即调用 更新阶段 getDerivedStateFromProps()：上面有说明 shouldComponentUpdate()：props或state变化，render()渲染之前调用，返回默认true(需要渲染页面) render()：上面有说明 getSnapshotBeforeUpdate()：在render()之后，渲染输出(提交到DOM节点)之前调用 componentDidUpdate()： 更新后调用，首次渲染不会执行此方法 卸载阶段 componentWillUnmount()：组件卸载及销毁之前直接调用 3. 写一个递归方法，把数组[1,2,[3,[4,5],6],7]，变成一维数组[1,2,3,4,5,6,7] function func(arr) { var newArr = [] for(var i = 0; i 4. 字符串相邻字符去重aaabbdebb=>abdeb 给一个字符串，把字符串中相邻重复的字符去掉，比如aaabbdebb 变成abdeb var str = 'aaabbdebb' function deleteRepeat(str) { var newStr = str[0] var tmp = str[0] for (var i = 1; i 5. get1_by2_list334_android7删除偶数和_ 给一个字符串：get1_by2_list334_android7(每个单词后偶棉携带一个数字)，删除其中偶数和_，不用不用循环，只用正则，如何实现输出get1bylistandroid7 var str = 'get1_by2_list334_android7'; var result = str.replace(/(\\d*[02468])*_*/g, '') console.log(result); 6.不用循环语句和迭代器实现0到1000数组赋值 不使用任何循环控制语句和迭代器的情况下，实现一个0到1000的数组赋值。 var i = 0; var arr = []; function fn() { arr[i] = i i++; if (i > 1000) { clearInterval(id) console.log(arr) } } var id = setInterval (fn, 0); 7. JSON格式的树状结构生成一个dom树 将类似以下JSON表示的树状结构（可以无限层级）通过parseDOM函数（使用document.createElement，document.createTextNode，appendChild等方法）生成一颗DOM树（返回一个element元素） const jsonTree = { \"tagName\": \"ul\", \"props\": { \"className\": \"list\", \"data-name\": \"jsontree\" }, \"children\": [{ \"tagName\": \"li\", \"children\": [{ \"tagName\": \"img\", \"props\": { \"src\": \"//img.alicdn.com/tps/TB1HwXxLpXXXXchapXXXXXXXXXX-32-32.ico\", \"width\": \"16px\" } }] }, { \"tagName\": \"li\", \"children\": [{ \"tagName\": \"a\", \"props\": { \"href\": \"https://www.aliyun.com\", \"target\": \"_blank\" }, \"children\": \"阿里云\" }] } ] }; function parseDOM(jsontree){ const {tagName,props,children} = jsontree; const element = document.createElement(tagName); // 添加属性 if (typeof props === 'object') { for (var key in props) { element.setAttribute(key, props[key]); } } // 添加子元素 if (children) { if (typeof children === 'string') { element.innerHTML = children; } else if (Array.isArray(children)) { children.forEach(function(e) { element.appendChild(parseDOM(e)) }) } } return element; } var one = document.getElementById('one'); one.appendChild(parseDOM(jsonTree)); http://js.jirengu.com/juyeki/edit?html,js,output 8. ['1', '2', '3'].map(parseInt)结果是啥？为什么？ 此面试题考察的内容：1、对于数组map函数的理解以及使用。2、对于parseInt的转换规则是否理解。 数组的map方法接受一个函数作为参数。该函数调用时，map方法向它传入三个参数：当前成员、当前位置和数组本身。 parseInt(string, radix) ：函数将其第一个参数转换为一个字符串，对该字符串进行解析，然后返回指定基数的十进制整数或 NaN。 radix 是2-36之间的整数，表示被解析字符串的基数。第二个参数可不传，默认值为10，即默认是十进制转十进制。第二个参数若传递的是0、NaN、undefined，则分两种情况： 1、若string以“0x”或“0X”开头，则默认为16进制。2、若不是第一种情况则会10进制 [“1”,“2”,“3”].map(parseInt)解析: parseInt(\"1\",0), parseInt(\"2\",1), parseInt(\"3\",2), 1、parseInt(“1”,0)由于传入的radix是0，而string非“0x”或“0X”则进制为十进制，parseInt(“1”,0)则为parseInt(“1”,10)，输出12、parseInt(“2”,1)由于radix是1，不在2-36区间，输出NaN。3、parseInt(“3”,2)的radix为2，在2-36区间，又因为在二进制中“3”是不存在的，为无效数字，输出NaN 所以最终结果： [1,NaN,NaN] powered by Gitbook文件最后修改时间： 2024-09-19 22:59:45 "},"doc/面试题/007-CSS答过的笔试题.html":{"url":"doc/面试题/007-CSS答过的笔试题.html","title":"CSS答过的笔试题","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 CSS答过的笔试题 1. 实现水平垂直居中，至少写2中方法 [TOC] CSS答过的笔试题 1. 实现水平垂直居中，至少写2中方法 transform: translate(-50%,-50%); -ms-transform: translate(-50%,-50%); 第一种，使用垂直对齐vertical-align: middle;水平对齐：text-align: center; .father { height: 300px; width: 300px; border: 1px solid; text-align: center; } .father::before { content: ''; display: inline-block; vertical-align: middle; height: 100%; } .son { vertical-align: middle; border: 1px solid; display: inline-block; } 子元素 第二种，使用绝对定位,transform: translate(-50%, -50%) .father { height: 300px; width: 300px; border: 1px solid; position: relative; } .son { border: 1px solid; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } 子元素 transform:变形，包括拉伸，压缩，旋转，偏移等等一些图形学里面的基本变换 translate：移动，第一个参数表示水平方向的移动距离，第二个参数表示垂直方向的移动距离 powered by Gitbook文件最后修改时间： 2020-04-21 18:06:03 "},"doc/面试题/008-7个简单棘手的JS问题.html":{"url":"doc/面试题/008-7个简单棘手的JS问题.html","title":"7个简单棘手的JS问题","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 7个简单但棘手的JavaScript面试问题 1. 意外全局变量 Question Answer 2.数组的length属性 Question Answer 3.鹰眼测试 Question 4.自动分号插入 Question Answer 5.经典问题：棘手的闭包 Question Answer Phase 1 Phase 2 6.浮点数计算 Question Answer 7.变量提升 Question Answer 8.最后... [TOC] 7个简单但棘手的JavaScript面试问题 本文整理、转载自：7个简单但棘手的JavaScript面试问题 1. 意外全局变量 Question 以下代码段中用于运算 typeof a 和 typeof b 的内容： function foo() { let a = b = 0; a++; return a; } foo(); typeof a; // => ??? typeof b; // => ??? Answer 让我们看一下第2行：let a = b = 0，该语句声明一个局部变量a，然儿，它也声明了全局变量b。 在 foo() 范围或全局范围中都没有声明变量b。因此JavaScript将 b = 0 表达式解释为 window.b = 0。换句话说，b是意外创建的全局变量。 在浏览器中，以上代码片段等效于： function foo() { let a; window.b = 0; a = window.b; a++; return a; } foo(); typeof a; // => 'undefined' typeof window.b; // => 'number' typeof a 等于 'undefined'，变量 a 存在于 foo() 范围内，而在外部范围内不使用。 因为b是一个值为0的全局变量，所以b的类型的值为 'number'。 2.数组的length属性 Question clothes[0] 的值是什么? const clothes = ['jacket', 't-shirt']; clothes.length = 0; clothes[0]; // => ??? Answer 数组对象的 length 属性具有特殊的行为：减少length属性的值的副作用是删除自己的数组元素。因此，当JavaScript执行 clothes.length = 0 的时候将删除所有元素。 clothes [0] 等于 undefined 的，因为 clothes 数组已被清空。 3.鹰眼测试 Question numbers 数组的内容是什么？ const length = 4; const numbers = []; for (var i = 0; i ??? 让我们仔细看一下分号 ； 出现在左大括号 {： 这个分号很容易被忽略，它创建了一个空语句。空语句是不做任何事情的空语句。 for() 在空语句上进行4次迭代（不执行任何操作），而忽略实际将项目推入数组的块：{number.push（i + 1）;}。上面的代码等效于以下代码： const length = 4; const numbers = []; var i; for (i = 0; i [5] for() 将 i 变量递增到4，然后JavaScript一次进入块 {number.push（i + 1）;}，将 4 +1 推入数字数组。 因此，numbers 数组的内容为 [5]。 4.自动分号插入 Question arrayFromValue() 返回什么值？ function arrayFromValue(item) { return [item]; } arrayFromValue(10); // => ??? Answer 很容易错过 return 关键字和 [item] 表达式之间的换行符。此换行符使JavaScript自动在 return 和 [item] 表达式之间插入分号。 这是等效的代码，在返回后插入了分号： function arrayFromValue(item) { return; [item]; } arrayFromValue(10); // => undefined return; 函数内部使其返回 undefined。因此 arrayFromValue(10) 的值为 undefined。 5.经典问题：棘手的闭包 Question 以下代码将输出什么到控制台？ let i; for (i = 0; i { console.log(i); } setTimeout(log, 100); } Answer 如果您以前从未听说过这个棘手的问题，则很可能您的答案是 0、1 和 2：这是错误的。当我第一次尝试解决它时，这也是我的答案！ 执行此代码段有两个阶段。 Phase 1 for() 重复3次，在每次迭代过程中，都会创建一个新的函数 log() 来捕获变量 i。然后 setTimout() 计划执行log()。 当 for() 循环完成时，i 变量的值为 3。 log() 是一个捕获变量 i 的闭包，该变量在 for() 循环的外部范围中定义。请务必注意，闭包可以词法捕获 i 变量。 Phase 2 第二阶段发生在100ms之后：setTimeout() 调用了3次计划的 log() 。log() 读取变量i的当前值为3，并记录到控制台3。这就是为什么控制台输出为3、3 和 3 的原因。 如果您难以理解闭包，建议阅读“ JavaScript闭包的简单说明”。 您知道如何将代码段记录为0、1和2吗？请在下面的评论中写下您的解决方案！ 6.浮点数计算 Question 这个等式的结果是什么？ 0.1 + 0.2 === 0.3 // => ??? Answer 首先，让我们看一下 0.1 + 0.2 的值： 0.1 + 0.2; // => 0.30000000000000004 0.1 和 0.2 的总和不完全是 0.3，而是略高于 0.3。 由于以二进制方式对浮点数进行编码，因此像浮点数相加之类的操作会产生舍入误差。 简而言之，直接比较浮点数并不精确。 因此 0.1 + 0.2 === 0.3 的结果是 false。 点击 0.30000000000000004.com 了解更多信息。 7.变量提升 Question 如果在声明前访问 myVar 和 myConst，会发生什么情况？ myVar; // => ??? myConst; // => ??? var myVar = 'value'; const myConst = 3.14; Answer 提升和临时死区是影响JavaScript变量生命周期的两个重要概念。 在声明之前访问 myVar 的结果为 undefined。在初始化之前，提升的 var 变量具有 undefined 的值。 然儿，在声明行之前访问 myConst 会引发 ReferenceError。const 变量处于临时死区，直到声明行 const myConst = 3.14。 8.最后... 您可以认为某些问题对面试毫无用处。我有同样的感觉，特别是关于鹰眼测试。尽管如此，他们可能会被问到。 无论如何，其中许多问题都可以真正评估您是否精通JavaScript，例如棘手的闭包。如果您在阅读帖子时遇到一些困难，这很好地表明了您接下来必须学习什么！ 原文：https://dmitripavlutin.com/simple-but-tricky-javascript-interview-questions/ 作者：Dmitri Pavlutin 翻译：做工程师不做码农 powered by Gitbook文件最后修改时间： 2024-08-15 10:52:42 "},"doc/面试题/009-浏览器http相关问题.html":{"url":"doc/面试题/009-浏览器http相关问题.html","title":"浏览器http相关问题","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 浏览器http相关问题 1. http常用状态码 2. Cookie session localstorage 区别 3. http和https的区别 [TOC] 浏览器http相关问题 1. http常用状态码 HTTP状态码（英语：HTTP Status Code）用来表示请求的结果，状态码被分为五大类： 100-199 信息，服务器收到请求，需要请求者继续执行操作。 200-299 表示请求成功，操作被成功接收并处理。 300-399 重定向，需要进一步的操作以完成请求。 400-499 表示浏览器方面出错。 500-599 表示服务器方面出错。 200：请求成功，202：请求已接收，但尚未处理完成，204：没有新文档，浏览器应该继续显示原来的文档。 300：重定向到多个地方，301：永久重定向到Location指定地址，302：临时重定向。304：使用缓存数据 400：请求出现语法错误，401：请求没有登录，需要登录，403：Forbidden资源不可用，没有权限服务器拒绝处理，404：Not Found，无法找到指定位置的资源，405：Method Not Allowed，请求方法不允许， 500：服务器遇到错误，不能完成请求，502：Bad Gateway，网关或者代理请求服务器无响应，504：Gateway Timeout，请求超时，长时间服务器无响应 2. Cookie session localstorage 区别 cookie是将数据存储在浏览器器上，容易被篡改，如果保存的是密码之类的最好先加密再保存。而且能存储的数据很少，大约只有4kb，能保存的个数也少；并且cookie只能保存字符串格式的参数。 session是将数据存储在服务器上，保密性好，不容易被篡改，并且能保存更多的数据，能保存的数据类型也更丰富。但因为session是将数据保存在服务器上，占用的是服务器内存，如果用户量过大，会影响到服务器的性能。 localStorage这个特性主要是用来作为本地存储来使用的，解决了cookie存储空间不足的问题(cookie中每条cookie的存储空间为4k)，localStorage中一般浏览器支持的是5M大小，这个在不同的浏览器中localStorage会有所不同。 localStorage的优势 1、localStorage拓展了cookie的4K限制 2、localStorage会将第一次请求的数据直接存储到本地，这个相当于一个5M大小的针对于前端页面的数据库，相比于cookie可以节约带宽，但是这个却是只有在高版本的浏览器中才支持的 localStorage的局限 1、浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性 2、目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换 3、localStorage在浏览器的隐私模式下面是不可读取的 4、localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡 localStorage与sessionStorage的唯一一点区别就是localStorage属于永久性存储，而sessionStorage属于当会话结束的时候，sessionStorage中的键值对会被清空 3. http和https的区别 一、HTTP和HTTPS的基本概念 　　HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。 　　HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 　　HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。 二、HTTP与HTTPS有什么区别？ 　　HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。 　　HTTPS和HTTP的区别主要如下： 　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 参考资料：https://www.cnblogs.com/wqhwe/p/5407468.html powered by Gitbook文件最后修改时间： 2020-04-21 20:08:33 "},"doc/面试题/010-这些前端基础题你能答对几道.html":{"url":"doc/面试题/010-这些前端基础题你能答对几道.html","title":"这些前端基础题你能答对几道","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 这些前端基础题你能答对几道？ 参考资料 [TOC] 这些前端基础题你能答对几道？ https://juejin.im/post/5ee03947e51d457889262921 参考资料 这些前端基础题你能答对几道？(测试你的基础掌握,附答案解析) powered by Gitbook文件最后修改时间： 2020-06-10 16:27:00 "},"doc/面试题/011-后端一次性丢给你10万条数据-怎么处理显示.html":{"url":"doc/面试题/011-后端一次性丢给你10万条数据-怎么处理显示.html","title":"后端一次性丢给你10万条数据-怎么处理显示","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 后端一次性丢给你10万条数据, 前端要怎么处理显示列表? 1. 初级工程师解决方案 2. 中级工程师的方案 3. 高级工程师的方案 [TOC] 后端一次性丢给你10万条数据, 前端要怎么处理显示列表? 转载整理自：https://zhuanlan.zhihu.com/p/147178478 后端由于某种原因没有实现分页功能, 所以一次性返回了2万条数据,让前端用select组件展示到用户界面里.如果通过硬编码的方式去直接渲染这两万条数据到select中,肯定会卡死. 后面他还说需要支持搜索, 也是前端来实现,我顿时产生了兴趣. 当时想到的方案大致如下: 1. 采用懒加载+分页(前端维护懒加载的数据分发和分页) 2. 使用虚拟滚动技术(目前react的antd4.0已支持虚拟滚动的select长列表) 懒加载和分页方式一般用于做长列表优化, 类似于表格的分页功能, 具体思路就是用户每次只加载能看见的数据, 当滚动到底部时再去加载下一页的数据. 虚拟滚动技术也可以用来优化长列表, 其核心思路就是每次只渲染可视区域的列表数,当滚动后动态的追加元素并通过顶部padding来撑起整个滚动内容,实现思路也非常简单. 1. 初级工程师解决方案 直接从后端请求数据, 渲染到页面的硬编码方案, 搜索也是从这些数据里面查找。 这样做本质上是可以实现基本的需求,但是有明显的缺点,那就是数据一次性渲染到页面中, 数据量庞大将导致页面性能极具降低, 造成页面卡顿. 2. 中级工程师的方案 作为一名有一定经验的前端开发工程师,一定对页面性能有所了解, 所以一定会熟悉防抖函数和节流函数, 并使用过诸如懒加载和分页这样的方案, 接下来我们看看中级工程师的方案: 通过这个过程的优化, 代码已经基本可用了, 下面来介绍具体实现方案: 1. 懒加载+分页方案 懒加载的实现主要是通过监听窗口的滚动, 当某一个占位元素可见之后去加载下一个数据,原理如下: 这里我们通过监听window的scroll事件以及对poll元素使用getBoundingClientRect来获取poll元素相对于可视窗口的距离, 从而自己实现一个懒加载方案. 在滚动的过程汇总我们还需要注意一个问题就是当用户往回滚动时, 实际上是不需要做任何处理的,所以我们需要加一个单向锁, 具体代码如下: function scrollAndLoading() { if(window.scrollY > prevY) { // 判断用户是否向下滚动 prevY = window.scrollY if(poll.current.getBoundingClientRect().top { // something code const getData = debounce(scrollAndLoading, 300) window.addEventListener('scroll', getData, false) return () => { window.removeEventListener('scroll', getData, false) } }, []) 其中prevY存储的是窗口上一次滚动的距离, 只有在向下滚动并且滚动高度大于上一次时才更新其值. 至于分页的逻辑, 原生javascript实现分页也很简单, 我们通过定义几个维度: curPage当前的页数 pageSize 每一页展示的数量 * data 传入的数据量 有了这几个条件,我们的基本能分页功能就可以完成了. 前端分页的核心代码如下: let data = []; let curPage = 1; let pageSize = 16; let prevY = 0; // other code... function scrollAndLoading() { if(window.scrollY > prevY) { // 判断用户是否向下滚动 prevY = window.scrollY if(poll.current.getBoundingClientRect().top 防抖函数实现 防抖函数因为比较简单, 这里直接上一个简单的防抖函数代码: function debounce(fn, time) { return function(args) { let that = this clearTimeout(fn.tid) fn.tid = setTimeout(() => { fn.call(that, args) }, time); } } 搜索实现 搜索功能代码如下: const handleSearch = (v) => { curPage = 1; prevY = 0; searchData = data.filter((item, i) => { // 采用正则来做匹配, 后期支持前端模糊搜索 let reg = new RegExp(v, 'gi') return reg.test(item.title) }) setList(searchData.slice(0, pageSize * curPage)) } 需要结合分页来实现, 所以这里为了不影响源数据, 我们采用临时数据searchData来存储. 3. 高级工程师的方案 作为一名久经战场的程序员, 我们应该考虑更优雅的实现方式,比如组件化, 算法优化, 多线程这类问题, 就比如我们问题中的大数据渲染, 我们也可以用虚拟长列表来更优雅简洁的来解决我们的需求. 至于虚拟长列表的实现笔者在开头已经点过,这里就不详细介绍了, 对于更大量的数据,比如100万(虽然实际开发中不会遇到这么无脑的场景),我们又该怎么处理呢? 第一个点我们可以使用js缓冲器来分片处理100万条数据, 思路代码如下: function multistep(steps,args,callback){ var tasks = steps.concat(); setTimeout(function(){ var task = tasks.shift(); task.apply(null, args || []); //调用Apply参数必须是数组 if(tasks.length > 0){ setTimeout(arguments.callee, 25); }else{ callback(); } },25); } 这样就能比较大量计算导致的js进程阻塞问题了.更多性能优化方案可以参考笔者之前的文章: web性能优化的15条实用技巧：https://zhuanlan.zhihu.com/p/94226707 我们还可以通过web worker来将需要在前端进行大量计算的逻辑移入进去, 保证js主进程的快速响应, 让web worker线程在后台计算, 计算完成后再通过web worker的通信机制来通知主进程, 比如模糊搜索等, 我们还可以对搜索算法进一步优化,比如二分法等,所以这些都是高级工程师该考虑的问题. 但是一定要分清场景, 寻找出性价比更高的方案. powered by Gitbook文件最后修改时间： 2020-06-11 22:59:03 "},"doc/面试题/012-说说你对options请求的理解.html":{"url":"doc/面试题/012-说说你对options请求的理解.html","title":"说说你对options请求的理解","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 说说你对 options 请求的理解 1. 什么是 options 请求 2. 简单请求与复杂请求 2.1 简单请求 2.2 复杂请求 3. options 关键的请求头字段 3.1 request header 的关键字段 3.2 response header 的关键字段 4. Options 请求优化 参考资料 [TOC] 说说你对 options 请求的理解 转载自：https://mp.weixin.qq.com/s/Fs9NO5mpcHQdDXrRn0P2JQ options 请求就是预检请求，可用于检测服务器允许的 http 方法。当发起跨域请求时，由于安全原因，触发一定条件时浏览器会在正式请求之前自动先发起 OPTIONS 请求，即 CORS 预检请求，服务器若接受该跨域请求，浏览器才继续发起正式请求。 1. 什么是 options 请求 MDN 中的一段描述： HTTP 的 OPTIONS 方法 用于获取目的资源所支持的通信选项。客户端可以对特定的 URL 使用 OPTIONS 方法，也可以对整站（通过将 URL 设置为“*”）使用该方法。 简单来说，就是可以用 options 请求去嗅探某个请求在对应的服务器中都支持哪种请求方法。 在前端中我们一般不会主动发起这个请求，但是往往你可以看到浏览器中相同的请求发起了 2 次，如图： 其实，这是因为在跨域的情况下，在浏览器发起\"复杂请求\"时主动发起的。跨域共享标准规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。 2. 简单请求与复杂请求 某些请求不会触发 CORS 预检请求，这样的请求一般称为\"简单请求\",而会触发预检的请求则称为\"复杂请求\"。 2.1 简单请求 请求方法为GET、HEAD、POST时发的请求 人为设置了规范集合之内的首部字段，如Accept/Accept-Language/Content-Language/Content-Type/DPR/Downlink/Save-Data/Viewport-Width/Width Content-Type 的值仅限于下列三者之一,即application/x-www-form-urlencoded、multipart/form-data、text/plain 请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； 请求中没有使用 ReadableStream 对象。 2.2 复杂请求 使用了下面任一 HTTP 方法，PUT/DELETE/CONNECT/OPTIONS/TRACE/PATCH 人为设置了以下集合之外首部字段，即简单请求外的字段 Content-Type 的值不属于下列之一，即application/x-www-form-urlencoded、multipart/form-data、text/plain 3. options 关键的请求头字段 3.1 request header 的关键字段 关键字段 作用 Access-Control-Request-Method 告知服务器，实际请求将使用 POST 方法 Access-Control-Request-Headers 告知服务器，实际请求将携带的自定义请求首部字段 如： Access-Control-Request-Method: POST Access-Control-Request-Headers: X-PINGOTHER, Content-Type 3.2 response header 的关键字段 关键字段 作用 Access-Control-Allow-Methods 表明服务器允许客户端使用什么方法发起请求 Access-Control-Allow-Origin 允许跨域请求的域名，如果要允许所有域名则设置为 * Access-Control-Allow-Headers 将实际请求所携带的首部字段告诉服务器 Access-Control-Max-Age 指定了预检请求的结果能够被缓存多久 4. Options 请求优化 当我们发起跨域请求时，如果是简单请求，那么我们只会发出一次请求，但是如果是复杂请求则先发出 options 请求，用于确认目标资源是否支持跨域，然后浏览器会根据服务端响应的 header 自动处理剩余的请求，如果响应支持跨域，则继续发出正常请求，如果不支持，则在控制台显示错误。 由此可见，当触发预检时，跨域请求便会发送 2 次请求，既增加了请求数，也延迟了请求真正发起的时间，严重影响性能。 所以，我们可以优化 Options 请求，主要有 2 种方法。 转为简单请求，如用 JSONP 做跨域请求 对 options 请求进行缓存，服务器端设置 Access-Control-Max-Age 字段，那么当第一次请求该 URL 时会发出 OPTIONS 请求，浏览器会根据返回的 Access-Control-Max-Age 字段缓存该请求的 OPTIONS 预检请求的响应结果（具体缓存时间还取决于浏览器的支持的默认最大值，取两者最小值，一般为 10 分钟）。在缓存有效期内，该资源的请求（URL 和 header 字段都相同的情况下）不会再触发预检。（chrome 打开控制台可以看到，当服务器响应 Access-Control-Max-Age 时只有第一次请求会有预检，后面不会了。注意要开启缓存，去掉 disable cache 勾选。） 参考资料 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#Preflighted_requests https://zhuanlan.zhihu.com/p/70032617 powered by Gitbook文件最后修改时间： 2020-06-16 23:10:01 "}}